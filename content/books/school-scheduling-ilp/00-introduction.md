# The Mathematics of Impossible Puzzles

Every fall, administrators at thousands of schools face the same impossible task. Teachers have preferences. Rooms have capacities. Students need courses. Time is finite. The combinations number in the millions. Yet by the first day of class, students sit in desks, teachers stand at boards, and the year begins. Someone solved the puzzle.

For decades, that someone was a veteran administrator with institutional memory and a wall covered in sticky notes. They knew that Mrs. Patterson absolutely cannot teach first period because she drives from two towns over. They remembered that the physics lab is being renovated until October. They internalized years of informal negotiations about who gets the good rooms and who teaches the dreaded Friday afternoon slots.

This approach works until it doesn't. The veteran retires. The school grows. Requirements compound. What once took a week of shuffling takes a month. What once felt like mastery feels like drowning. The sticky notes fall off the wall.

Computer-assisted scheduling emerged from operations research, a field that applies mathematics to complex logistical problems. The techniques developed during World War II to optimize supply chains and military operations found peacetime applications in airlines, factories, and eventually schools. The core insight was that many apparently impossible puzzles become tractable when expressed as mathematical models.

Integer Linear Programming represents one of the most powerful approaches to scheduling problems. The technique expresses what you want as an objective to maximize or minimize, what you must have as constraints that cannot be violated, and what you'd prefer as soft constraints that carry penalties when violated. A solver—a sophisticated mathematical engine—explores the space of possible solutions and finds one that optimizes the objective while satisfying the constraints.

The scheduling problem is NP-hard, which means no algorithm can guarantee finding the optimal solution quickly for all cases. But practical instances usually aren't worst cases. Modern solvers incorporate decades of algorithmic improvements—branch and bound, cutting planes, preprocessing, parallel search—that make real-world problems tractable. A schedule that would take a human weeks to construct by trial and error can often be computed in minutes.

Building a school scheduling system with vibe coding proved to be an ideal match for several reasons. The mathematical formulation is well-documented in academic literature. The constraints are explicit and logical—no room can host two classes simultaneously, no teacher can be in two places at once. The objective function is a matter of policy decisions, not technical discovery. What remains is translating these requirements into working software, which is exactly what AI-assisted development excels at.

The system that emerged from my Claude Code sessions handles the complete workflow. Data entry captures teachers, classes, rooms, and time slots. Constraint specification lets administrators express both hard requirements and soft preferences. The solver generates schedules that satisfy requirements while optimizing preferences. The interface displays results, highlights conflicts, and enables manual adjustments. Export produces calendar files that integrate with other systems.

Alternative approaches exist but fall short in various ways. Genetic algorithms are popular but unreliable—they get stuck in local optima and offer no guarantee of finding feasible solutions. Constraint programming works for small problems but struggles to scale. Manual scheduling is error-prone and exhausting. Commercial scheduling software costs tens of thousands of dollars annually, often runs as inflexible black boxes, and locks institutions into vendor relationships.

Integer Linear Programming gives you mathematical guarantees, scalability, transparency, and control. The model is visible and understandable. You can explain why an assignment was made by pointing to the constraints it satisfies. When the solver says no feasible schedule exists, you can analyze which constraints conflict. This transparency builds trust in a way that black-box solutions never can.

Building this system revealed patterns that apply to any optimization problem. How to represent decision variables. How to express constraints that solvers understand. How to weight competing objectives. How to interpret solver results. How to handle infeasibility gracefully. These patterns transfer to employee scheduling, sports league fixtures, exam timetabling, and dozens of other domains where ILP shines.

The book that follows documents this journey. Not as a tutorial to copy line by line, but as a guide to the concepts and techniques that make such systems possible. The specific implementations belong to your vibe coding sessions. The understanding of why those implementations work belongs here.

By the end, you'll grasp how to model a scheduling problem as ILP, how to build a solver integration that produces real schedules, how to present those schedules through a usable interface, and how to handle the edge cases that make production systems robust. More importantly, you'll understand a category of problems that mathematical optimization solves elegantly—problems that appear impossible until you learn to think in constraints.
