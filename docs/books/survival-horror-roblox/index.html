<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>How to Vibe Code a Survival Horror Game in Roblox | metavibe</title>
  <meta name="description" content="A practical guide to building survival horror games in Roblox using">
  <style>
    :root {
      --bg: #fdfcfa;
      --text: #1a1a1a;
      --text-muted: #666;
      --accent: #6366f1;
      --border: #e5e5e5;
      --code-bg: #f3f4f6;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #111;
        --text: #e5e5e5;
        --text-muted: #999;
        --border: #333;
        --code-bg: #1a1a1a;
      }
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Charter', 'Bitstream Charter', Georgia, serif;
      line-height: 1.7;
      color: var(--text);
      background: var(--bg);
    }
    .container { max-width: 720px; margin: 0 auto; padding: 2rem; }
    header { margin-bottom: 2rem; padding-bottom: 1rem; border-bottom: 1px solid var(--border); }
    h1 { font-size: 2rem; font-weight: 700; margin-bottom: 0.5rem; font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
    .subtitle { color: var(--text-muted); font-size: 1.1rem; }
    .back { display: inline-block; margin-bottom: 1rem; color: var(--accent); text-decoration: none; font-family: sans-serif; font-size: 0.9rem; }
    .back:hover { text-decoration: underline; }
    nav { margin: 2rem 0; padding: 1.5rem; background: var(--code-bg); border-radius: 8px; }
    nav h2 { font-size: 1rem; margin-bottom: 1rem; font-family: sans-serif; }
    nav ul { list-style: none; padding-left: 0; }
    nav li { margin: 0.5rem 0; }
    nav a { color: var(--accent); text-decoration: none; }
    nav a:hover { text-decoration: underline; }
    .chapter { margin: 3rem 0; padding-top: 2rem; border-top: 1px solid var(--border); }
    h2 { font-size: 1.5rem; font-weight: 600; margin: 2rem 0 1rem; font-family: sans-serif; }
    h3 { font-size: 1.25rem; font-weight: 600; margin: 1.5rem 0 0.75rem; font-family: sans-serif; }
    p { margin: 1rem 0; }
    a { color: var(--accent); }
    code { font-family: 'SF Mono', Monaco, monospace; font-size: 0.9em; background: var(--code-bg); padding: 0.2em 0.4em; border-radius: 3px; }
    pre { background: var(--code-bg); padding: 1rem; border-radius: 6px; overflow-x: auto; margin: 1rem 0; }
    pre code { background: none; padding: 0; font-size: 0.85em; }
    strong { font-weight: 600; }
    ul, ol { margin: 1rem 0; padding-left: 1.5rem; }
    li { margin: 0.5rem 0; }
    footer { margin-top: 4rem; padding-top: 2rem; border-top: 1px solid var(--border); text-align: center; color: var(--text-muted); font-size: 0.9rem; font-family: sans-serif; }
  </style>
</head>
<body>
  <div class="container">
    <a href="../../" class="back">← Back to all books</a>
    <header>
      <h1>How to Vibe Code a Survival Horror Game in Roblox</h1>
      <p class="subtitle">Building atmospheric horror experiences with AI-assisted Luau development</p>
    </header>

    <nav>
      <h2>Table of Contents</h2>
      <ul>
        <li><a href="#chapter-0">Introduction</a></li>
<li><a href="#chapter-1">Project Setup with Rojo</a></li>
<li><a href="#chapter-2">Creating Atmosphere</a></li>
<li><a href="#chapter-3">Creature AI and Threats</a></li>
<li><a href="#chapter-4">Survival Mechanics</a></li>
<li><a href="#chapter-5">Environment and Level Design</a></li>
<li><a href="#chapter-6">Multiplayer Systems</a></li>
<li><a href="#chapter-7">Polish and Publishing</a></li>
      </ul>
    </nav>

    <main>
      
    <section id="chapter-0" class="chapter">
      <h2>Introduction</h2>
      <p>Horror games have a unique power: they make players <em>feel</em> something. Not just challenged or entertained, but genuinely unsettled. Building that experience is hard. Building it in Roblox—a platform often associated with casual games—is harder.</p><p>This book shows you how.</p><h2>Why Survival Horror?</h2><p>Survival horror sits at the intersection of several game design challenges:</p><p>1. <strong>Atmosphere over action</strong> - You can't just throw enemies at players. The tension must build through environment, sound, and pacing.</p><p>2. <strong>Resource scarcity</strong> - Every bullet, every health kit matters. Managing scarcity creates genuine stakes.</p><p>3. <strong>Vulnerability</strong> - Players must feel underpowered. The creature is a threat, not a target.</p><p>4. <strong>Mystery</strong> - Horror thrives on the unknown. What's behind that door? What made that sound?</p><p>These constraints force you to think deeply about game design. You can't brute-force a horror game with better graphics or more content.</p><h2>Why Roblox?</h2><p>Roblox might seem like an odd choice for horror. But consider:</p><p>- <strong>Massive audience</strong> - Millions of players, many hungry for new experiences<br>
- <strong>Low friction</strong> - Players don't download your game, they just join<br>
- <strong>Multiplayer built-in</strong> - Co-op horror is trivial to implement<br>
- <strong>Lua/Luau</strong> - A forgiving, expressive scripting language<br>
- <strong>Rojo</strong> - Professional tooling for version control and team development</p><p>The platform's limitations actually help. You can't rely on photorealistic graphics, so you focus on what matters: atmosphere, sound, and mechanics.</p><h2>Why Vibe Code It?</h2><p>Vibe coding is AI-assisted development where you describe what you want and let AI handle the implementation. For game development, this means:</p><p>- <strong>Rapid prototyping</strong> - Describe a creature behavior, get working code in minutes<br>
- <strong>Exploring ideas</strong> - "What if the creature could hear the player's footsteps?" Try it immediately.<br>
- <strong>Learning Roblox APIs</strong> - AI knows the platform better than you do (at first)<br>
- <strong>Staying in flow</strong> - Less time debugging syntax, more time designing</p><p>This book doesn't just teach you Roblox game development. It teaches you how to <em>collaborate with AI</em> to build games faster than you thought possible.</p><h2>What We'll Build</h2><p>By the end of this book, you'll have built:</p><p>- A complete survival horror game framework<br>
- Atmospheric lighting and sound systems<br>
- Creature AI with detection and chase behaviors<br>
- Survival mechanics (health, stamina, inventory, crafting)<br>
- Terrain and level design tools<br>
- Multiplayer support for co-op horror</p><p>More importantly, you'll understand the <em>patterns</em> behind these systems. Every horror game is different, but the principles transfer.</p><h2>Prerequisites</h2><p>You'll need:</p><p>- <strong>Roblox Studio</strong> - The development environment<br>
- <strong>Rojo</strong> - For professional project management (<code>cargo install rojo</code> or use the VS Code extension)<br>
- <strong>Git</strong> - For version control<br>
- <strong>An AI assistant</strong> - Claude Code, Cursor, or similar<br>
- <strong>Basic Luau knowledge</strong> - Variables, functions, tables. We'll teach the rest.</p><h2>How to Use This Book</h2><p>Each chapter builds on the previous one, but they're designed to be self-contained references. Read front-to-back for a complete learning experience, or jump to specific chapters when you need them.</p><p>Code examples are practical, not minimal. We show you real patterns from production games, not toy examples that fall apart at scale.</p><p>Let's build something scary.<br>
</p>
    </section>
  

    <section id="chapter-1" class="chapter">
      <h2>Project Setup with Rojo</h2>
      <p>Before we write any game code, we need a professional development setup. Roblox Studio is great for building, but for serious games you need version control, team collaboration, and a workflow that doesn't involve clicking through menus.</p><p>That's where Rojo comes in.</p><h2>What is Rojo?</h2><p>Rojo is a project management tool that syncs files on your computer with Roblox Studio. Instead of editing scripts inside Studio, you edit <code>.luau</code> files in VS Code (or any editor) and Rojo keeps them in sync.</p><p>Why does this matter?</p><p>- <strong>Git version control</strong> - Track every change, branch for features, review code in PRs<br>
- <strong>Real editor</strong> - Use VS Code with proper Lua extensions, not Studio's limited editor<br>
- <strong>Team collaboration</strong> - Multiple people can work on the same project<br>
- <strong>AI assistance</strong> - Claude Code and Cursor work with files, not Studio</p><h2>Installing Rojo</h2><h3>Option 1: Cargo (Recommended)</h3><p>If you have Rust installed:</p><pre><code class="language-bash">cargo install rojo</code></pre><h3>Option 2: VS Code Extension</h3><p>Install the "Rojo" extension from the VS Code marketplace. It includes the Rojo binary.</p><h3>Option 3: GitHub Releases</h3><p>Download the binary from <a href="https://rojo.space">rojo.space</a> and add it to your PATH.</p><p>Verify installation:</p><pre><code class="language-bash">rojo --version</code></pre><h2>Project Structure</h2><p>A well-organized Roblox project looks like this:</p><pre><code class="language-">my-horror-game/<br>
├── src/<br>
│   ├── client/           # StarterPlayerScripts<br>
│   ├── server/           # ServerScriptService<br>
│   └── shared/           # ReplicatedStorage<br>
├── assets/               # Models, sounds (optional, can stay in Studio)<br>
├── tests/                # TestEZ tests<br>
├── default.project.json  # Rojo configuration<br>
├── wally.toml           # Package manager (optional)<br>
└── README.md</code></pre><h2>Creating the Project File</h2><p>Create <code>default.project.json</code>:</p><pre><code class="language-json">{<br>
  &quot;name&quot;: &quot;HorrorGame&quot;,<br>
  &quot;tree&quot;: {<br>
    &quot;$className&quot;: &quot;DataModel&quot;,</p><p>    &quot;ReplicatedStorage&quot;: {<br>
      &quot;$className&quot;: &quot;ReplicatedStorage&quot;,<br>
      &quot;Shared&quot;: {<br>
        &quot;$path&quot;: &quot;src/shared&quot;<br>
      }<br>
    },</p><p>    &quot;ServerScriptService&quot;: {<br>
      &quot;$className&quot;: &quot;ServerScriptService&quot;,<br>
      &quot;Server&quot;: {<br>
        &quot;$path&quot;: &quot;src/server&quot;<br>
      }<br>
    },</p><p>    &quot;StarterPlayer&quot;: {<br>
      &quot;$className&quot;: &quot;StarterPlayer&quot;,<br>
      &quot;StarterPlayerScripts&quot;: {<br>
        &quot;$className&quot;: &quot;StarterPlayerScripts&quot;,<br>
        &quot;Client&quot;: {<br>
          &quot;$path&quot;: &quot;src/client&quot;<br>
        }<br>
      }<br>
    },</p><p>    &quot;Lighting&quot;: {<br>
      &quot;$className&quot;: &quot;Lighting&quot;,<br>
      &quot;$properties&quot;: {<br>
        &quot;Brightness&quot;: 0.5,<br>
        &quot;ClockTime&quot;: 0,<br>
        &quot;Ambient&quot;: [0.05, 0.05, 0.08],<br>
        &quot;FogEnd&quot;: 200,<br>
        &quot;FogColor&quot;: [0.1, 0.1, 0.12]<br>
      }<br>
    }<br>
  }<br>
}</code></pre><p>This tells Rojo:<br>
- Scripts in <code>src/server/</code> go to ServerScriptService<br>
- Scripts in <code>src/client/</code> go to StarterPlayerScripts<br>
- Scripts in <code>src/shared/</code> go to ReplicatedStorage<br>
- Lighting starts dark and foggy (horror defaults)</p><h2>Client-Server Architecture</h2><p>Roblox enforces a client-server model:</p><p><strong>Server</strong> (<code>src/server/</code>)<br>
- Runs on Roblox's servers<br>
- Has authority over game state<br>
- Can access datastores<br>
- Scripts end in <code>.server.luau</code></p><p><strong>Client</strong> (<code>src/client/</code>)<br>
- Runs on each player's device<br>
- Handles input and UI<br>
- Can be exploited—never trust client data<br>
- Scripts end in <code>.client.luau</code></p><p><strong>Shared</strong> (<code>src/shared/</code>)<br>
- Code used by both client and server<br>
- No automatic execution—must be <code>require()</code>d<br>
- Great for utility functions and types<br>
- Scripts end in <code>.luau</code> (no server/client suffix)</p><h2>Your First Scripts</h2><p>Create <code>src/server/Init.server.luau</code>:</p><pre><code class="language-lua">-- Server initialization<br>
print(&quot;Server starting...&quot;)</p><p>-- Game state<br>
local GameState = {<br>
    isNight = true,<br>
    threatLevel = 0,<br>
    playersAlive = 0,<br>
}</p><p>-- Wait for players<br>
game.Players.PlayerAdded:Connect(function(player)<br>
    print(player.Name .. &quot; joined&quot;)<br>
    GameState.playersAlive += 1<br>
end)</p><p>game.Players.PlayerRemoving:Connect(function(player)<br>
    GameState.playersAlive -= 1<br>
end)</code></pre><p>Create <code>src/client/Init.client.luau</code>:</p><pre><code class="language-lua">-- Client initialization<br>
print(&quot;Client starting...&quot;)</p><p>local player = game.Players.LocalPlayer<br>
local playerGui = player:WaitForChild(&quot;PlayerGui&quot;)</p><p>-- Basic horror UI setup<br>
local screenGui = Instance.new(&quot;ScreenGui&quot;)<br>
screenGui.Name = &quot;HorrorUI&quot;<br>
screenGui.Parent = playerGui</code></pre><p>Create <code>src/shared/Config.luau</code>:</p><pre><code class="language-lua">-- Shared configuration<br>
return {<br>
    -- Player settings<br>
    PLAYER_WALK_SPEED = 12,<br>
    PLAYER_RUN_SPEED = 20,<br>
    PLAYER_MAX_STAMINA = 100,<br>
    STAMINA_DRAIN_RATE = 10,<br>
    STAMINA_REGEN_RATE = 5,</p><p>    -- Creature settings<br>
    CREATURE_DETECTION_RADIUS = 50,<br>
    CREATURE_CHASE_SPEED = 18,<br>
    CREATURE_PATROL_SPEED = 8,</p><p>    -- World settings<br>
    DAY_LENGTH = 600,  -- seconds<br>
    NIGHT_LENGTH = 300,<br>
}</code></pre><h2>Running with Rojo</h2><p>Start the Rojo server:</p><pre><code class="language-bash">rojo serve</code></pre><p>In Roblox Studio:<br>
1. Open a new place (or your existing place)<br>
2. Go to Plugins → Rojo<br>
3. Click "Connect"<br>
4. Your files now sync automatically</p><p>Every time you save a <code>.luau</code> file, it appears in Studio instantly.</p><h2>Git Setup</h2><p>Initialize version control:</p><pre><code class="language-bash">git init<br>
echo &quot;*.rbxl&quot; &gt;&gt; .gitignore<br>
echo &quot;*.rbxlx&quot; &gt;&gt; .gitignore<br>
echo &quot;.DS_Store&quot; &gt;&gt; .gitignore<br>
git add .<br>
git commit -m &quot;Initial project setup&quot;</code></pre><p>The <code>.rbxl</code> files are Roblox place files—large binary files that don't version control well. With Rojo, your source of truth is the <code>src/</code> directory.</p><h2>Vibe Coding the Setup</h2><p>When setting up a new Roblox project with AI assistance, try prompts like:</p><p>> "Create a Rojo project structure for a survival horror game with client-server separation"</p><p>> "Add a shared Config module with settings for player movement, stamina, and creature behavior"</p><p>> "Set up dark, foggy lighting defaults appropriate for a horror game"</p><p>The AI can generate the boilerplate instantly, letting you focus on what makes your game unique.</p><h2>Next Steps</h2><p>With the project structure in place, we can start building the actual game. In the next chapter, we'll create the atmospheric lighting and sound systems that make horror games feel terrifying.<br>
</p>
    </section>
  

    <section id="chapter-2" class="chapter">
      <h2>Creating Atmosphere</h2>
      <p>Horror games live and die by atmosphere. A dark corridor is just a dark corridor—until the lighting flickers, the music shifts, and you hear something breathing behind you.</p><p>This chapter covers the technical systems that create dread.</p><h2>Lighting for Horror</h2><p>Roblox's Lighting service controls the entire visual mood. For horror, we want:</p><p>- <strong>Low ambient light</strong> - Players can't see everything clearly<br>
- <strong>Fog</strong> - Limits visibility, creates uncertainty<br>
- <strong>Strategic light sources</strong> - Draw attention, create shadows<br>
- <strong>Color grading</strong> - Desaturated, cold tones</p><h3>Base Horror Lighting</h3><p>In your project file or via script:</p><pre><code class="language-lua">-- src/server/Atmosphere.server.luau<br>
local Lighting = game:GetService(&quot;Lighting&quot;)</p><p>-- Base horror settings<br>
Lighting.Brightness = 0.3<br>
Lighting.Ambient = Color3.fromRGB(15, 15, 25)<br>
Lighting.OutdoorAmbient = Color3.fromRGB(20, 20, 30)<br>
Lighting.FogEnd = 150<br>
Lighting.FogStart = 0<br>
Lighting.FogColor = Color3.fromRGB(20, 20, 25)</p><p>-- Color correction for desaturated look<br>
local colorCorrection = Instance.new(&quot;ColorCorrectionEffect&quot;)<br>
colorCorrection.Saturation = -0.3<br>
colorCorrection.Contrast = 0.1<br>
colorCorrection.TintColor = Color3.fromRGB(200, 200, 220)<br>
colorCorrection.Parent = Lighting</p><p>-- Bloom for light sources to pop<br>
local bloom = Instance.new(&quot;BloomEffect&quot;)<br>
bloom.Intensity = 0.5<br>
bloom.Size = 24<br>
bloom.Threshold = 0.8<br>
bloom.Parent = Lighting</code></pre><h3>Dynamic Lighting Changes</h3><p>Horror isn't static. Lights should flicker, areas should get darker as danger approaches:</p><pre><code class="language-lua">-- src/shared/LightingUtils.luau<br>
local TweenService = game:GetService(&quot;TweenService&quot;)<br>
local Lighting = game:GetService(&quot;Lighting&quot;)</p><p>local LightingUtils = {}</p><p>function LightingUtils.transitionTo(settings, duration)<br>
    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Sine)</p><p>    for property, value in pairs(settings) do<br>
        local tween = TweenService:Create(Lighting, tweenInfo, {<br>
            [property] = value<br>
        })<br>
        tween:Play()<br>
    end<br>
end</p><p>function LightingUtils.flickerLight(light, duration, intensity)<br>
    local original = light.Brightness<br>
    local flickerCount = math.floor(duration / 0.1)</p><p>    task.spawn(function()<br>
        for i = 1, flickerCount do<br>
            light.Brightness = original <em> (math.random() </em> intensity)<br>
            task.wait(0.05 + math.random() * 0.1)<br>
        end<br>
        light.Brightness = original<br>
    end)<br>
end</p><p>function LightingUtils.setThreatLevel(level)<br>
    -- 0 = safe, 1 = maximum danger<br>
    level = math.clamp(level, 0, 1)</p><p>    local settings = {<br>
        FogEnd = 200 - (level * 100),  -- Fog closes in<br>
        Brightness = 0.5 - (level * 0.3),  -- Gets darker<br>
    }</p><p>    LightingUtils.transitionTo(settings, 2)<br>
end</p><p>return LightingUtils</code></pre><h2>Day/Night Cycles</h2><p>Many horror games use time of day to pace tension. Daytime for exploration, nighttime for survival.</p><pre><code class="language-lua">-- src/server/DayNight.server.luau<br>
local Lighting = game:GetService(&quot;Lighting&quot;)<br>
local Config = require(game.ReplicatedStorage.Shared.Config)</p><p>local DayNight = {<br>
    currentTime = 6,  -- Start at 6 AM<br>
    isPaused = false,<br>
}</p><p>local TIME_PHASES = {<br>
    { hour = 6, name = &quot;Dawn&quot;, brightness = 0.5, fogEnd = 300 },<br>
    { hour = 12, name = &quot;Day&quot;, brightness = 1, fogEnd = 500 },<br>
    { hour = 18, name = &quot;Dusk&quot;, brightness = 0.4, fogEnd = 200 },<br>
    { hour = 22, name = &quot;Night&quot;, brightness = 0.1, fogEnd = 100 },<br>
    { hour = 2, name = &quot;DeadOfNight&quot;, brightness = 0.05, fogEnd = 50 },<br>
}</p><p>function DayNight.getCurrentPhase()<br>
    local hour = DayNight.currentTime<br>
    for i = #TIME_PHASES, 1, -1 do<br>
        if hour &gt;= TIME_PHASES[i].hour then<br>
            return TIME_PHASES[i]<br>
        end<br>
    end<br>
    return TIME_PHASES[#TIME_PHASES]  -- Wrap to dead of night<br>
end</p><p>function DayNight.update()<br>
    if DayNight.isPaused then return end</p><p>    -- Calculate time increment<br>
    local isDay = DayNight.currentTime &gt;= 6 and DayNight.currentTime &lt; 22<br>
    local cycleDuration = isDay and Config.DAY_LENGTH or Config.NIGHT_LENGTH<br>
    local hoursInPhase = isDay and 16 or 8<br>
    local timePerSecond = hoursInPhase / cycleDuration</p><p>    DayNight.currentTime = (DayNight.currentTime + timePerSecond) % 24<br>
    Lighting.ClockTime = DayNight.currentTime</p><p>    local phase = DayNight.getCurrentPhase()<br>
    -- Smoothly transition lighting<br>
    Lighting.Brightness = phase.brightness<br>
    Lighting.FogEnd = phase.fogEnd<br>
end</p><p>-- Run update loop<br>
task.spawn(function()<br>
    while true do<br>
        DayNight.update()<br>
        task.wait(1)<br>
    end<br>
end)</p><p>return DayNight</code></pre><h2>Sound Design</h2><p>Sound is half of horror. Visuals tell you what's there; sound tells you what <em>might</em> be there.</p><h3>Ambient Sound Layers</h3><p>Layer multiple sound sources:</p><p>1. <strong>Base ambience</strong> - Constant low drone, wind, distant sounds<br>
2. <strong>Environmental</strong> - Dripping water, creaking wood, electrical hum<br>
3. <strong>Dynamic stingers</strong> - Sharp sounds when danger appears<br>
4. <strong>Music</strong> - Tension-building tracks that respond to game state</p><pre><code class="language-lua">-- src/client/SoundManager.client.luau<br>
local SoundService = game:GetService(&quot;SoundService&quot;)</p><p>local SoundManager = {<br>
    layers = {},<br>
}</p><p>function SoundManager.createLayer(name, soundId, properties)<br>
    local sound = Instance.new(&quot;Sound&quot;)<br>
    sound.SoundId = soundId<br>
    sound.Name = name<br>
    sound.Looped = properties.looped or false<br>
    sound.Volume = properties.volume or 0.5<br>
    sound.Parent = SoundService</p><p>    SoundManager.layers[name] = sound<br>
    return sound<br>
end</p><p>function SoundManager.playStinger(soundId, volume)<br>
    local stinger = Instance.new(&quot;Sound&quot;)<br>
    stinger.SoundId = soundId<br>
    stinger.Volume = volume or 1<br>
    stinger.Parent = SoundService<br>
    stinger:Play()<br>
    stinger.Ended:Connect(function()<br>
        stinger:Destroy()<br>
    end)<br>
end</p><p>function SoundManager.setThreatLevel(level)<br>
    -- Crossfade between calm and tense ambience<br>
    local calmLayer = SoundManager.layers[&quot;Calm&quot;]<br>
    local tenseLayer = SoundManager.layers[&quot;Tense&quot;]</p><p>    if calmLayer then<br>
        calmLayer.Volume = (1 - level) * 0.5<br>
    end<br>
    if tenseLayer then<br>
        tenseLayer.Volume = level * 0.7<br>
    end<br>
end</p><p>-- Initialize base layers<br>
SoundManager.createLayer(&quot;Calm&quot;, &quot;rbxassetid://YOUR_CALM_AMBIENT&quot;, {<br>
    looped = true,<br>
    volume = 0.5,<br>
})<br>
SoundManager.createLayer(&quot;Tense&quot;, &quot;rbxassetid://YOUR_TENSE_AMBIENT&quot;, {<br>
    looped = true,<br>
    volume = 0,<br>
})</p><p>-- Start playback<br>
for _, sound in pairs(SoundManager.layers) do<br>
    sound:Play()<br>
end</p><p>return SoundManager</code></pre><h3>Positional Audio</h3><p>Sounds in 3D space are crucial for horror. Players should hear the creature before they see it:</p><pre><code class="language-lua">function SoundManager.playAtPosition(soundId, position, properties)<br>
    local part = Instance.new(&quot;Part&quot;)<br>
    part.Anchored = true<br>
    part.CanCollide = false<br>
    part.Transparency = 1<br>
    part.Position = position<br>
    part.Parent = workspace</p><p>    local sound = Instance.new(&quot;Sound&quot;)<br>
    sound.SoundId = soundId<br>
    sound.RollOffMode = Enum.RollOffMode.Linear<br>
    sound.RollOffMinDistance = properties.minDistance or 10<br>
    sound.RollOffMaxDistance = properties.maxDistance or 100<br>
    sound.Volume = properties.volume or 1<br>
    sound.Parent = part</p><p>    sound:Play()<br>
    sound.Ended:Connect(function()<br>
        part:Destroy()<br>
    end)</p><p>    return sound<br>
end</code></pre><h2>Environmental Storytelling</h2><p>The environment itself tells the story. Players should discover what happened through:</p><p>- <strong>Visual details</strong> - Blood stains, claw marks, abandoned items<br>
- <strong>Notes and logs</strong> - Text that reveals backstory<br>
- <strong>Environmental changes</strong> - Areas that look different after events<br>
- <strong>Interactive objects</strong> - Things players can examine</p><pre><code class="language-lua">-- src/server/Discovery.server.luau<br>
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)</p><p>local Discovery = {<br>
    foundItems = {},  -- Track per-player<br>
}</p><p>local DISCOVERABLE_ITEMS = {<br>
    {<br>
        id = &quot;note_1&quot;,<br>
        type = &quot;note&quot;,<br>
        title = &quot;Researcher's Log&quot;,<br>
        content = &quot;Day 15. The readings are off the charts. Something is wrong with the samples...&quot;,<br>
    },<br>
    {<br>
        id = &quot;audio_1&quot;,<br>
        type = &quot;audio&quot;,<br>
        title = &quot;Emergency Recording&quot;,<br>
        soundId = &quot;rbxassetid://YOUR_AUDIO&quot;,<br>
    },<br>
}</p><p>function Discovery.onItemDiscovered(player, itemId)<br>
    if not Discovery.foundItems[player] then<br>
        Discovery.foundItems[player] = {}<br>
    end</p><p>    if Discovery.foundItems[player][itemId] then<br>
        return false  -- Already found<br>
    end</p><p>    Discovery.foundItems[player][itemId] = true</p><p>    -- Fire event to client<br>
    local item = nil<br>
    for _, i in ipairs(DISCOVERABLE_ITEMS) do<br>
        if i.id == itemId then<br>
            item = i<br>
            break<br>
        end<br>
    end</p><p>    if item then<br>
        ReplicatedStorage.Events.ItemDiscovered:FireClient(player, item)<br>
    end</p><p>    return true<br>
end</p><p>return Discovery</code></pre><h2>Vibe Coding Atmosphere</h2><p>When working with AI on atmosphere systems:</p><p>> "Create a lighting system that gradually gets darker and foggier as threat level increases from 0 to 1"</p><p>> "Implement a sound manager with layered ambient sounds that crossfade based on game state"</p><p>> "Add a day/night cycle where nights are shorter but much more dangerous"</p><p>The AI excels at these systems because they're well-defined: input (threat level, time) → output (lighting, sound). Let it handle the math while you focus on the <em>feel</em>.</p><h2>Testing Atmosphere</h2><p>Atmosphere is subjective. Test with:</p><p>1. <strong>Screenshots at different times</strong> - Do key moments look right?<br>
2. <strong>Playtests with fresh eyes</strong> - Does it feel tense to someone who hasn't seen it 100 times?<br>
3. <strong>Audio-only tests</strong> - Close your eyes and listen. Does the sound alone create unease?</p><h2>Next Steps</h2><p>With the atmosphere systems in place, we need something to be afraid of. In the next chapter, we'll build the creature AI that stalks the player through our carefully crafted darkness.<br>
</p>
    </section>
  

    <section id="chapter-3" class="chapter">
      <h2>Creature AI and Threats</h2>
      <p>A horror game without threats is just a walking simulator with mood lighting. The creature—whatever form it takes—must feel intelligent, relentless, and terrifying.</p><p>This chapter covers the AI systems that make players genuinely afraid.</p><h2>The Core Loop</h2><p>Every creature AI follows a basic loop:</p><p>1. <strong>Perceive</strong> - Detect players through sight, sound, or other senses<br>
2. <strong>Decide</strong> - Choose a behavior based on current state<br>
3. <strong>Act</strong> - Execute movement, attacks, or other actions<br>
4. <strong>Update</strong> - Adjust state based on results</p><pre><code class="language-lua">-- src/server/Creature.server.luau<br>
local PathfindingService = game:GetService(&quot;PathfindingService&quot;)<br>
local Players = game:GetService(&quot;Players&quot;)</p><p>local CreatureAI = {}<br>
CreatureAI.__index = CreatureAI</p><p>function CreatureAI.new(model)<br>
    local self = setmetatable({}, CreatureAI)</p><p>    self.model = model<br>
    self.humanoid = model:FindFirstChildOfClass(&quot;Humanoid&quot;)<br>
    self.rootPart = model:FindFirstChild(&quot;HumanoidRootPart&quot;)</p><p>    self.state = &quot;idle&quot;<br>
    self.target = nil<br>
    self.lastKnownPosition = nil<br>
    self.alertLevel = 0  -- 0 = unaware, 1 = suspicious, 2 = hunting</p><p>    self.config = {<br>
        detectionRadius = 50,<br>
        chaseSpeed = 18,<br>
        patrolSpeed = 8,<br>
        attackRange = 5,<br>
        loseTargetTime = 10,<br>
    }</p><p>    return self<br>
end</p><p>function CreatureAI:update(dt)<br>
    self:perceive()<br>
    self:decide()<br>
    self:act(dt)<br>
end</p><p>return CreatureAI</code></pre><h2>Detection Systems</h2><p>Players should be detectable through multiple senses. This creates interesting gameplay—they can hide from sight but still be heard.</p><h3>Line of Sight</h3><pre><code class="language-lua">function CreatureAI:canSee(target)<br>
    local targetRoot = target.Character and target.Character:FindFirstChild(&quot;HumanoidRootPart&quot;)<br>
    if not targetRoot then return false end</p><p>    local origin = self.rootPart.Position + Vector3.new(0, 2, 0)  -- Eye height<br>
    local direction = (targetRoot.Position - origin)<br>
    local distance = direction.Magnitude</p><p>    -- Too far?<br>
    if distance &gt; self.config.detectionRadius then<br>
        return false<br>
    end</p><p>    -- Raycast for obstacles<br>
    local rayParams = RaycastParams.new()<br>
    rayParams.FilterDescendantsInstances = {self.model}<br>
    rayParams.FilterType = Enum.RaycastFilterType.Exclude</p><p>    local result = workspace:Raycast(origin, direction, rayParams)</p><p>    if result then<br>
        -- Hit something - is it the target?<br>
        local hitPart = result.Instance<br>
        return hitPart:IsDescendantOf(target.Character)<br>
    end</p><p>    return true  -- Nothing in the way<br>
end</code></pre><h3>Sound Detection</h3><p>Players making noise should attract attention:</p><pre><code class="language-lua">function CreatureAI:canHear(target)<br>
    local targetRoot = target.Character and target.Character:FindFirstChild(&quot;HumanoidRootPart&quot;)<br>
    if not targetRoot then return false end</p><p>    local distance = (targetRoot.Position - self.rootPart.Position).Magnitude<br>
    local humanoid = target.Character:FindFirstChildOfClass(&quot;Humanoid&quot;)</p><p>    if not humanoid then return false end</p><p>    -- Calculate noise level based on movement<br>
    local noiseLevel = 0<br>
    local velocity = targetRoot.AssemblyLinearVelocity.Magnitude</p><p>    if velocity &gt; 20 then<br>
        noiseLevel = 3  -- Running<br>
    elseif velocity &gt; 5 then<br>
        noiseLevel = 1  -- Walking<br>
    else<br>
        noiseLevel = 0  -- Standing still<br>
    end</p><p>    -- Noise travels further in quiet environments<br>
    local hearingRange = noiseLevel * 30</p><p>    return distance &lt;= hearingRange<br>
end</code></pre><h3>Combined Perception</h3><pre><code class="language-lua">function CreatureAI:perceive()<br>
    local closestTarget = nil<br>
    local closestDistance = math.huge</p><p>    for _, player in ipairs(Players:GetPlayers()) do<br>
        if self:canSee(player) or self:canHear(player) then<br>
            local distance = self:getDistanceToPlayer(player)<br>
            if distance &lt; closestDistance then<br>
                closestTarget = player<br>
                closestDistance = distance<br>
            end<br>
        end<br>
    end</p><p>    if closestTarget then<br>
        self.target = closestTarget<br>
        self.lastKnownPosition = closestTarget.Character.HumanoidRootPart.Position<br>
        self.alertLevel = 2<br>
        self.lastSeenTime = tick()<br>
    elseif self.target and (tick() - self.lastSeenTime) &gt; self.config.loseTargetTime then<br>
        -- Lost target for too long<br>
        self.target = nil<br>
        self.alertLevel = 1  -- Still suspicious<br>
    end<br>
end</code></pre><h2>Behavior States</h2><p>Use a state machine to organize creature behaviors:</p><pre><code class="language-lua">local STATES = {<br>
    idle = &quot;idle&quot;,<br>
    patrol = &quot;patrol&quot;,<br>
    investigate = &quot;investigate&quot;,<br>
    chase = &quot;chase&quot;,<br>
    attack = &quot;attack&quot;,<br>
    search = &quot;search&quot;,<br>
}</p><p>function CreatureAI:decide()<br>
    if self.alertLevel == 0 then<br>
        self.state = STATES.patrol<br>
    elseif self.alertLevel == 1 then<br>
        self.state = STATES.investigate<br>
    elseif self.alertLevel == 2 then<br>
        if self:getDistanceToTarget() &lt; self.config.attackRange then<br>
            self.state = STATES.attack<br>
        else<br>
            self.state = STATES.chase<br>
        end<br>
    end<br>
end</p><p>function CreatureAI:act(dt)<br>
    if self.state == STATES.idle then<br>
        self:doIdle()<br>
    elseif self.state == STATES.patrol then<br>
        self:doPatrol()<br>
    elseif self.state == STATES.investigate then<br>
        self:doInvestigate()<br>
    elseif self.state == STATES.chase then<br>
        self:doChase()<br>
    elseif self.state == STATES.attack then<br>
        self:doAttack()<br>
    elseif self.state == STATES.search then<br>
        self:doSearch()<br>
    end<br>
end</code></pre><h2>Pathfinding</h2><p>Roblox provides PathfindingService for navigation:</p><pre><code class="language-lua">function CreatureAI:moveToPosition(targetPosition)<br>
    local path = PathfindingService:CreatePath({<br>
        AgentRadius = 2,<br>
        AgentHeight = 5,<br>
        AgentCanJump = true,<br>
        AgentCanClimb = false,<br>
    })</p><p>    local success, errorMessage = pcall(function()<br>
        path:ComputeAsync(self.rootPart.Position, targetPosition)<br>
    end)</p><p>    if success and path.Status == Enum.PathStatus.Success then<br>
        local waypoints = path:GetWaypoints()</p><p>        for _, waypoint in ipairs(waypoints) do<br>
            self.humanoid:MoveTo(waypoint.Position)<br>
            self.humanoid.MoveToFinished:Wait()</p><p>            -- Check if we should stop (target moved, etc.)<br>
            if self:shouldAbortPath() then<br>
                break<br>
            end<br>
        end<br>
    else<br>
        -- Pathfinding failed - move directly (may get stuck)<br>
        self.humanoid:MoveTo(targetPosition)<br>
    end<br>
end</p><p>function CreatureAI:doChase()<br>
    if not self.target then return end</p><p>    local targetPosition = self.target.Character and<br>
        self.target.Character:FindFirstChild(&quot;HumanoidRootPart&quot;) and<br>
        self.target.Character.HumanoidRootPart.Position</p><p>    if targetPosition then<br>
        self.humanoid.WalkSpeed = self.config.chaseSpeed<br>
        self:moveToPosition(targetPosition)<br>
    end<br>
end</code></pre><h2>Patrol Behavior</h2><p>When not hunting, creatures should patrol to seem alive:</p><pre><code class="language-lua">function CreatureAI:setupPatrolPoints(points)<br>
    self.patrolPoints = points<br>
    self.currentPatrolIndex = 1<br>
end</p><p>function CreatureAI:doPatrol()<br>
    if not self.patrolPoints or #self.patrolPoints == 0 then<br>
        self:doIdle()<br>
        return<br>
    end</p><p>    self.humanoid.WalkSpeed = self.config.patrolSpeed<br>
    local targetPoint = self.patrolPoints[self.currentPatrolIndex]</p><p>    self:moveToPosition(targetPoint)</p><p>    -- Check if we reached the point<br>
    local distance = (self.rootPart.Position - targetPoint).Magnitude<br>
    if distance &lt; 3 then<br>
        -- Wait at patrol point<br>
        task.wait(2 + math.random() * 3)</p><p>        -- Move to next point<br>
        self.currentPatrolIndex = (self.currentPatrolIndex % #self.patrolPoints) + 1<br>
    end<br>
end</code></pre><h2>Investigation Behavior</h2><p>When suspicious but not certain, creatures should investigate:</p><pre><code class="language-lua">function CreatureAI:doInvestigate()<br>
    if not self.lastKnownPosition then<br>
        self.alertLevel = 0<br>
        return<br>
    end</p><p>    self.humanoid.WalkSpeed = self.config.patrolSpeed * 1.2</p><p>    self:moveToPosition(self.lastKnownPosition)</p><p>    local distance = (self.rootPart.Position - self.lastKnownPosition).Magnitude<br>
    if distance &lt; 5 then<br>
        -- Reached investigation point, look around<br>
        self:lookAround()</p><p>        -- If nothing found, decrease alert level<br>
        if not self.target then<br>
            self.alertLevel = 0<br>
            self.lastKnownPosition = nil<br>
        end<br>
    end<br>
end</p><p>function CreatureAI:lookAround()<br>
    -- Turn in place to scan area<br>
    for i = 1, 4 do<br>
        self.rootPart.CFrame = self.rootPart.CFrame * CFrame.Angles(0, math.rad(90), 0)<br>
        task.wait(1)</p><p>        -- Check for players during each turn<br>
        self:perceive()<br>
        if self.alertLevel == 2 then<br>
            return  -- Found someone!<br>
        end<br>
    end<br>
end</code></pre><h2>Making It Scary</h2><p>Technical AI is necessary but not sufficient. The creature must <em>feel</em> dangerous:</p><h3>Telegraphing Presence</h3><p>Let players know danger is near before they see it:</p><pre><code class="language-lua">function CreatureAI:emitPresence()<br>
    -- Play ambient sounds when creature is nearby<br>
    local nearbyPlayers = self:getPlayersInRadius(100)</p><p>    for _, player in ipairs(nearbyPlayers) do<br>
        local distance = self:getDistanceToPlayer(player)<br>
        local intensity = 1 - (distance / 100)</p><p>        -- Fire client event to play sounds/effects<br>
        game.ReplicatedStorage.Events.CreatureNearby:FireClient(player, intensity)<br>
    end<br>
end</code></pre><h3>Unpredictability</h3><p>Don't be perfectly optimal—that's boring:</p><pre><code class="language-lua">function CreatureAI:doChase()<br>
    if not self.target then return end</p><p>    -- Occasionally lose track<br>
    if math.random() &lt; 0.1 then<br>
        self.alertLevel = 1<br>
        task.wait(2 + math.random() * 3)<br>
        return<br>
    end</p><p>    -- Sometimes take suboptimal routes<br>
    local targetPosition = self.lastKnownPosition<br>
    if math.random() &lt; 0.3 then<br>
        -- Add randomness to target<br>
        targetPosition = targetPosition + Vector3.new(<br>
            (math.random() - 0.5) * 20,<br>
            0,<br>
            (math.random() - 0.5) * 20<br>
        )<br>
    end</p><p>    self.humanoid.WalkSpeed = self.config.chaseSpeed<br>
    self:moveToPosition(targetPosition)<br>
end</code></pre><h3>The Peek</h3><p>One of horror's most effective tools—let players see the creature watching them:</p><pre><code class="language-lua">function CreatureAI:tryPeek(targetPlayer)<br>
    -- Find a corner or doorway near the player<br>
    local peekSpots = self:findPeekSpots(targetPlayer)</p><p>    if #peekSpots &gt; 0 then<br>
        local spot = peekSpots[math.random(#peekSpots)]<br>
        self:moveToPosition(spot)<br>
        self:lookAt(targetPlayer.Character.HumanoidRootPart.Position)</p><p>        -- Stand there ominously<br>
        task.wait(3 + math.random() * 5)</p><p>        -- Then disappear<br>
        self:moveToPosition(self:findHidingSpot())<br>
    end<br>
end</code></pre><h2>Vibe Coding Creature AI</h2><p>When working with AI on creature behavior:</p><p>> "Create a creature that patrols between waypoints but investigates loud sounds within 50 studs"</p><p>> "Add a behavior where the creature sometimes stops and listens, scanning the area"</p><p>> "Make the chase feel tense—the creature should be fast but occasionally lose the player"</p><p>Let AI handle the boilerplate (pathfinding setup, state machine structure) while you focus on the behaviors that make your creature unique.</p><h2>Balancing Challenge</h2><p>Horror requires helplessness, but not hopelessness:</p><p>- <strong>The creature should catch you sometimes</strong> - Near misses lose tension if they always work<br>
- <strong>Give tells before attacks</strong> - Sound cues, visual warnings<br>
- <strong>Provide escape options</strong> - Hiding spots, diversions, sprint<br>
- <strong>Vary the threat</strong> - Sometimes the creature is close, sometimes it's background dread</p><h2>Next Steps</h2><p>We have atmosphere and a threat. Now players need ways to survive. In the next chapter, we'll build the resource management and survival mechanics that give players agency in our horror world.<br>
</p>
    </section>
  

    <section id="chapter-4" class="chapter">
      <h2>Survival Mechanics</h2>
      <p>Horror without stakes is just spooky aesthetics. Survival mechanics create the stakes—every resource matters, every decision has consequences, every mistake brings you closer to death.</p><p>This chapter covers the systems that make survival feel meaningful.</p><h2>Health System</h2><p>Health in survival horror should feel fragile. Players need to constantly manage their status:</p><pre><code class="language-lua">-- src/shared/PlayerStats.luau<br>
local PlayerStats = {}<br>
PlayerStats.__index = PlayerStats</p><p>function PlayerStats.new()<br>
    local self = setmetatable({}, PlayerStats)</p><p>    self.health = 100<br>
    self.maxHealth = 100<br>
    self.stamina = 100<br>
    self.maxStamina = 100<br>
    self.sanity = 100  -- Optional: mental health mechanic</p><p>    self.effects = {}  -- Active status effects</p><p>    return self<br>
end</p><p>function PlayerStats:takeDamage(amount, damageType)<br>
    -- Different damage types can have different effects<br>
    local finalDamage = amount</p><p>    if damageType == &quot;bleed&quot; then<br>
        -- Bleeding does damage over time<br>
        self:applyEffect(&quot;bleeding&quot;, {<br>
            duration = 30,<br>
            damagePerSecond = 2,<br>
        })<br>
        finalDamage = amount * 0.5  -- Initial hit is smaller<br>
    elseif damageType == &quot;poison&quot; then<br>
        self:applyEffect(&quot;poisoned&quot;, {<br>
            duration = 60,<br>
            damagePerSecond = 1,<br>
            staminaPenalty = 0.5,<br>
        })<br>
    end</p><p>    self.health = math.max(0, self.health - finalDamage)<br>
    return self.health &lt;= 0  -- Returns true if dead<br>
end</p><p>function PlayerStats:heal(amount)<br>
    self.health = math.min(self.maxHealth, self.health + amount)<br>
end</p><p>function PlayerStats:applyEffect(effectName, data)<br>
    self.effects[effectName] = {<br>
        startTime = tick(),<br>
        data = data,<br>
    }<br>
end</p><p>function PlayerStats:update(dt)<br>
    -- Process active effects<br>
    for name, effect in pairs(self.effects) do<br>
        local elapsed = tick() - effect.startTime</p><p>        if elapsed &gt;= effect.data.duration then<br>
            -- Effect expired<br>
            self.effects[name] = nil<br>
        else<br>
            -- Apply effect<br>
            if effect.data.damagePerSecond then<br>
                self.health = math.max(0, self.health - effect.data.damagePerSecond * dt)<br>
            end<br>
        end<br>
    end<br>
end</p><p>return PlayerStats</code></pre><h3>Displaying Health</h3><p>Health UI should be minimal but clear:</p><pre><code class="language-lua">-- src/client/HealthUI.client.luau<br>
local Players = game:GetService(&quot;Players&quot;)<br>
local TweenService = game:GetService(&quot;TweenService&quot;)</p><p>local player = Players.LocalPlayer<br>
local playerGui = player:WaitForChild(&quot;PlayerGui&quot;)</p><p>-- Create health bar<br>
local screenGui = Instance.new(&quot;ScreenGui&quot;)<br>
screenGui.Name = &quot;HealthUI&quot;<br>
screenGui.ResetOnSpawn = false<br>
screenGui.Parent = playerGui</p><p>local healthFrame = Instance.new(&quot;Frame&quot;)<br>
healthFrame.Name = &quot;HealthFrame&quot;<br>
healthFrame.Size = UDim2.new(0, 200, 0, 20)<br>
healthFrame.Position = UDim2.new(0, 20, 1, -40)<br>
healthFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)<br>
healthFrame.BorderSizePixel = 0<br>
healthFrame.Parent = screenGui</p><p>local healthBar = Instance.new(&quot;Frame&quot;)<br>
healthBar.Name = &quot;HealthBar&quot;<br>
healthBar.Size = UDim2.new(1, 0, 1, 0)<br>
healthBar.BackgroundColor3 = Color3.fromRGB(180, 40, 40)<br>
healthBar.BorderSizePixel = 0<br>
healthBar.Parent = healthFrame</p><p>local healthLabel = Instance.new(&quot;TextLabel&quot;)<br>
healthLabel.Name = &quot;HealthLabel&quot;<br>
healthLabel.Size = UDim2.new(1, 0, 1, 0)<br>
healthLabel.BackgroundTransparency = 1<br>
healthLabel.TextColor3 = Color3.new(1, 1, 1)<br>
healthLabel.TextSize = 14<br>
healthLabel.Font = Enum.Font.SourceSansBold<br>
healthLabel.Parent = healthFrame</p><p>-- Low health effects<br>
local lowHealthOverlay = Instance.new(&quot;Frame&quot;)<br>
lowHealthOverlay.Name = &quot;LowHealthOverlay&quot;<br>
lowHealthOverlay.Size = UDim2.new(1, 0, 1, 0)<br>
lowHealthOverlay.BackgroundColor3 = Color3.fromRGB(100, 0, 0)<br>
lowHealthOverlay.BackgroundTransparency = 1<br>
lowHealthOverlay.BorderSizePixel = 0<br>
lowHealthOverlay.ZIndex = 0<br>
lowHealthOverlay.Parent = screenGui</p><p>local function updateHealthDisplay(health, maxHealth)<br>
    local percent = health / maxHealth</p><p>    -- Animate health bar<br>
    local tween = TweenService:Create(healthBar, TweenInfo.new(0.3), {<br>
        Size = UDim2.new(percent, 0, 1, 0)<br>
    })<br>
    tween:Play()</p><p>    healthLabel.Text = math.floor(health) .. &quot; / &quot; .. maxHealth</p><p>    -- Low health warning effect<br>
    if percent &lt; 0.25 then<br>
        -- Pulse red overlay<br>
        local pulse = TweenService:Create(lowHealthOverlay, TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {<br>
            BackgroundTransparency = 0.7<br>
        })<br>
        pulse:Play()<br>
    else<br>
        lowHealthOverlay.BackgroundTransparency = 1<br>
    end<br>
end</p><p>-- Connect to health changes<br>
game.ReplicatedStorage.Events.HealthChanged.OnClientEvent:Connect(updateHealthDisplay)</code></pre><h2>Stamina System</h2><p>Stamina limits what players can do. Running, attacking, and certain actions drain stamina:</p><pre><code class="language-lua">-- src/shared/StaminaSystem.luau<br>
local Config = require(game.ReplicatedStorage.Shared.Config)</p><p>local StaminaSystem = {}<br>
StaminaSystem.__index = StaminaSystem</p><p>function StaminaSystem.new(stats)<br>
    local self = setmetatable({}, StaminaSystem)</p><p>    self.stats = stats<br>
    self.isExhausted = false  -- Can't run when exhausted<br>
    self.exhaustionThreshold = 10  -- Can't run below this<br>
    self.recoveryThreshold = 30  -- Must recover to this before running again</p><p>    return self<br>
end</p><p>function StaminaSystem:canRun()<br>
    if self.isExhausted then<br>
        return self.stats.stamina &gt;= self.recoveryThreshold<br>
    end<br>
    return self.stats.stamina &gt; self.exhaustionThreshold<br>
end</p><p>function StaminaSystem:startRunning()<br>
    if not self:canRun() then return false end<br>
    self.isExhausted = false<br>
    return true<br>
end</p><p>function StaminaSystem:update(dt, isRunning, humanoid)<br>
    if isRunning and self:canRun() then<br>
        -- Drain stamina while running<br>
        self.stats.stamina = math.max(0, self.stats.stamina - Config.STAMINA_DRAIN_RATE * dt)<br>
        humanoid.WalkSpeed = Config.PLAYER_RUN_SPEED</p><p>        if self.stats.stamina &lt;= self.exhaustionThreshold then<br>
            self.isExhausted = true<br>
        end<br>
    else<br>
        -- Regenerate stamina<br>
        local regenRate = Config.STAMINA_REGEN_RATE</p><p>        -- Standing still regenerates faster<br>
        if humanoid.MoveDirection.Magnitude &lt; 0.1 then<br>
            regenRate = regenRate * 2<br>
        end</p><p>        self.stats.stamina = math.min(self.stats.maxStamina, self.stats.stamina + regenRate * dt)<br>
        humanoid.WalkSpeed = Config.PLAYER_WALK_SPEED</p><p>        -- Clear exhaustion when recovered<br>
        if self.isExhausted and self.stats.stamina &gt;= self.recoveryThreshold then<br>
            self.isExhausted = false<br>
        end<br>
    end<br>
end</p><p>return StaminaSystem</code></pre><h2>Inventory System</h2><p>A proper inventory creates meaningful choices about what to carry:</p><pre><code class="language-lua">-- src/shared/Inventory.luau<br>
local Inventory = {}<br>
Inventory.__index = Inventory</p><p>local ITEM_DEFINITIONS = {<br>
    flashlight = {<br>
        name = &quot;Flashlight&quot;,<br>
        maxStack = 1,<br>
        weight = 1,<br>
        category = &quot;tool&quot;,<br>
    },<br>
    battery = {<br>
        name = &quot;Battery&quot;,<br>
        maxStack = 5,<br>
        weight = 0.2,<br>
        category = &quot;consumable&quot;,<br>
    },<br>
    medkit = {<br>
        name = &quot;Medical Kit&quot;,<br>
        maxStack = 3,<br>
        weight = 2,<br>
        category = &quot;consumable&quot;,<br>
        healAmount = 50,<br>
    },<br>
    bandage = {<br>
        name = &quot;Bandage&quot;,<br>
        maxStack = 10,<br>
        weight = 0.5,<br>
        category = &quot;consumable&quot;,<br>
        healAmount = 15,<br>
        curesEffect = &quot;bleeding&quot;,<br>
    },<br>
    key_red = {<br>
        name = &quot;Red Keycard&quot;,<br>
        maxStack = 1,<br>
        weight = 0.1,<br>
        category = &quot;key&quot;,<br>
    },<br>
}</p><p>function Inventory.new(maxSlots, maxWeight)<br>
    local self = setmetatable({}, Inventory)</p><p>    self.slots = {}<br>
    self.maxSlots = maxSlots or 10<br>
    self.maxWeight = maxWeight or 20<br>
    self.currentWeight = 0</p><p>    return self<br>
end</p><p>function Inventory:getCurrentWeight()<br>
    local weight = 0<br>
    for _, slot in pairs(self.slots) do<br>
        local def = ITEM_DEFINITIONS[slot.itemId]<br>
        if def then<br>
            weight = weight + (def.weight * slot.quantity)<br>
        end<br>
    end<br>
    return weight<br>
end</p><p>function Inventory:canAddItem(itemId, quantity)<br>
    local def = ITEM_DEFINITIONS[itemId]<br>
    if not def then return false, &quot;Unknown item&quot; end</p><p>    quantity = quantity or 1<br>
    local addedWeight = def.weight * quantity</p><p>    if self:getCurrentWeight() + addedWeight &gt; self.maxWeight then<br>
        return false, &quot;Too heavy&quot;<br>
    end</p><p>    -- Check if we can stack with existing<br>
    for slotIndex, slot in pairs(self.slots) do<br>
        if slot.itemId == itemId then<br>
            if slot.quantity + quantity &lt;= def.maxStack then<br>
                return true, slotIndex  -- Can stack<br>
            end<br>
        end<br>
    end</p><p>    -- Need new slot<br>
    if self:getUsedSlots() &gt;= self.maxSlots then<br>
        return false, &quot;Inventory full&quot;<br>
    end</p><p>    return true, nil  -- Can add to new slot<br>
end</p><p>function Inventory:addItem(itemId, quantity)<br>
    local canAdd, result = self:canAddItem(itemId, quantity)<br>
    if not canAdd then return false, result end</p><p>    quantity = quantity or 1<br>
    local def = ITEM_DEFINITIONS[itemId]</p><p>    -- Try to stack first<br>
    if type(result) == &quot;number&quot; then<br>
        self.slots[result].quantity = self.slots[result].quantity + quantity<br>
        return true<br>
    end</p><p>    -- Add to new slot<br>
    local newIndex = self:getFirstEmptySlot()<br>
    self.slots[newIndex] = {<br>
        itemId = itemId,<br>
        quantity = quantity,<br>
    }</p><p>    return true<br>
end</p><p>function Inventory:removeItem(itemId, quantity)<br>
    quantity = quantity or 1</p><p>    for slotIndex, slot in pairs(self.slots) do<br>
        if slot.itemId == itemId then<br>
            if slot.quantity &gt;= quantity then<br>
                slot.quantity = slot.quantity - quantity<br>
                if slot.quantity &lt;= 0 then<br>
                    self.slots[slotIndex] = nil<br>
                end<br>
                return true<br>
            end<br>
        end<br>
    end</p><p>    return false<br>
end</p><p>function Inventory:hasItem(itemId, quantity)<br>
    quantity = quantity or 1<br>
    local total = 0</p><p>    for _, slot in pairs(self.slots) do<br>
        if slot.itemId == itemId then<br>
            total = total + slot.quantity<br>
        end<br>
    end</p><p>    return total &gt;= quantity<br>
end</p><p>function Inventory:getUsedSlots()<br>
    local count = 0<br>
    for _ in pairs(self.slots) do<br>
        count = count + 1<br>
    end<br>
    return count<br>
end</p><p>function Inventory:getFirstEmptySlot()<br>
    for i = 1, self.maxSlots do<br>
        if not self.slots[i] then<br>
            return i<br>
        end<br>
    end<br>
    return nil<br>
end</p><p>function Inventory.getItemDefinition(itemId)<br>
    return ITEM_DEFINITIONS[itemId]<br>
end</p><p>return Inventory</code></pre><h3>Inventory UI</h3><pre><code class="language-lua">-- src/client/InventoryUI.client.luau<br>
local Players = game:GetService(&quot;Players&quot;)<br>
local UserInputService = game:GetService(&quot;UserInputService&quot;)<br>
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)</p><p>local Inventory = require(ReplicatedStorage.Shared.Inventory)</p><p>local player = Players.LocalPlayer<br>
local playerGui = player:WaitForChild(&quot;PlayerGui&quot;)</p><p>local isOpen = false<br>
local inventoryData = {}</p><p>-- Create inventory screen<br>
local screenGui = Instance.new(&quot;ScreenGui&quot;)<br>
screenGui.Name = &quot;InventoryUI&quot;<br>
screenGui.Enabled = false<br>
screenGui.ResetOnSpawn = false<br>
screenGui.Parent = playerGui</p><p>local background = Instance.new(&quot;Frame&quot;)<br>
background.Name = &quot;Background&quot;<br>
background.Size = UDim2.new(0, 400, 0, 500)<br>
background.Position = UDim2.new(0.5, -200, 0.5, -250)<br>
background.BackgroundColor3 = Color3.fromRGB(30, 30, 35)<br>
background.BorderSizePixel = 0<br>
background.Parent = screenGui</p><p>local title = Instance.new(&quot;TextLabel&quot;)<br>
title.Name = &quot;Title&quot;<br>
title.Size = UDim2.new(1, 0, 0, 40)<br>
title.BackgroundColor3 = Color3.fromRGB(20, 20, 25)<br>
title.BorderSizePixel = 0<br>
title.Text = &quot;INVENTORY&quot;<br>
title.TextColor3 = Color3.new(1, 1, 1)<br>
title.TextSize = 18<br>
title.Font = Enum.Font.SourceSansBold<br>
title.Parent = background</p><p>local gridContainer = Instance.new(&quot;Frame&quot;)<br>
gridContainer.Name = &quot;Grid&quot;<br>
gridContainer.Size = UDim2.new(1, -20, 1, -100)<br>
gridContainer.Position = UDim2.new(0, 10, 0, 50)<br>
gridContainer.BackgroundTransparency = 1<br>
gridContainer.Parent = background</p><p>local gridLayout = Instance.new(&quot;UIGridLayout&quot;)<br>
gridLayout.CellSize = UDim2.new(0, 70, 0, 70)<br>
gridLayout.CellPadding = UDim2.new(0, 5, 0, 5)<br>
gridLayout.Parent = gridContainer</p><p>-- Weight display<br>
local weightLabel = Instance.new(&quot;TextLabel&quot;)<br>
weightLabel.Name = &quot;WeightLabel&quot;<br>
weightLabel.Size = UDim2.new(1, 0, 0, 30)<br>
weightLabel.Position = UDim2.new(0, 0, 1, -40)<br>
weightLabel.BackgroundTransparency = 1<br>
weightLabel.TextColor3 = Color3.fromRGB(150, 150, 150)<br>
weightLabel.TextSize = 14<br>
weightLabel.Font = Enum.Font.SourceSans<br>
weightLabel.Parent = background</p><p>local function createSlot(index)<br>
    local slot = Instance.new(&quot;Frame&quot;)<br>
    slot.Name = &quot;Slot_&quot; .. index<br>
    slot.BackgroundColor3 = Color3.fromRGB(50, 50, 55)<br>
    slot.BorderSizePixel = 0<br>
    slot.Parent = gridContainer</p><p>    local icon = Instance.new(&quot;ImageLabel&quot;)<br>
    icon.Name = &quot;Icon&quot;<br>
    icon.Size = UDim2.new(0.8, 0, 0.8, 0)<br>
    icon.Position = UDim2.new(0.1, 0, 0.05, 0)<br>
    icon.BackgroundTransparency = 1<br>
    icon.ScaleType = Enum.ScaleType.Fit<br>
    icon.Parent = slot</p><p>    local quantity = Instance.new(&quot;TextLabel&quot;)<br>
    quantity.Name = &quot;Quantity&quot;<br>
    quantity.Size = UDim2.new(0.4, 0, 0.3, 0)<br>
    quantity.Position = UDim2.new(0.55, 0, 0.65, 0)<br>
    quantity.BackgroundTransparency = 1<br>
    quantity.TextColor3 = Color3.new(1, 1, 1)<br>
    quantity.TextSize = 12<br>
    quantity.Font = Enum.Font.SourceSansBold<br>
    quantity.TextXAlignment = Enum.TextXAlignment.Right<br>
    quantity.Parent = slot</p><p>    return slot<br>
end</p><p>local function refreshInventory()<br>
    -- Clear existing slots<br>
    for _, child in ipairs(gridContainer:GetChildren()) do<br>
        if child:IsA(&quot;Frame&quot;) then<br>
            child:Destroy()<br>
        end<br>
    end</p><p>    -- Create slots<br>
    for i = 1, 10 do<br>
        local slot = createSlot(i)<br>
        local slotData = inventoryData[i]</p><p>        if slotData then<br>
            local def = Inventory.getItemDefinition(slotData.itemId)<br>
            if def then<br>
                slot.Icon.Image = &quot;rbxassetid://YOUR_ITEM_ICONS&quot;  -- Replace with actual icons<br>
                slot.Quantity.Text = slotData.quantity &gt; 1 and tostring(slotData.quantity) or &quot;&quot;<br>
            end<br>
        else<br>
            slot.Icon.Image = &quot;&quot;<br>
            slot.Quantity.Text = &quot;&quot;<br>
        end<br>
    end<br>
end</p><p>local function toggleInventory()<br>
    isOpen = not isOpen<br>
    screenGui.Enabled = isOpen</p><p>    if isOpen then<br>
        -- Request inventory data from server<br>
        ReplicatedStorage.Events.RequestInventory:FireServer()<br>
    end<br>
end</p><p>-- Keyboard toggle<br>
UserInputService.InputBegan:Connect(function(input, processed)<br>
    if processed then return end</p><p>    if input.KeyCode == Enum.KeyCode.Tab or input.KeyCode == Enum.KeyCode.I then<br>
        toggleInventory()<br>
    end<br>
end)</p><p>-- Receive inventory updates<br>
ReplicatedStorage.Events.InventoryUpdated.OnClientEvent:Connect(function(data, currentWeight, maxWeight)<br>
    inventoryData = data<br>
    weightLabel.Text = string.format(&quot;Weight: %.1f / %.1f&quot;, currentWeight, maxWeight)<br>
    refreshInventory()<br>
end)</code></pre><h2>Item Pickups</h2><p>Items in the world that players can collect:</p><pre><code class="language-lua">-- src/server/ItemPickup.server.luau<br>
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)<br>
local CollectionService = game:GetService(&quot;CollectionService&quot;)</p><p>local Inventory = require(ReplicatedStorage.Shared.Inventory)</p><p>-- Tag items in the world with &quot;Pickup&quot;<br>
local PICKUP_RANGE = 5</p><p>local function setupPickup(part)<br>
    -- Get item data from attributes<br>
    local itemId = part:GetAttribute(&quot;ItemId&quot;)<br>
    local quantity = part:GetAttribute(&quot;Quantity&quot;) or 1</p><p>    if not itemId then<br>
        warn(&quot;Pickup missing ItemId attribute: &quot; .. part:GetFullName())<br>
        return<br>
    end</p><p>    -- Create proximity prompt<br>
    local prompt = Instance.new(&quot;ProximityPrompt&quot;)<br>
    prompt.ActionText = &quot;Pick up&quot;<br>
    prompt.ObjectText = Inventory.getItemDefinition(itemId).name<br>
    prompt.MaxActivationDistance = PICKUP_RANGE<br>
    prompt.HoldDuration = 0.3<br>
    prompt.Parent = part</p><p>    prompt.Triggered:Connect(function(player)<br>
        local playerInventory = getPlayerInventory(player)  -- Your player data system</p><p>        local success, err = playerInventory:addItem(itemId, quantity)</p><p>        if success then<br>
            -- Remove pickup from world<br>
            part:Destroy()</p><p>            -- Notify player<br>
            ReplicatedStorage.Events.ItemPickedUp:FireClient(player, itemId, quantity)</p><p>            -- Sync inventory<br>
            syncInventoryToClient(player)<br>
        else<br>
            -- Notify player of failure<br>
            ReplicatedStorage.Events.PickupFailed:FireClient(player, err)<br>
        end<br>
    end)<br>
end</p><p>-- Set up existing pickups<br>
for _, pickup in ipairs(CollectionService:GetTagged(&quot;Pickup&quot;)) do<br>
    setupPickup(pickup)<br>
end</p><p>-- Set up future pickups<br>
CollectionService:GetInstanceAddedSignal(&quot;Pickup&quot;):Connect(setupPickup)</code></pre><h2>Crafting System</h2><p>Let players combine items to create new ones:</p><pre><code class="language-lua">-- src/shared/Crafting.luau<br>
local Crafting = {}</p><p>local RECIPES = {<br>
    {<br>
        id = &quot;torch&quot;,<br>
        name = &quot;Makeshift Torch&quot;,<br>
        ingredients = {<br>
            { itemId = &quot;stick&quot;, quantity = 1 },<br>
            { itemId = &quot;cloth&quot;, quantity = 1 },<br>
        },<br>
        result = { itemId = &quot;torch&quot;, quantity = 1 },<br>
        craftTime = 3,<br>
    },<br>
    {<br>
        id = &quot;medkit&quot;,<br>
        name = &quot;Medical Kit&quot;,<br>
        ingredients = {<br>
            { itemId = &quot;bandage&quot;, quantity = 3 },<br>
            { itemId = &quot;alcohol&quot;, quantity = 1 },<br>
        },<br>
        result = { itemId = &quot;medkit&quot;, quantity = 1 },<br>
        craftTime = 5,<br>
    },<br>
    {<br>
        id = &quot;lockpick&quot;,<br>
        name = &quot;Lockpick&quot;,<br>
        ingredients = {<br>
            { itemId = &quot;wire&quot;, quantity = 2 },<br>
        },<br>
        result = { itemId = &quot;lockpick&quot;, quantity = 1 },<br>
        craftTime = 4,<br>
    },<br>
}</p><p>function Crafting.getAvailableRecipes(inventory)<br>
    local available = {}</p><p>    for _, recipe in ipairs(RECIPES) do<br>
        if Crafting.canCraft(inventory, recipe.id) then<br>
            table.insert(available, recipe)<br>
        end<br>
    end</p><p>    return available<br>
end</p><p>function Crafting.canCraft(inventory, recipeId)<br>
    local recipe = Crafting.getRecipe(recipeId)<br>
    if not recipe then return false end</p><p>    for _, ingredient in ipairs(recipe.ingredients) do<br>
        if not inventory:hasItem(ingredient.itemId, ingredient.quantity) then<br>
            return false<br>
        end<br>
    end</p><p>    -- Check if result can fit<br>
    local canAdd = inventory:canAddItem(recipe.result.itemId, recipe.result.quantity)<br>
    return canAdd<br>
end</p><p>function Crafting.craft(inventory, recipeId)<br>
    if not Crafting.canCraft(inventory, recipeId) then<br>
        return false, &quot;Cannot craft&quot;<br>
    end</p><p>    local recipe = Crafting.getRecipe(recipeId)</p><p>    -- Remove ingredients<br>
    for _, ingredient in ipairs(recipe.ingredients) do<br>
        inventory:removeItem(ingredient.itemId, ingredient.quantity)<br>
    end</p><p>    -- Add result<br>
    inventory:addItem(recipe.result.itemId, recipe.result.quantity)</p><p>    return true, recipe.craftTime<br>
end</p><p>function Crafting.getRecipe(recipeId)<br>
    for _, recipe in ipairs(RECIPES) do<br>
        if recipe.id == recipeId then<br>
            return recipe<br>
        end<br>
    end<br>
    return nil<br>
end</p><p>function Crafting.getAllRecipes()<br>
    return RECIPES<br>
end</p><p>return Crafting</code></pre><h2>Flashlight and Battery Management</h2><p>A classic horror mechanic—limited light:</p><pre><code class="language-lua">-- src/client/Flashlight.client.luau<br>
local Players = game:GetService(&quot;Players&quot;)<br>
local UserInputService = game:GetService(&quot;UserInputService&quot;)<br>
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)<br>
local TweenService = game:GetService(&quot;TweenService&quot;)</p><p>local player = Players.LocalPlayer<br>
local character = player.Character or player.CharacterAdded:Wait()</p><p>local flashlightOn = false<br>
local batteryLevel = 100<br>
local drainRate = 5  -- Percent per second</p><p>local spotlight = nil<br>
local flickerConnection = nil</p><p>local function createSpotlight()<br>
    local head = character:WaitForChild(&quot;Head&quot;)</p><p>    spotlight = Instance.new(&quot;SpotLight&quot;)<br>
    spotlight.Name = &quot;Flashlight&quot;<br>
    spotlight.Brightness = 3<br>
    spotlight.Range = 60<br>
    spotlight.Angle = 45<br>
    spotlight.Face = Enum.NormalId.Front<br>
    spotlight.Enabled = false<br>
    spotlight.Parent = head</p><p>    return spotlight<br>
end</p><p>local function updateFlashlightState()<br>
    if not spotlight then return end</p><p>    spotlight.Enabled = flashlightOn and batteryLevel &gt; 0</p><p>    -- Flicker when battery is low<br>
    if batteryLevel &lt; 20 and flashlightOn then<br>
        if not flickerConnection then<br>
            flickerConnection = task.spawn(function()<br>
                while flashlightOn and batteryLevel &gt; 0 and batteryLevel &lt; 20 do<br>
                    local intensity = 0.5 + math.random() * 0.5<br>
                    spotlight.Brightness = 3 * intensity<br>
                    task.wait(0.1 + math.random() * 0.2)<br>
                end<br>
                spotlight.Brightness = 3<br>
            end)<br>
        end<br>
    else<br>
        if flickerConnection then<br>
            task.cancel(flickerConnection)<br>
            flickerConnection = nil<br>
            spotlight.Brightness = 3<br>
        end<br>
    end<br>
end</p><p>local function toggleFlashlight()<br>
    -- Check if player has flashlight item<br>
    -- (simplified - your inventory system handles this)</p><p>    flashlightOn = not flashlightOn<br>
    updateFlashlightState()</p><p>    -- Play sound<br>
    local sound = Instance.new(&quot;Sound&quot;)<br>
    sound.SoundId = &quot;rbxassetid://YOUR_CLICK_SOUND&quot;<br>
    sound.Volume = 0.5<br>
    sound.Parent = character.Head<br>
    sound:Play()<br>
    sound.Ended:Connect(function() sound:Destroy() end)<br>
end</p><p>local function useBattery()<br>
    if batteryLevel &lt;= 0 then<br>
        flashlightOn = false<br>
        updateFlashlightState()<br>
        return<br>
    end</p><p>    -- Check for batteries in inventory<br>
    ReplicatedStorage.Events.UseBattery:FireServer()<br>
end</p><p>-- Initialize<br>
createSpotlight()</p><p>-- Toggle with F key<br>
UserInputService.InputBegan:Connect(function(input, processed)<br>
    if processed then return end</p><p>    if input.KeyCode == Enum.KeyCode.F then<br>
        toggleFlashlight()<br>
    elseif input.KeyCode == Enum.KeyCode.R and flashlightOn then<br>
        useBattery()<br>
    end<br>
end)</p><p>-- Battery drain loop<br>
task.spawn(function()<br>
    while true do<br>
        if flashlightOn and batteryLevel &gt; 0 then<br>
            batteryLevel = math.max(0, batteryLevel - drainRate * 0.1)<br>
            updateFlashlightState()</p><p>            -- Update UI<br>
            ReplicatedStorage.Events.BatteryChanged:Fire(batteryLevel)<br>
        end<br>
        task.wait(0.1)<br>
    end<br>
end)</p><p>-- Receive battery level from server<br>
ReplicatedStorage.Events.BatteryUpdated.OnClientEvent:Connect(function(level)<br>
    batteryLevel = level<br>
    updateFlashlightState()<br>
end)</p><p>-- Respawn handling<br>
player.CharacterAdded:Connect(function(newCharacter)<br>
    character = newCharacter<br>
    createSpotlight()<br>
    flashlightOn = false<br>
    updateFlashlightState()<br>
end)</code></pre><h2>Hunger and Thirst (Optional)</h2><p>For longer-form survival horror:</p><pre><code class="language-lua">-- src/server/Needs.server.luau<br>
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)<br>
local Players = game:GetService(&quot;Players&quot;)</p><p>local HUNGER_DRAIN_RATE = 0.5  -- Per minute<br>
local THIRST_DRAIN_RATE = 0.8  -- Per minute<br>
local STARVATION_DAMAGE = 1    -- Damage per second when starving</p><p>local playerNeeds = {}</p><p>local function initPlayer(player)<br>
    playerNeeds[player] = {<br>
        hunger = 100,<br>
        thirst = 100,<br>
    }<br>
end</p><p>local function updateNeeds(player, dt)<br>
    local needs = playerNeeds[player]<br>
    if not needs then return end</p><p>    -- Drain needs<br>
    needs.hunger = math.max(0, needs.hunger - HUNGER_DRAIN_RATE * dt / 60)<br>
    needs.thirst = math.max(0, needs.thirst - THIRST_DRAIN_RATE * dt / 60)</p><p>    -- Apply starvation/dehydration damage<br>
    local character = player.Character<br>
    local humanoid = character and character:FindFirstChildOfClass(&quot;Humanoid&quot;)</p><p>    if humanoid then<br>
        if needs.hunger &lt;= 0 then<br>
            humanoid:TakeDamage(STARVATION_DAMAGE * dt)<br>
        end<br>
        if needs.thirst &lt;= 0 then<br>
            humanoid:TakeDamage(STARVATION_DAMAGE * dt)<br>
        end<br>
    end</p><p>    -- Sync to client<br>
    ReplicatedStorage.Events.NeedsUpdated:FireClient(player, needs.hunger, needs.thirst)<br>
end</p><p>local function consumeFood(player, hungerRestore)<br>
    local needs = playerNeeds[player]<br>
    if not needs then return end</p><p>    needs.hunger = math.min(100, needs.hunger + hungerRestore)<br>
end</p><p>local function consumeWater(player, thirstRestore)<br>
    local needs = playerNeeds[player]<br>
    if not needs then return end</p><p>    needs.thirst = math.min(100, needs.thirst + thirstRestore)<br>
end</p><p>-- Initialize players<br>
Players.PlayerAdded:Connect(initPlayer)<br>
Players.PlayerRemoving:Connect(function(player)<br>
    playerNeeds[player] = nil<br>
end)</p><p>-- Update loop<br>
task.spawn(function()<br>
    while true do<br>
        local dt = task.wait(1)<br>
        for player in pairs(playerNeeds) do<br>
            updateNeeds(player, dt)<br>
        end<br>
    end<br>
end)</p><p>-- Expose functions<br>
return {<br>
    consumeFood = consumeFood,<br>
    consumeWater = consumeWater,<br>
}</code></pre><h2>Vibe Coding Survival Mechanics</h2><p>When building these systems with AI:</p><p>> "Create an inventory system with weight limits and stackable items"</p><p>> "Add a stamina system where players get exhausted if they run too long"</p><p>> "Implement a flashlight that drains batteries and flickers when low"</p><p>> "Build a simple crafting system with 3-4 recipes for survival items"</p><p>Let AI handle the boilerplate—state management, UI updates, server sync. You focus on the tuning: How fast does stamina drain? How long do batteries last? These numbers define the <em>feel</em>.</p><h2>Balancing Survival</h2><p>Survival mechanics require careful tuning:</p><p>- <strong>Too punishing</strong> - Players feel helpless, give up<br>
- <strong>Too forgiving</strong> - No tension, resources don't matter<br>
- <strong>The sweet spot</strong> - Players are always slightly worried but never hopeless</p><p>Start generous, then tighten. It's easier to make a game harder than to add features that make it easier.</p><h2>Next Steps</h2><p>With survival mechanics in place, players have tools to stay alive. But where do they survive? In the next chapter, we'll build the environments that make those tools necessary—the dark corridors, abandoned rooms, and terrifying spaces of our horror world.<br>
</p>
    </section>
  

    <section id="chapter-5" class="chapter">
      <h2>Environment and Level Design</h2>
      <p>A horror game's environment is its most powerful tool. The creature stalks, mechanics create tension, but the space itself tells players what to fear. Every corridor, every room, every shadow is a design decision.</p><p>This chapter covers building spaces that terrify.</p><h2>The Psychology of Horror Spaces</h2><p>Horror environments work through specific principles:</p><h3>1. Limited Visibility</h3><br>
Players fear what they can't see. Design spaces that:<br>
- Limit sightlines (corners, columns, furniture)<br>
- Create pools of darkness between light sources<br>
- Use fog, dust, or particle effects to obscure distance</p><h3>2. Audio Ambiguity</h3><br>
Sounds without clear sources create paranoia:<br>
- Vents and pipes that carry sound from other rooms<br>
- Distant thuds, scrapes, and groans<br>
- Footsteps that might be yours... or might not</p><h3>3. Spatial Disorientation</h3><br>
When players can't trust their sense of space:<br>
- Hallways that seem too long<br>
- Rooms that feel larger inside than outside<br>
- Subtle asymmetry that feels "wrong"</p><h3>4. Environmental Storytelling</h3><br>
The space itself tells a story:<br>
- Blood trails leading nowhere<br>
- Furniture arranged as barricades<br>
- Personal effects abandoned mid-action</p><h2>Building with Roblox Parts</h2><p>Roblox offers multiple approaches to level design:</p><h3>Modular Building Blocks</h3><p>Create reusable pieces that snap together:</p><pre><code class="language-lua">-- src/server/LevelBuilder.server.luau<br>
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)</p><p>local LevelBuilder = {}</p><p>-- Grid size for snapping<br>
local GRID_SIZE = 8</p><p>local function snapToGrid(position)<br>
    return Vector3.new(<br>
        math.round(position.X / GRID_SIZE) * GRID_SIZE,<br>
        math.round(position.Y / GRID_SIZE) * GRID_SIZE,<br>
        math.round(position.Z / GRID_SIZE) * GRID_SIZE<br>
    )<br>
end</p><p>function LevelBuilder.placeModule(moduleName, position, rotation)<br>
    local modules = ReplicatedStorage:WaitForChild(&quot;Modules&quot;)<br>
    local module = modules:FindFirstChild(moduleName)</p><p>    if not module then<br>
        warn(&quot;Module not found: &quot; .. moduleName)<br>
        return nil<br>
    end</p><p>    local clone = module:Clone()<br>
    local primaryPart = clone.PrimaryPart or clone:FindFirstChildWhichIsA(&quot;BasePart&quot;)</p><p>    if primaryPart then<br>
        local snappedPos = snapToGrid(position)<br>
        local cf = CFrame.new(snappedPos) * CFrame.Angles(0, math.rad(rotation or 0), 0)<br>
        clone:SetPrimaryPartCFrame(cf)<br>
    end</p><p>    clone.Parent = workspace.Level<br>
    return clone<br>
end</p><p>-- Common horror modules to create:<br>
-- Corridor_Straight, Corridor_Corner, Corridor_T<br>
-- Room_Small, Room_Medium, Room_Large<br>
-- Door_Single, Door_Double, Door_Locked<br>
-- Stairs_Up, Stairs_Down</p><p>return LevelBuilder</code></pre><h3>Procedural Placement</h3><p>For details that shouldn't be hand-placed:</p><pre><code class="language-lua">-- src/server/EnvironmentDetails.server.luau<br>
local function scatterDebris(room, density)<br>
    local bounds = room:GetBoundingBox()<br>
    local size = room:GetExtentsSize()</p><p>    local debrisTypes = {<br>
        &quot;Paper&quot;, &quot;Bottle&quot;, &quot;Can&quot;, &quot;Box&quot;,<br>
    }</p><p>    local count = math.floor(size.X <em> size.Z </em> density / 100)</p><p>    for i = 1, count do<br>
        local randomX = (math.random() - 0.5) <em> size.X </em> 0.8<br>
        local randomZ = (math.random() - 0.5) <em> size.Z </em> 0.8<br>
        local position = bounds.Position + Vector3.new(randomX, 0, randomZ)</p><p>        -- Raycast to find floor<br>
        local rayResult = workspace:Raycast(<br>
            position + Vector3.new(0, 10, 0),<br>
            Vector3.new(0, -20, 0)<br>
        )</p><p>        if rayResult then<br>
            local debris = ReplicatedStorage.Debris[debrisTypes[math.random(#debrisTypes)]]:Clone()<br>
            debris.Position = rayResult.Position<br>
            debris.Orientation = Vector3.new(<br>
                math.random(-15, 15),<br>
                math.random(0, 360),<br>
                math.random(-15, 15)<br>
            )<br>
            debris.Parent = room<br>
        end<br>
    end<br>
end</p><p>local function addBloodStains(room, count)<br>
    local decal = Instance.new(&quot;Decal&quot;)<br>
    decal.Texture = &quot;rbxassetid://YOUR_BLOOD_TEXTURE&quot;</p><p>    for i = 1, count do<br>
        local surfaces = {}<br>
        for _, part in ipairs(room:GetDescendants()) do<br>
            if part:IsA(&quot;BasePart&quot;) then<br>
                table.insert(surfaces, part)<br>
            end<br>
        end</p><p>        if #surfaces &gt; 0 then<br>
            local surface = surfaces[math.random(#surfaces)]<br>
            local stain = decal:Clone()<br>
            stain.Face = Enum.NormalId.Top  -- Floor stains<br>
            stain.Parent = surface<br>
        end<br>
    end<br>
end</code></pre><h2>Lighting Design</h2><p>Horror lighting follows specific rules:</p><h3>The Three-Point Darkness Rule</h3><p>1. <strong>Key light</strong> - One strong light source players navigate toward<br>
2. <strong>Fill darkness</strong> - Large areas of shadow between lights<br>
3. <strong>Accent lights</strong> - Small, colored lights that create unease</p><pre><code class="language-lua">-- src/server/LightingSetup.server.luau<br>
local function createHorrorLight(position, config)<br>
    config = config or {}</p><p>    local part = Instance.new(&quot;Part&quot;)<br>
    part.Name = &quot;LightSource&quot;<br>
    part.Anchored = true<br>
    part.CanCollide = false<br>
    part.Transparency = 1<br>
    part.Position = position<br>
    part.Parent = workspace.Lights</p><p>    local light = Instance.new(&quot;PointLight&quot;)<br>
    light.Brightness = config.brightness or 1<br>
    light.Range = config.range or 30<br>
    light.Color = config.color or Color3.fromRGB(255, 200, 150)<br>
    light.Shadows = config.shadows ~= false<br>
    light.Parent = part</p><p>    -- Add subtle flicker for atmosphere<br>
    if config.flicker then<br>
        task.spawn(function()<br>
            local baseBrightness = light.Brightness<br>
            while light.Parent do<br>
                local variance = (math.random() - 0.5) * config.flicker<br>
                light.Brightness = baseBrightness + variance<br>
                task.wait(0.05 + math.random() * 0.1)<br>
            end<br>
        end)<br>
    end</p><p>    return light<br>
end</p><p>-- Example usage:<br>
-- Emergency light (red, flickering)<br>
createHorrorLight(Vector3.new(0, 10, 0), {<br>
    brightness = 0.8,<br>
    range = 20,<br>
    color = Color3.fromRGB(255, 50, 50),<br>
    flicker = 0.3,<br>
})</p><p>-- Dying fluorescent (harsh, unstable)<br>
createHorrorLight(Vector3.new(20, 10, 0), {<br>
    brightness = 1.5,<br>
    range = 40,<br>
    color = Color3.fromRGB(200, 255, 200),<br>
    flicker = 0.5,<br>
})</code></pre><h3>Dynamic Light Zones</h3><p>Different areas should have different lighting moods:</p><pre><code class="language-lua">-- src/server/LightZones.server.luau<br>
local Lighting = game:GetService(&quot;Lighting&quot;)<br>
local Players = game:GetService(&quot;Players&quot;)</p><p>local LIGHT_ZONES = {<br>
    safe = {<br>
        Brightness = 0.8,<br>
        Ambient = Color3.fromRGB(40, 40, 50),<br>
        FogEnd = 300,<br>
    },<br>
    corridor = {<br>
        Brightness = 0.3,<br>
        Ambient = Color3.fromRGB(15, 15, 25),<br>
        FogEnd = 150,<br>
    },<br>
    danger = {<br>
        Brightness = 0.1,<br>
        Ambient = Color3.fromRGB(10, 5, 5),<br>
        FogEnd = 80,<br>
    },<br>
}</p><p>local function getPlayerZone(player)<br>
    local character = player.Character<br>
    if not character then return &quot;corridor&quot; end</p><p>    local rootPart = character:FindFirstChild(&quot;HumanoidRootPart&quot;)<br>
    if not rootPart then return &quot;corridor&quot; end</p><p>    -- Check which zone the player is in<br>
    for _, zone in ipairs(workspace.Zones:GetChildren()) do<br>
        local zoneType = zone:GetAttribute(&quot;ZoneType&quot;)<br>
        if zoneType and isInsideZone(rootPart.Position, zone) then<br>
            return zoneType<br>
        end<br>
    end</p><p>    return &quot;corridor&quot;<br>
end</p><p>local function isInsideZone(position, zonePart)<br>
    local relativePos = zonePart.CFrame:PointToObjectSpace(position)<br>
    local halfSize = zonePart.Size / 2<br>
    return math.abs(relativePos.X) &lt;= halfSize.X<br>
        and math.abs(relativePos.Y) &lt;= halfSize.Y<br>
        and math.abs(relativePos.Z) &lt;= halfSize.Z<br>
end</p><p>-- Per-player lighting would require post-processing effects<br>
-- For simplicity, use the &quot;most dangerous&quot; zone among all players<br>
local function updateGlobalLighting()<br>
    local mostDangerous = &quot;safe&quot;<br>
    local dangerRank = { safe = 0, corridor = 1, danger = 2 }</p><p>    for _, player in ipairs(Players:GetPlayers()) do<br>
        local zone = getPlayerZone(player)<br>
        if dangerRank[zone] &gt; dangerRank[mostDangerous] then<br>
            mostDangerous = zone<br>
        end<br>
    end</p><p>    local settings = LIGHT_ZONES[mostDangerous]<br>
    -- Tween to new settings<br>
    for property, value in pairs(settings) do<br>
        Lighting[property] = value<br>
    end<br>
end</code></pre><h2>Door Systems</h2><p>Doors are pivotal in horror—they create anticipation:</p><pre><code class="language-lua">-- src/server/DoorSystem.server.luau<br>
local TweenService = game:GetService(&quot;TweenService&quot;)<br>
local SoundService = game:GetService(&quot;SoundService&quot;)</p><p>local DoorSystem = {}</p><p>local DOOR_SOUNDS = {<br>
    open = &quot;rbxassetid://YOUR_DOOR_OPEN&quot;,<br>
    close = &quot;rbxassetid://YOUR_DOOR_CLOSE&quot;,<br>
    locked = &quot;rbxassetid://YOUR_DOOR_LOCKED&quot;,<br>
    unlock = &quot;rbxassetid://YOUR_DOOR_UNLOCK&quot;,<br>
    creak = &quot;rbxassetid://YOUR_DOOR_CREAK&quot;,<br>
}</p><p>function DoorSystem.setupDoor(doorModel)<br>
    local hinge = doorModel:FindFirstChild(&quot;Hinge&quot;)<br>
    local doorPart = doorModel:FindFirstChild(&quot;Door&quot;)</p><p>    if not hinge or not doorPart then<br>
        warn(&quot;Invalid door model: &quot; .. doorModel:GetFullName())<br>
        return<br>
    end</p><p>    local isOpen = false<br>
    local isLocked = doorModel:GetAttribute(&quot;Locked&quot;) or false<br>
    local requiredKey = doorModel:GetAttribute(&quot;RequiredKey&quot;)</p><p>    local originalCFrame = hinge.CFrame<br>
    local openCFrame = originalCFrame * CFrame.Angles(0, math.rad(90), 0)</p><p>    local prompt = Instance.new(&quot;ProximityPrompt&quot;)<br>
    prompt.ActionText = isLocked and &quot;Locked&quot; or &quot;Open&quot;<br>
    prompt.MaxActivationDistance = 6<br>
    prompt.HoldDuration = isLocked and 0.5 or 0<br>
    prompt.Parent = doorPart</p><p>    local function playSound(soundType)<br>
        local soundId = DOOR_SOUNDS[soundType]<br>
        if not soundId then return end</p><p>        local sound = Instance.new(&quot;Sound&quot;)<br>
        sound.SoundId = soundId<br>
        sound.RollOffMode = Enum.RollOffMode.Linear<br>
        sound.RollOffMaxDistance = 50<br>
        sound.Parent = doorPart<br>
        sound:Play()<br>
        sound.Ended:Connect(function() sound:Destroy() end)<br>
    end</p><p>    local function toggleDoor(player)<br>
        if isLocked then<br>
            -- Check if player has key<br>
            if requiredKey then<br>
                local inventory = getPlayerInventory(player)<br>
                if inventory:hasItem(requiredKey) then<br>
                    -- Unlock<br>
                    isLocked = false<br>
                    playSound(&quot;unlock&quot;)<br>
                    prompt.ActionText = &quot;Open&quot;<br>
                    prompt.HoldDuration = 0</p><p>                    -- Optionally consume key<br>
                    -- inventory:removeItem(requiredKey)<br>
                    return<br>
                end<br>
            end</p><p>            playSound(&quot;locked&quot;)<br>
            return<br>
        end</p><p>        isOpen = not isOpen</p><p>        local targetCFrame = isOpen and openCFrame or originalCFrame<br>
        local tweenInfo = TweenInfo.new(0.8, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)</p><p>        playSound(isOpen and &quot;open&quot; or &quot;close&quot;)</p><p>        -- Occasional creak<br>
        if math.random() &lt; 0.3 then<br>
            task.delay(0.2, function() playSound(&quot;creak&quot;) end)<br>
        end</p><p>        local tween = TweenService:Create(hinge, tweenInfo, {<br>
            CFrame = targetCFrame<br>
        })<br>
        tween:Play()</p><p>        prompt.ActionText = isOpen and &quot;Close&quot; or &quot;Open&quot;<br>
    end</p><p>    prompt.Triggered:Connect(toggleDoor)<br>
end</p><p>-- Creature can force doors<br>
function DoorSystem.forceDoor(doorModel, force)<br>
    local hinge = doorModel:FindFirstChild(&quot;Hinge&quot;)<br>
    if not hinge then return end</p><p>    local originalCFrame = hinge.CFrame<br>
    local forcedCFrame = originalCFrame * CFrame.Angles(0, math.rad(110), 0)</p><p>    -- Violent open<br>
    local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out)<br>
    local tween = TweenService:Create(hinge, tweenInfo, {<br>
        CFrame = forcedCFrame<br>
    })</p><p>    -- Play crash sound<br>
    local crash = Instance.new(&quot;Sound&quot;)<br>
    crash.SoundId = &quot;rbxassetid://YOUR_DOOR_CRASH&quot;<br>
    crash.Volume = 1.5<br>
    crash.Parent = doorModel<br>
    crash:Play()</p><p>    tween:Play()<br>
end</p><p>return DoorSystem</code></pre><h2>Hiding Spots</h2><p>Players need places to hide from the creature:</p><pre><code class="language-lua">-- src/server/HidingSpots.server.luau<br>
local CollectionService = game:GetService(&quot;CollectionService&quot;)<br>
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)</p><p>local HIDING_SPOTS = {}  -- Track occupied spots</p><p>local function setupHidingSpot(part)<br>
    local spotId = part:GetFullName()<br>
    HIDING_SPOTS[spotId] = {<br>
        part = part,<br>
        occupied = false,<br>
        occupant = nil,<br>
    }</p><p>    local prompt = Instance.new(&quot;ProximityPrompt&quot;)<br>
    prompt.ActionText = &quot;Hide&quot;<br>
    prompt.ObjectText = part:GetAttribute(&quot;SpotName&quot;) or &quot;Hiding Spot&quot;<br>
    prompt.MaxActivationDistance = 5<br>
    prompt.HoldDuration = 0.5<br>
    prompt.Parent = part</p><p>    prompt.Triggered:Connect(function(player)<br>
        local spot = HIDING_SPOTS[spotId]</p><p>        if spot.occupied then<br>
            -- Already occupied<br>
            return<br>
        end</p><p>        -- Hide the player<br>
        enterHidingSpot(player, spot)<br>
    end)<br>
end</p><p>local function enterHidingSpot(player, spot)<br>
    local character = player.Character<br>
    if not character then return end</p><p>    spot.occupied = true<br>
    spot.occupant = player</p><p>    -- Make player invisible<br>
    for _, part in ipairs(character:GetDescendants()) do<br>
        if part:IsA(&quot;BasePart&quot;) then<br>
            part.Transparency = 1<br>
        end<br>
    end</p><p>    -- Disable movement<br>
    local humanoid = character:FindFirstChildOfClass(&quot;Humanoid&quot;)<br>
    if humanoid then<br>
        humanoid.WalkSpeed = 0<br>
        humanoid.JumpPower = 0<br>
    end</p><p>    -- Position player at hiding spot<br>
    local rootPart = character:FindFirstChild(&quot;HumanoidRootPart&quot;)<br>
    if rootPart then<br>
        rootPart.CFrame = spot.part.CFrame<br>
        rootPart.Anchored = true<br>
    end</p><p>    -- Notify client<br>
    ReplicatedStorage.Events.EnteredHiding:FireClient(player, spot.part)</p><p>    -- Create exit prompt<br>
    local exitPrompt = Instance.new(&quot;ProximityPrompt&quot;)<br>
    exitPrompt.ActionText = &quot;Exit&quot;<br>
    exitPrompt.KeyboardKeyCode = Enum.KeyCode.E<br>
    exitPrompt.HoldDuration = 0.3<br>
    exitPrompt.Parent = spot.part</p><p>    exitPrompt.Triggered:Connect(function(exitPlayer)<br>
        if exitPlayer == player then<br>
            exitHidingSpot(player, spot)<br>
            exitPrompt:Destroy()<br>
        end<br>
    end)<br>
end</p><p>local function exitHidingSpot(player, spot)<br>
    local character = player.Character<br>
    if not character then return end</p><p>    spot.occupied = false<br>
    spot.occupant = nil</p><p>    -- Make player visible<br>
    for _, part in ipairs(character:GetDescendants()) do<br>
        if part:IsA(&quot;BasePart&quot;) and part.Name ~= &quot;HumanoidRootPart&quot; then<br>
            part.Transparency = 0<br>
        end<br>
    end</p><p>    -- Re-enable movement<br>
    local humanoid = character:FindFirstChildOfClass(&quot;Humanoid&quot;)<br>
    if humanoid then<br>
        humanoid.WalkSpeed = 16<br>
        humanoid.JumpPower = 50<br>
    end</p><p>    local rootPart = character:FindFirstChild(&quot;HumanoidRootPart&quot;)<br>
    if rootPart then<br>
        rootPart.Anchored = false<br>
        -- Move slightly out of hiding spot<br>
        rootPart.CFrame = rootPart.CFrame + rootPart.CFrame.LookVector * 3<br>
    end</p><p>    ReplicatedStorage.Events.ExitedHiding:FireClient(player)<br>
end</p><p>-- Creature detection - hiding isn't perfect<br>
local function canCreatureDetectHiddenPlayer(creature, spot)<br>
    -- Creature can detect if:<br>
    -- 1. Very close (within 5 studs)<br>
    -- 2. Player entered recently (within 3 seconds)<br>
    -- 3. Player is making noise</p><p>    local distance = (creature.rootPart.Position - spot.part.Position).Magnitude</p><p>    if distance &lt; 5 then<br>
        -- Close inspection - 50% chance to detect<br>
        return math.random() &lt; 0.5<br>
    end</p><p>    return false<br>
end</p><p>-- Setup existing spots<br>
for _, spot in ipairs(CollectionService:GetTagged(&quot;HidingSpot&quot;)) do<br>
    setupHidingSpot(spot)<br>
end</p><p>CollectionService:GetInstanceAddedSignal(&quot;HidingSpot&quot;):Connect(setupHidingSpot)</code></pre><h2>Interactive Objects</h2><p>Objects that players can examine or interact with:</p><pre><code class="language-lua">-- src/server/InteractiveObjects.server.luau<br>
local CollectionService = game:GetService(&quot;CollectionService&quot;)<br>
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)</p><p>local function setupInteractive(part)<br>
    local interactionType = part:GetAttribute(&quot;InteractionType&quot;)<br>
    local content = part:GetAttribute(&quot;Content&quot;)</p><p>    local prompt = Instance.new(&quot;ProximityPrompt&quot;)<br>
    prompt.MaxActivationDistance = 6<br>
    prompt.HoldDuration = 0.3<br>
    prompt.Parent = part</p><p>    if interactionType == &quot;note&quot; then<br>
        prompt.ActionText = &quot;Read&quot;<br>
        prompt.ObjectText = part:GetAttribute(&quot;Title&quot;) or &quot;Note&quot;</p><p>        prompt.Triggered:Connect(function(player)<br>
            ReplicatedStorage.Events.ShowNote:FireClient(player, {<br>
                title = part:GetAttribute(&quot;Title&quot;),<br>
                content = content,<br>
            })<br>
        end)</p><p>    elseif interactionType == &quot;examine&quot; then<br>
        prompt.ActionText = &quot;Examine&quot;<br>
        prompt.ObjectText = part:GetAttribute(&quot;ObjectName&quot;) or &quot;Object&quot;</p><p>        prompt.Triggered:Connect(function(player)<br>
            ReplicatedStorage.Events.ShowExamination:FireClient(player, {<br>
                name = part:GetAttribute(&quot;ObjectName&quot;),<br>
                description = content,<br>
                image = part:GetAttribute(&quot;ImageId&quot;),<br>
            })<br>
        end)</p><p>    elseif interactionType == &quot;switch&quot; then<br>
        prompt.ActionText = &quot;Use&quot;<br>
        prompt.ObjectText = part:GetAttribute(&quot;SwitchName&quot;) or &quot;Switch&quot;</p><p>        local isOn = part:GetAttribute(&quot;IsOn&quot;) or false</p><p>        prompt.Triggered:Connect(function(player)<br>
            isOn = not isOn<br>
            part:SetAttribute(&quot;IsOn&quot;, isOn)</p><p>            -- Fire linked events<br>
            local linkedId = part:GetAttribute(&quot;LinkedTo&quot;)<br>
            if linkedId then<br>
                ReplicatedStorage.Events.SwitchToggled:Fire(linkedId, isOn)<br>
            end</p><p>            -- Play sound<br>
            local sound = Instance.new(&quot;Sound&quot;)<br>
            sound.SoundId = &quot;rbxassetid://YOUR_SWITCH_SOUND&quot;<br>
            sound.Parent = part<br>
            sound:Play()<br>
        end)<br>
    end<br>
end</p><p>for _, obj in ipairs(CollectionService:GetTagged(&quot;Interactive&quot;)) do<br>
    setupInteractive(obj)<br>
end</p><p>CollectionService:GetInstanceAddedSignal(&quot;Interactive&quot;):Connect(setupInteractive)</code></pre><h2>Room Templates</h2><p>Pre-designed room types for consistent horror feel:</p><pre><code class="language-lua">-- src/shared/RoomTemplates.luau<br>
local RoomTemplates = {}</p><p>RoomTemplates.CORRIDOR = {<br>
    width = 8,<br>
    height = 12,<br>
    lightSpacing = 16,<br>
    debrisDensity = 0.3,<br>
    features = {&quot;flickering_light&quot;, &quot;pipe_sounds&quot;},<br>
}</p><p>RoomTemplates.STORAGE = {<br>
    minSize = Vector3.new(16, 12, 16),<br>
    maxSize = Vector3.new(32, 12, 32),<br>
    shelving = true,<br>
    debrisDensity = 0.5,<br>
    hidingSpots = {&quot;locker&quot;, &quot;behind_shelves&quot;},<br>
    features = {&quot;single_light&quot;, &quot;dripping_water&quot;},<br>
}</p><p>RoomTemplates.OFFICE = {<br>
    size = Vector3.new(24, 12, 24),<br>
    furniture = {&quot;desk&quot;, &quot;chair&quot;, &quot;filing_cabinet&quot;},<br>
    interactives = {&quot;computer&quot;, &quot;phone&quot;, &quot;notes&quot;},<br>
    lightType = &quot;fluorescent&quot;,<br>
    features = {&quot;computer_hum&quot;, &quot;flickering_monitor&quot;},<br>
}</p><p>RoomTemplates.MEDICAL = {<br>
    size = Vector3.new(32, 12, 24),<br>
    furniture = {&quot;examination_table&quot;, &quot;cabinet&quot;, &quot;sink&quot;},<br>
    loot = {&quot;medkit&quot;, &quot;bandage&quot;, &quot;syringe&quot;},<br>
    lightType = &quot;harsh_white&quot;,<br>
    features = {&quot;medical_equipment_beeps&quot;, &quot;blood_stains&quot;},<br>
}</p><p>RoomTemplates.GENERATOR = {<br>
    size = Vector3.new(24, 16, 24),<br>
    machinery = true,<br>
    loudAmbient = true,<br>
    objective = &quot;power_restore&quot;,<br>
    features = {&quot;loud_hum&quot;, &quot;steam_vents&quot;, &quot;warning_lights&quot;},<br>
}</p><p>return RoomTemplates</code></pre><h2>Vibe Coding Level Design</h2><p>When working with AI on environment design:</p><p>> "Create a modular corridor system with 8-stud grid snapping and door connections"</p><p>> "Add a hiding spot system where players become invisible but creatures can detect them if too close"</p><p>> "Build a room template for an abandoned medical bay with examination tables, cabinets, and flickering lights"</p><p>> "Implement an interactive note system that displays text overlays when players examine objects"</p><p>The AI handles the Roblox specifics—CFrames, tweens, collision groups. You focus on the spatial experience.</p><h2>Testing Environments</h2><p>Walk through your spaces as a player:</p><p>1. <strong>Sightline check</strong> - Can you see too far? Too little?<br>
2. <strong>Navigation check</strong> - Can you find your way? Get lost in the right places?<br>
3. <strong>Audio check</strong> - Does sound tell a story? Create uncertainty?<br>
4. <strong>Pacing check</strong> - Are there moments of relief between tension?</p><h2>Next Steps</h2><p>With environments built, we have all the pieces for a single-player horror experience. But horror is amplified with others. In the next chapter, we'll add multiplayer systems that let friends survive—or die—together.<br>
</p>
    </section>
  

    <section id="chapter-6" class="chapter">
      <h2>Multiplayer Systems</h2>
      <p>Horror alone is terrifying. Horror together is a shared experience that bonds players through fear. But multiplayer horror introduces unique design challenges—coordinating players, sharing resources, and keeping tension when safety comes in numbers.</p><p>This chapter covers building co-op survival horror in Roblox.</p><h2>The Multiplayer Horror Paradox</h2><p>More players means more safety. This seems to undermine horror. But smart design turns multiplayer into an amplifier:</p><p>- <strong>Shared vulnerability</strong> - If one player dies, everyone suffers<br>
- <strong>Resource splitting</strong> - Items must be shared, creating tension<br>
- <strong>Communication</strong> - Coordinating requires noise, which attracts danger<br>
- <strong>Separation</strong> - The creature can split the group</p><h2>Player Data Management</h2><p>Server-authoritative data prevents cheating and ensures sync:</p><pre><code class="language-lua">-- src/server/PlayerData.server.luau<br>
local Players = game:GetService(&quot;Players&quot;)<br>
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)</p><p>local Inventory = require(ReplicatedStorage.Shared.Inventory)<br>
local PlayerStats = require(ReplicatedStorage.Shared.PlayerStats)</p><p>local PlayerData = {<br>
    players = {},<br>
}</p><p>function PlayerData.initPlayer(player)<br>
    PlayerData.players[player] = {<br>
        stats = PlayerStats.new(),<br>
        inventory = Inventory.new(10, 20),  -- 10 slots, 20 weight<br>
        isAlive = true,<br>
        spawnTime = tick(),<br>
        deathCount = 0,<br>
    }</p><p>    -- Give starting items<br>
    PlayerData.players[player].inventory:addItem(&quot;flashlight&quot;, 1)<br>
    PlayerData.players[player].inventory:addItem(&quot;battery&quot;, 2)</p><p>    -- Sync to client<br>
    PlayerData.syncToClient(player)<br>
end</p><p>function PlayerData.getPlayerData(player)<br>
    return PlayerData.players[player]<br>
end</p><p>function PlayerData.syncToClient(player)<br>
    local data = PlayerData.players[player]<br>
    if not data then return end</p><p>    -- Send stats<br>
    ReplicatedStorage.Events.StatsUpdated:FireClient(player, {<br>
        health = data.stats.health,<br>
        maxHealth = data.stats.maxHealth,<br>
        stamina = data.stats.stamina,<br>
        maxStamina = data.stats.maxStamina,<br>
    })</p><p>    -- Send inventory<br>
    ReplicatedStorage.Events.InventoryUpdated:FireClient(<br>
        player,<br>
        data.inventory.slots,<br>
        data.inventory:getCurrentWeight(),<br>
        data.inventory.maxWeight<br>
    )<br>
end</p><p>function PlayerData.syncToAll()<br>
    for player in pairs(PlayerData.players) do<br>
        PlayerData.syncToClient(player)<br>
    end<br>
end</p><p>-- Player lifecycle<br>
Players.PlayerAdded:Connect(function(player)<br>
    PlayerData.initPlayer(player)</p><p>    player.CharacterAdded:Connect(function(character)<br>
        local data = PlayerData.players[player]<br>
        if data then<br>
            data.isAlive = true</p><p>            -- Apply stats to humanoid<br>
            local humanoid = character:WaitForChild(&quot;Humanoid&quot;)<br>
            humanoid.MaxHealth = data.stats.maxHealth<br>
            humanoid.Health = data.stats.health</p><p>            humanoid.Died:Connect(function()<br>
                PlayerData.onPlayerDeath(player)<br>
            end)<br>
        end<br>
    end)<br>
end)</p><p>Players.PlayerRemoving:Connect(function(player)<br>
    PlayerData.players[player] = nil<br>
end)</p><p>function PlayerData.onPlayerDeath(player)<br>
    local data = PlayerData.players[player]<br>
    if not data then return end</p><p>    data.isAlive = false<br>
    data.deathCount = data.deathCount + 1</p><p>    -- Notify all players<br>
    for otherPlayer in pairs(PlayerData.players) do<br>
        ReplicatedStorage.Events.PlayerDied:FireClient(otherPlayer, player.Name)<br>
    end</p><p>    -- Check for team wipe<br>
    local anyAlive = false<br>
    for _, pData in pairs(PlayerData.players) do<br>
        if pData.isAlive then<br>
            anyAlive = true<br>
            break<br>
        end<br>
    end</p><p>    if not anyAlive then<br>
        PlayerData.onTeamWipe()<br>
    end<br>
end</p><p>function PlayerData.onTeamWipe()<br>
    -- Game over<br>
    for player in pairs(PlayerData.players) do<br>
        ReplicatedStorage.Events.GameOver:FireClient(player, {<br>
            reason = &quot;Everyone died&quot;,<br>
            stats = PlayerData.getGameStats(),<br>
        })<br>
    end<br>
end</p><p>function PlayerData.getGameStats()<br>
    local stats = {<br>
        survivalTime = 0,<br>
        totalDeaths = 0,<br>
        itemsCollected = 0,<br>
    }</p><p>    for _, data in pairs(PlayerData.players) do<br>
        stats.totalDeaths = stats.totalDeaths + data.deathCount<br>
    end</p><p>    return stats<br>
end</p><p>return PlayerData</code></pre><h2>Team Communication</h2><p>In-game voice or text creates immersion:</p><pre><code class="language-lua">-- src/server/TeamChat.server.luau<br>
local Players = game:GetService(&quot;Players&quot;)<br>
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)<br>
local TextService = game:GetService(&quot;TextService&quot;)</p><p>local PROXIMITY_RANGE = 50  -- Studs for proximity chat<br>
local WHISPER_RANGE = 15    -- Studs for whisper</p><p>local function getDistance(player1, player2)<br>
    local char1 = player1.Character<br>
    local char2 = player2.Character<br>
    if not char1 or not char2 then return math.huge end</p><p>    local root1 = char1:FindFirstChild(&quot;HumanoidRootPart&quot;)<br>
    local root2 = char2:FindFirstChild(&quot;HumanoidRootPart&quot;)<br>
    if not root1 or not root2 then return math.huge end</p><p>    return (root1.Position - root2.Position).Magnitude<br>
end</p><p>local function filterMessage(player, message)<br>
    local success, result = pcall(function()<br>
        return TextService:FilterStringAsync(message, player.UserId)<br>
    end)</p><p>    if success then<br>
        return result:GetNonChatStringForBroadcastAsync()<br>
    end<br>
    return &quot;[filtered]&quot;<br>
end</p><p>-- Proximity chat - only nearby players hear<br>
ReplicatedStorage.Events.SendProximityMessage.OnServerEvent:Connect(function(sender, message)<br>
    local filtered = filterMessage(sender, message)</p><p>    for _, receiver in ipairs(Players:GetPlayers()) do<br>
        local distance = getDistance(sender, receiver)</p><p>        if distance &lt;= PROXIMITY_RANGE then<br>
            -- Volume based on distance<br>
            local volume = 1 - (distance / PROXIMITY_RANGE)</p><p>            ReplicatedStorage.Events.ReceiveProximityMessage:FireClient(<br>
                receiver,<br>
                sender.Name,<br>
                filtered,<br>
                volume<br>
            )<br>
        end<br>
    end</p><p>    -- IMPORTANT: Proximity chat attracts creature<br>
    notifyCreatureOfNoise(sender, &quot;voice&quot;, PROXIMITY_RANGE * 0.5)<br>
end)</p><p>-- Whisper - very close range, quieter<br>
ReplicatedStorage.Events.SendWhisper.OnServerEvent:Connect(function(sender, message)<br>
    local filtered = filterMessage(sender, message)</p><p>    for _, receiver in ipairs(Players:GetPlayers()) do<br>
        local distance = getDistance(sender, receiver)</p><p>        if distance &lt;= WHISPER_RANGE then<br>
            ReplicatedStorage.Events.ReceiveWhisper:FireClient(<br>
                receiver,<br>
                sender.Name,<br>
                filtered<br>
            )<br>
        end<br>
    end</p><p>    -- Whispers make less noise<br>
    notifyCreatureOfNoise(sender, &quot;whisper&quot;, WHISPER_RANGE * 0.3)<br>
end)</p><p>-- Radio - global but uses batteries<br>
ReplicatedStorage.Events.SendRadioMessage.OnServerEvent:Connect(function(sender, message)<br>
    local playerData = getPlayerData(sender)<br>
    if not playerData.inventory:hasItem(&quot;radio&quot;) then<br>
        return<br>
    end</p><p>    local filtered = filterMessage(sender, message)</p><p>    for _, receiver in ipairs(Players:GetPlayers()) do<br>
        if receiver ~= sender and getPlayerData(receiver).inventory:hasItem(&quot;radio&quot;) then<br>
            ReplicatedStorage.Events.ReceiveRadioMessage:FireClient(<br>
                receiver,<br>
                sender.Name,<br>
                filtered<br>
            )<br>
        end<br>
    end</p><p>    -- Radios are LOUD<br>
    notifyCreatureOfNoise(sender, &quot;radio&quot;, 100)<br>
end)</code></pre><h2>Item Trading</h2><p>Players should be able to share resources:</p><pre><code class="language-lua">-- src/server/Trading.server.luau<br>
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)</p><p>local TRADE_RANGE = 10</p><p>local activeTrades = {}</p><p>local function startTrade(initiator, target)<br>
    local initiatorRoot = initiator.Character and initiator.Character:FindFirstChild(&quot;HumanoidRootPart&quot;)<br>
    local targetRoot = target.Character and target.Character:FindFirstChild(&quot;HumanoidRootPart&quot;)</p><p>    if not initiatorRoot or not targetRoot then return end</p><p>    local distance = (initiatorRoot.Position - targetRoot.Position).Magnitude<br>
    if distance &gt; TRADE_RANGE then<br>
        ReplicatedStorage.Events.TradeFailed:FireClient(initiator, &quot;Too far away&quot;)<br>
        return<br>
    end</p><p>    local tradeId = initiator.UserId .. &quot;_&quot; .. target.UserId .. &quot;_&quot; .. tick()</p><p>    activeTrades[tradeId] = {<br>
        initiator = initiator,<br>
        target = target,<br>
        initiatorItems = {},<br>
        targetItems = {},<br>
        initiatorReady = false,<br>
        targetReady = false,<br>
    }</p><p>    ReplicatedStorage.Events.TradeRequest:FireClient(target, initiator.Name, tradeId)<br>
    ReplicatedStorage.Events.TradeStarted:FireClient(initiator, target.Name, tradeId)<br>
end</p><p>local function acceptTrade(player, tradeId)<br>
    local trade = activeTrades[tradeId]<br>
    if not trade then return end</p><p>    if player ~= trade.target then return end</p><p>    ReplicatedStorage.Events.TradeAccepted:FireClient(trade.initiator, tradeId)<br>
    ReplicatedStorage.Events.TradeAccepted:FireClient(trade.target, tradeId)<br>
end</p><p>local function addItemToTrade(player, tradeId, itemId, quantity)<br>
    local trade = activeTrades[tradeId]<br>
    if not trade then return end</p><p>    local playerData = getPlayerData(player)<br>
    if not playerData.inventory:hasItem(itemId, quantity) then<br>
        return<br>
    end</p><p>    local itemList<br>
    if player == trade.initiator then<br>
        itemList = trade.initiatorItems<br>
    elseif player == trade.target then<br>
        itemList = trade.targetItems<br>
    else<br>
        return<br>
    end</p><p>    table.insert(itemList, { itemId = itemId, quantity = quantity })</p><p>    -- Sync to both players<br>
    ReplicatedStorage.Events.TradeUpdated:FireClient(trade.initiator, tradeId, trade)<br>
    ReplicatedStorage.Events.TradeUpdated:FireClient(trade.target, tradeId, trade)<br>
end</p><p>local function confirmTrade(player, tradeId)<br>
    local trade = activeTrades[tradeId]<br>
    if not trade then return end</p><p>    if player == trade.initiator then<br>
        trade.initiatorReady = true<br>
    elseif player == trade.target then<br>
        trade.targetReady = true<br>
    end</p><p>    -- Both ready - execute trade<br>
    if trade.initiatorReady and trade.targetReady then<br>
        executeTrade(trade)<br>
        activeTrades[tradeId] = nil<br>
    end<br>
end</p><p>local function executeTrade(trade)<br>
    local initiatorData = getPlayerData(trade.initiator)<br>
    local targetData = getPlayerData(trade.target)</p><p>    -- Remove items from initiator, add to target<br>
    for _, item in ipairs(trade.initiatorItems) do<br>
        if initiatorData.inventory:removeItem(item.itemId, item.quantity) then<br>
            targetData.inventory:addItem(item.itemId, item.quantity)<br>
        end<br>
    end</p><p>    -- Remove items from target, add to initiator<br>
    for _, item in ipairs(trade.targetItems) do<br>
        if targetData.inventory:removeItem(item.itemId, item.quantity) then<br>
            initiatorData.inventory:addItem(item.itemId, item.quantity)<br>
        end<br>
    end</p><p>    -- Sync inventories<br>
    syncToClient(trade.initiator)<br>
    syncToClient(trade.target)</p><p>    ReplicatedStorage.Events.TradeCompleted:FireClient(trade.initiator, tradeId)<br>
    ReplicatedStorage.Events.TradeCompleted:FireClient(trade.target, tradeId)<br>
end</p><p>-- Quick drop for emergencies<br>
ReplicatedStorage.Events.DropItem.OnServerEvent:Connect(function(player, itemId, quantity)<br>
    local playerData = getPlayerData(player)<br>
    if not playerData.inventory:hasItem(itemId, quantity) then return end</p><p>    local character = player.Character<br>
    if not character then return end</p><p>    local rootPart = character:FindFirstChild(&quot;HumanoidRootPart&quot;)<br>
    if not rootPart then return end</p><p>    -- Remove from inventory<br>
    playerData.inventory:removeItem(itemId, quantity)</p><p>    -- Spawn pickup in world<br>
    local pickup = createPickup(itemId, quantity)<br>
    pickup.Position = rootPart.Position + Vector3.new(0, 0, 3)<br>
    pickup.Parent = workspace.Items</p><p>    syncToClient(player)<br>
end)</code></pre><h2>Player Revival</h2><p>Downed players can be revived by teammates:</p><pre><code class="language-lua">-- src/server/Revival.server.luau<br>
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)<br>
local Players = game:GetService(&quot;Players&quot;)</p><p>local REVIVAL_TIME = 5  -- Seconds to revive<br>
local BLEEDOUT_TIME = 60  -- Seconds before permanent death</p><p>local downedPlayers = {}</p><p>local function onPlayerDowned(player)<br>
    local character = player.Character<br>
    if not character then return end</p><p>    local humanoid = character:FindFirstChildOfClass(&quot;Humanoid&quot;)<br>
    if not humanoid then return end</p><p>    -- Don't die immediately - go to downed state<br>
    humanoid.Health = 1<br>
    humanoid.WalkSpeed = 0<br>
    humanoid.JumpPower = 0</p><p>    downedPlayers[player] = {<br>
        downedAt = tick(),<br>
        isBeingRevived = false,<br>
        reviver = nil,<br>
    }</p><p>    -- Play downed animation<br>
    local animator = humanoid:FindFirstChildOfClass(&quot;Animator&quot;)<br>
    if animator then<br>
        local animation = Instance.new(&quot;Animation&quot;)<br>
        animation.AnimationId = &quot;rbxassetid://YOUR_DOWNED_ANIMATION&quot;<br>
        animator:LoadAnimation(animation):Play()<br>
    end</p><p>    -- Notify all players<br>
    for _, p in ipairs(Players:GetPlayers()) do<br>
        ReplicatedStorage.Events.PlayerDowned:FireClient(p, player.Name)<br>
    end</p><p>    -- Create revival prompt<br>
    local prompt = Instance.new(&quot;ProximityPrompt&quot;)<br>
    prompt.ActionText = &quot;Revive&quot;<br>
    prompt.ObjectText = player.Name<br>
    prompt.HoldDuration = REVIVAL_TIME<br>
    prompt.RequiresLineOfSight = false<br>
    prompt.MaxActivationDistance = 5<br>
    prompt.Parent = character.HumanoidRootPart</p><p>    prompt.PromptButtonHoldBegan:Connect(function(reviver)<br>
        downedPlayers[player].isBeingRevived = true<br>
        downedPlayers[player].reviver = reviver<br>
    end)</p><p>    prompt.PromptButtonHoldEnded:Connect(function()<br>
        downedPlayers[player].isBeingRevived = false<br>
        downedPlayers[player].reviver = nil<br>
    end)</p><p>    prompt.Triggered:Connect(function(reviver)<br>
        revivePlayer(player, reviver)<br>
        prompt:Destroy()<br>
    end)</p><p>    -- Bleedout timer<br>
    task.spawn(function()<br>
        while downedPlayers[player] do<br>
            task.wait(1)</p><p>            local elapsed = tick() - downedPlayers[player].downedAt</p><p>            -- Sync bleedout timer to downed player<br>
            local remaining = BLEEDOUT_TIME - elapsed<br>
            ReplicatedStorage.Events.BleedoutTimer:FireClient(player, remaining)</p><p>            if elapsed &gt;= BLEEDOUT_TIME then<br>
                -- Permanent death<br>
                permanentDeath(player)<br>
                break<br>
            end<br>
        end<br>
    end)<br>
end</p><p>local function revivePlayer(player, reviver)<br>
    if not downedPlayers[player] then return end</p><p>    local character = player.Character<br>
    if not character then return end</p><p>    local humanoid = character:FindFirstChildOfClass(&quot;Humanoid&quot;)<br>
    if not humanoid then return end</p><p>    -- Restore player<br>
    humanoid.Health = humanoid.MaxHealth * 0.5  -- Revive at half health<br>
    humanoid.WalkSpeed = 16<br>
    humanoid.JumpPower = 50</p><p>    downedPlayers[player] = nil</p><p>    -- Notify all players<br>
    for _, p in ipairs(Players:GetPlayers()) do<br>
        ReplicatedStorage.Events.PlayerRevived:FireClient(p, player.Name, reviver.Name)<br>
    end<br>
end</p><p>local function permanentDeath(player)<br>
    downedPlayers[player] = nil</p><p>    local character = player.Character<br>
    if character then<br>
        local humanoid = character:FindFirstChildOfClass(&quot;Humanoid&quot;)<br>
        if humanoid then<br>
            humanoid.Health = 0<br>
        end<br>
    end<br>
end</p><p>-- Hook into damage system<br>
ReplicatedStorage.Events.PlayerTakeDamage.OnServerEvent:Connect(function(player, amount)<br>
    local playerData = getPlayerData(player)<br>
    local character = player.Character<br>
    local humanoid = character and character:FindFirstChildOfClass(&quot;Humanoid&quot;)</p><p>    if humanoid and humanoid.Health - amount &lt;= 0 then<br>
        if not downedPlayers[player] then<br>
            -- First down - go to downed state<br>
            humanoid.Health = 1<br>
            onPlayerDowned(player)<br>
        end<br>
    end<br>
end)</code></pre><h2>Spectating Dead Players</h2><p>Dead players should be able to watch teammates:</p><pre><code class="language-lua">-- src/client/Spectator.client.luau<br>
local Players = game:GetService(&quot;Players&quot;)<br>
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)<br>
local UserInputService = game:GetService(&quot;UserInputService&quot;)</p><p>local player = Players.LocalPlayer<br>
local camera = workspace.CurrentCamera</p><p>local isSpectating = false<br>
local spectateTarget = nil<br>
local spectateIndex = 1</p><p>local function getAlivePlayers()<br>
    local alive = {}<br>
    for _, p in ipairs(Players:GetPlayers()) do<br>
        if p ~= player and p.Character and p.Character:FindFirstChildOfClass(&quot;Humanoid&quot;) then<br>
            local humanoid = p.Character:FindFirstChildOfClass(&quot;Humanoid&quot;)<br>
            if humanoid.Health &gt; 0 then<br>
                table.insert(alive, p)<br>
            end<br>
        end<br>
    end<br>
    return alive<br>
end</p><p>local function startSpectating()<br>
    isSpectating = true</p><p>    local alivePlayers = getAlivePlayers()<br>
    if #alivePlayers == 0 then<br>
        -- No one to spectate<br>
        return<br>
    end</p><p>    spectateTarget = alivePlayers[1]<br>
    spectateIndex = 1</p><p>    camera.CameraType = Enum.CameraType.Custom<br>
    camera.CameraSubject = spectateTarget.Character:FindFirstChildOfClass(&quot;Humanoid&quot;)</p><p>    -- Show spectate UI<br>
    showSpectateUI(spectateTarget.Name)<br>
end</p><p>local function cycleSpectateTarget(direction)<br>
    local alivePlayers = getAlivePlayers()<br>
    if #alivePlayers == 0 then return end</p><p>    spectateIndex = spectateIndex + direction<br>
    if spectateIndex &gt; #alivePlayers then<br>
        spectateIndex = 1<br>
    elseif spectateIndex &lt; 1 then<br>
        spectateIndex = #alivePlayers<br>
    end</p><p>    spectateTarget = alivePlayers[spectateIndex]<br>
    camera.CameraSubject = spectateTarget.Character:FindFirstChildOfClass(&quot;Humanoid&quot;)<br>
    updateSpectateUI(spectateTarget.Name)<br>
end</p><p>local function stopSpectating()<br>
    isSpectating = false<br>
    spectateTarget = nil</p><p>    -- Reset camera when respawning<br>
    if player.Character then<br>
        camera.CameraSubject = player.Character:FindFirstChildOfClass(&quot;Humanoid&quot;)<br>
    end</p><p>    hideSpectateUI()<br>
end</p><p>-- Enter spectate mode on death<br>
ReplicatedStorage.Events.EnterSpectateMode.OnClientEvent:Connect(startSpectating)</p><p>-- Cycle targets<br>
UserInputService.InputBegan:Connect(function(input, processed)<br>
    if processed or not isSpectating then return end</p><p>    if input.KeyCode == Enum.KeyCode.Q then<br>
        cycleSpectateTarget(-1)<br>
    elseif input.KeyCode == Enum.KeyCode.E then<br>
        cycleSpectateTarget(1)<br>
    end<br>
end)</p><p>-- Exit on respawn<br>
player.CharacterAdded:Connect(stopSpectating)</code></pre><h2>Objective Coordination</h2><p>Multiplayer objectives require teamwork:</p><pre><code class="language-lua">-- src/server/Objectives.server.luau<br>
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)<br>
local Players = game:GetService(&quot;Players&quot;)</p><p>local Objectives = {<br>
    current = nil,<br>
    completed = {},<br>
}</p><p>local OBJECTIVE_TYPES = {<br>
    collect = {<br>
        setup = function(obj)<br>
            obj.collected = 0<br>
            obj.required = obj.data.count or 3<br>
        end,<br>
        check = function(obj)<br>
            return obj.collected &gt;= obj.required<br>
        end,<br>
        progress = function(obj)<br>
            return obj.collected .. &quot;/&quot; .. obj.required<br>
        end,<br>
    },</p><p>    survive = {<br>
        setup = function(obj)<br>
            obj.startTime = tick()<br>
            obj.duration = obj.data.duration or 120<br>
        end,<br>
        check = function(obj)<br>
            return tick() - obj.startTime &gt;= obj.duration<br>
        end,<br>
        progress = function(obj)<br>
            local remaining = obj.duration - (tick() - obj.startTime)<br>
            return string.format(&quot;%d:%02d&quot;, remaining / 60, remaining % 60)<br>
        end,<br>
    },</p><p>    activate = {<br>
        setup = function(obj)<br>
            obj.activated = {}<br>
            obj.required = obj.data.targets or {}<br>
        end,<br>
        check = function(obj)<br>
            for _, target in ipairs(obj.required) do<br>
                if not obj.activated[target] then<br>
                    return false<br>
                end<br>
            end<br>
            return true<br>
        end,<br>
        progress = function(obj)<br>
            local count = 0<br>
            for _ in pairs(obj.activated) do count = count + 1 end<br>
            return count .. &quot;/&quot; .. #obj.required<br>
        end,<br>
    },</p><p>    escape = {<br>
        setup = function(obj)<br>
            obj.playersEscaped = {}<br>
            obj.escapeZone = obj.data.zone<br>
        end,<br>
        check = function(obj)<br>
            -- All alive players must escape<br>
            for _, player in ipairs(Players:GetPlayers()) do<br>
                local data = getPlayerData(player)<br>
                if data.isAlive and not obj.playersEscaped[player] then<br>
                    return false<br>
                end<br>
            end<br>
            return true<br>
        end,<br>
        progress = function(obj)<br>
            local escaped = 0<br>
            for _ in pairs(obj.playersEscaped) do escaped = escaped + 1 end<br>
            local alive = 0<br>
            for _, player in ipairs(Players:GetPlayers()) do<br>
                if getPlayerData(player).isAlive then alive = alive + 1 end<br>
            end<br>
            return escaped .. &quot;/&quot; .. alive .. &quot; escaped&quot;<br>
        end,<br>
    },<br>
}</p><p>function Objectives.start(objectiveId, objectiveType, data)<br>
    local typeHandler = OBJECTIVE_TYPES[objectiveType]<br>
    if not typeHandler then return end</p><p>    local obj = {<br>
        id = objectiveId,<br>
        type = objectiveType,<br>
        data = data,<br>
        description = data.description or &quot;Complete the objective&quot;,<br>
    }</p><p>    typeHandler.setup(obj)<br>
    Objectives.current = obj</p><p>    -- Notify all players<br>
    Objectives.sync()<br>
end</p><p>function Objectives.update(updateType, updateData)<br>
    local obj = Objectives.current<br>
    if not obj then return end</p><p>    if obj.type == &quot;collect&quot; and updateType == &quot;collected&quot; then<br>
        obj.collected = obj.collected + 1<br>
    elseif obj.type == &quot;activate&quot; and updateType == &quot;activated&quot; then<br>
        obj.activated[updateData.target] = true<br>
    elseif obj.type == &quot;escape&quot; and updateType == &quot;escaped&quot; then<br>
        obj.playersEscaped[updateData.player] = true<br>
    end</p><p>    -- Check completion<br>
    local typeHandler = OBJECTIVE_TYPES[obj.type]<br>
    if typeHandler.check(obj) then<br>
        Objectives.complete()<br>
    else<br>
        Objectives.sync()<br>
    end<br>
end</p><p>function Objectives.complete()<br>
    local obj = Objectives.current<br>
    if not obj then return end</p><p>    table.insert(Objectives.completed, obj.id)<br>
    Objectives.current = nil</p><p>    for _, player in ipairs(Players:GetPlayers()) do<br>
        ReplicatedStorage.Events.ObjectiveCompleted:FireClient(player, obj.description)<br>
    end</p><p>    -- Trigger next objective or victory<br>
    onObjectiveCompleted(obj.id)<br>
end</p><p>function Objectives.sync()<br>
    local obj = Objectives.current<br>
    if not obj then return end</p><p>    local typeHandler = OBJECTIVE_TYPES[obj.type]</p><p>    for _, player in ipairs(Players:GetPlayers()) do<br>
        ReplicatedStorage.Events.ObjectiveUpdated:FireClient(player, {<br>
            description = obj.description,<br>
            progress = typeHandler.progress(obj),<br>
        })<br>
    end<br>
end</p><p>return Objectives</code></pre><h2>Shared Threat Response</h2><p>The creature should respond to the group:</p><pre><code class="language-lua">-- src/server/CreatureMultiplayer.luau<br>
-- Extension to creature AI for multiplayer</p><p>function CreatureAI:selectTarget()<br>
    local players = Players:GetPlayers()<br>
    local candidates = {}</p><p>    for _, player in ipairs(players) do<br>
        if self:canSee(player) or self:canHear(player) then<br>
            local distance = self:getDistanceToPlayer(player)<br>
            local threat = self:calculateThreatLevel(player)</p><p>            table.insert(candidates, {<br>
                player = player,<br>
                distance = distance,<br>
                threat = threat,<br>
                score = threat / distance,  -- Higher score = more attractive target<br>
            })<br>
        end<br>
    end</p><p>    if #candidates == 0 then<br>
        return nil<br>
    end</p><p>    -- Sort by score<br>
    table.sort(candidates, function(a, b)<br>
        return a.score &gt; b.score<br>
    end)</p><p>    -- Usually pick highest score, but sometimes switch targets<br>
    if math.random() &lt; 0.2 and #candidates &gt; 1 then<br>
        return candidates[2].player<br>
    end</p><p>    return candidates[1].player<br>
end</p><p>function CreatureAI:calculateThreatLevel(player)<br>
    local threat = 1</p><p>    -- Flashlight on = more visible<br>
    if playerHasFlashlightOn(player) then<br>
        threat = threat * 1.5<br>
    end</p><p>    -- Making noise = more attractive<br>
    local velocity = getPlayerVelocity(player)<br>
    if velocity &gt; 20 then<br>
        threat = threat * 2  -- Running<br>
    elseif velocity &gt; 5 then<br>
        threat = threat * 1.3  -- Walking<br>
    end</p><p>    -- Isolated players are easier targets<br>
    local nearbyAllies = countNearbyPlayers(player, 20)<br>
    if nearbyAllies == 0 then<br>
        threat = threat * 1.5  -- Alone<br>
    end</p><p>    -- Injured players are easier<br>
    local health = getPlayerHealth(player)<br>
    if health &lt; 50 then<br>
        threat = threat * 1.3<br>
    end</p><p>    return threat<br>
end</p><p>-- Split the party<br>
function CreatureAI:trySplitGroup()<br>
    local players = Players:GetPlayers()<br>
    if #players &lt; 2 then return end</p><p>    -- Find the two players furthest apart<br>
    local maxDistance = 0<br>
    local player1, player2</p><p>    for i, p1 in ipairs(players) do<br>
        for j, p2 in ipairs(players) do<br>
            if i &lt; j then<br>
                local dist = getDistanceBetweenPlayers(p1, p2)<br>
                if dist &gt; maxDistance then<br>
                    maxDistance = dist<br>
                    player1 = p1<br>
                    player2 = p2<br>
                end<br>
            end<br>
        end<br>
    end</p><p>    -- If players are already somewhat separated, go for the isolated one<br>
    if maxDistance &gt; 30 then<br>
        local alone1 = countNearbyPlayers(player1, 15) == 0<br>
        local alone2 = countNearbyPlayers(player2, 15) == 0</p><p>        if alone1 then<br>
            self.target = player1<br>
        elseif alone2 then<br>
            self.target = player2<br>
        end<br>
    end<br>
end</code></pre><h2>Vibe Coding Multiplayer</h2><p>When building multiplayer systems with AI:</p><p>> "Create a proximity chat system where messages only reach players within 50 studs"</p><p>> "Build a player revival system with 5-second revive time and 60-second bleedout"</p><p>> "Implement item trading between players within 10 studs of each other"</p><p>> "Add spectator mode for dead players to watch living teammates"</p><p>The AI handles the networking boilerplate—RemoteEvents, data sync, edge cases. You focus on the social dynamics.</p><h2>Playtesting Multiplayer</h2><p>Multiplayer horror requires specific testing:</p><p>1. <strong>Solo test</strong> - Does it work with one player?<br>
2. <strong>Duo test</strong> - The most common multiplayer scenario<br>
3. <strong>Full lobby</strong> - Does it scale? Is it still scary?<br>
4. <strong>Asymmetric test</strong> - One good player, one new player<br>
5. <strong>Grief test</strong> - Can players ruin each other's experience?</p><h2>Next Steps</h2><p>With multiplayer working, we have a complete horror game. But "complete" isn't "polished." In the final chapter, we'll cover the finishing touches—UI polish, sound design refinement, performance optimization, and publishing your game to the Roblox platform.<br>
</p>
    </section>
  

    <section id="chapter-7" class="chapter">
      <h2>Polish and Publishing</h2>
      <p>A game that works isn't the same as a game that shines. Polish transforms functional systems into memorable experiences. This final chapter covers the finishing touches that separate amateur projects from professional releases.</p><h2>UI/UX Polish</h2><p>Horror UI should be minimal but effective—never break immersion.</p><h3>Diegetic UI</h3><p>Information integrated into the game world:</p><pre><code class="language-lua">-- src/client/DiegeticUI.client.luau<br>
-- Health shown through visual effects, not bars</p><p>local Players = game:GetService(&quot;Players&quot;)<br>
local Lighting = game:GetService(&quot;Lighting&quot;)<br>
local TweenService = game:GetService(&quot;TweenService&quot;)</p><p>local player = Players.LocalPlayer</p><p>-- Vignette effect for low health<br>
local vignette = Instance.new(&quot;ImageLabel&quot;)<br>
vignette.Name = &quot;HealthVignette&quot;<br>
vignette.Size = UDim2.new(1, 0, 1, 0)<br>
vignette.Position = UDim2.new(0, 0, 0, 0)<br>
vignette.BackgroundTransparency = 1<br>
vignette.Image = &quot;rbxassetid://YOUR_VIGNETTE_IMAGE&quot;<br>
vignette.ImageColor3 = Color3.fromRGB(100, 0, 0)<br>
vignette.ImageTransparency = 1<br>
vignette.ZIndex = 100</p><p>local screenGui = Instance.new(&quot;ScreenGui&quot;)<br>
screenGui.Name = &quot;DiegeticEffects&quot;<br>
screenGui.IgnoreGuiInset = true<br>
screenGui.ResetOnSpawn = false<br>
screenGui.Parent = player.PlayerGui</p><p>vignette.Parent = screenGui</p><p>-- Color correction for damage<br>
local colorCorrection = Lighting:FindFirstChild(&quot;ColorCorrectionEffect&quot;)<br>
if not colorCorrection then<br>
    colorCorrection = Instance.new(&quot;ColorCorrectionEffect&quot;)<br>
    colorCorrection.Parent = Lighting<br>
end</p><p>local function updateHealthEffects(healthPercent)<br>
    -- Vignette intensity<br>
    local vignetteAlpha = math.clamp(1 - healthPercent, 0, 0.7)<br>
    vignette.ImageTransparency = 1 - vignetteAlpha</p><p>    -- Desaturation at low health<br>
    colorCorrection.Saturation = -0.5 * (1 - healthPercent)</p><p>    -- Pulse effect at critical health<br>
    if healthPercent &lt; 0.25 then<br>
        local pulse = TweenService:Create(vignette, TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {<br>
            ImageTransparency = 0.3<br>
        })<br>
        pulse:Play()<br>
    end<br>
end</p><p>game.ReplicatedStorage.Events.HealthChanged.OnClientEvent:Connect(function(health, maxHealth)<br>
    updateHealthEffects(health / maxHealth)<br>
end)</code></pre><h3>Screen Shake</h3><p>Camera shake for impact:</p><pre><code class="language-lua">-- src/client/ScreenShake.client.luau<br>
local RunService = game:GetService(&quot;RunService&quot;)<br>
local camera = workspace.CurrentCamera</p><p>local ScreenShake = {<br>
    shakes = {},<br>
}</p><p>function ScreenShake.add(intensity, duration, frequency)<br>
    local shake = {<br>
        intensity = intensity,<br>
        duration = duration,<br>
        frequency = frequency or 20,<br>
        startTime = tick(),<br>
    }</p><p>    table.insert(ScreenShake.shakes, shake)<br>
    return shake<br>
end</p><p>function ScreenShake.addImpact(intensity)<br>
    -- Single impact shake that decays<br>
    ScreenShake.add(intensity, 0.3, 30)<br>
end</p><p>function ScreenShake.addTrauma(amount)<br>
    -- Accumulating trauma that decays over time<br>
    ScreenShake.add(amount, 2, 15)<br>
end</p><p>RunService.RenderStepped:Connect(function(dt)<br>
    local totalOffset = Vector3.new(0, 0, 0)<br>
    local totalRotation = Vector3.new(0, 0, 0)</p><p>    for i = #ScreenShake.shakes, 1, -1 do<br>
        local shake = ScreenShake.shakes[i]<br>
        local elapsed = tick() - shake.startTime</p><p>        if elapsed &gt;= shake.duration then<br>
            table.remove(ScreenShake.shakes, i)<br>
        else<br>
            -- Calculate decay<br>
            local decay = 1 - (elapsed / shake.duration)<br>
            local intensity = shake.intensity * decay</p><p>            -- Perlin noise for smooth shake<br>
            local time = tick() * shake.frequency<br>
            local offsetX = (math.noise(time, 0) <em> 2 - 1) </em> intensity<br>
            local offsetY = (math.noise(0, time) <em> 2 - 1) </em> intensity<br>
            local rotationZ = (math.noise(time, time) <em> 2 - 1) </em> intensity * 0.5</p><p>            totalOffset = totalOffset + Vector3.new(offsetX, offsetY, 0)<br>
            totalRotation = totalRotation + Vector3.new(0, 0, rotationZ)<br>
        end<br>
    end</p><p>    -- Apply to camera<br>
    if totalOffset.Magnitude &gt; 0 then<br>
        camera.CFrame = camera.CFrame <em> CFrame.new(totalOffset) </em> CFrame.Angles(<br>
            math.rad(totalRotation.X),<br>
            math.rad(totalRotation.Y),<br>
            math.rad(totalRotation.Z)<br>
        )<br>
    end<br>
end)</p><p>return ScreenShake</code></pre><h3>Horror-Appropriate Fonts</h3><pre><code class="language-lua">-- Avoid playful fonts. Use:<br>
-- Enum.Font.SourceSans (clean, neutral)<br>
-- Enum.Font.SourceSansBold (emphasis)<br>
-- Enum.Font.Code (terminals, logs)<br>
-- Enum.Font.Highway (signs, warnings)</p><p>local function createHorrorText(text, parent)<br>
    local label = Instance.new(&quot;TextLabel&quot;)<br>
    label.Font = Enum.Font.SourceSans<br>
    label.TextColor3 = Color3.fromRGB(200, 200, 200)  -- Slightly off-white<br>
    label.TextSize = 18<br>
    label.BackgroundTransparency = 1<br>
    label.Text = text<br>
    label.Parent = parent<br>
    return label<br>
end</code></pre><h2>Sound Polish</h2><p>Sound sells horror. Every interaction needs audio feedback.</p><h3>Footstep System</h3><p>Different surfaces, different sounds:</p><pre><code class="language-lua">-- src/client/Footsteps.client.luau<br>
local Players = game:GetService(&quot;Players&quot;)<br>
local SoundService = game:GetService(&quot;SoundService&quot;)<br>
local RunService = game:GetService(&quot;RunService&quot;)</p><p>local player = Players.LocalPlayer</p><p>local FOOTSTEP_SOUNDS = {<br>
    Concrete = { &quot;rbxassetid://CONCRETE_1&quot;, &quot;rbxassetid://CONCRETE_2&quot; },<br>
    Metal = { &quot;rbxassetid://METAL_1&quot;, &quot;rbxassetid://METAL_2&quot; },<br>
    Wood = { &quot;rbxassetid://WOOD_1&quot;, &quot;rbxassetid://WOOD_2&quot; },<br>
    Grass = { &quot;rbxassetid://GRASS_1&quot;, &quot;rbxassetid://GRASS_2&quot; },<br>
    Water = { &quot;rbxassetid://SPLASH_1&quot;, &quot;rbxassetid://SPLASH_2&quot; },<br>
}</p><p>local lastStep = 0<br>
local stepInterval = 0.4</p><p>local function getMaterialUnderFoot()<br>
    local character = player.Character<br>
    if not character then return &quot;Concrete&quot; end</p><p>    local rootPart = character:FindFirstChild(&quot;HumanoidRootPart&quot;)<br>
    if not rootPart then return &quot;Concrete&quot; end</p><p>    local rayResult = workspace:Raycast(<br>
        rootPart.Position,<br>
        Vector3.new(0, -5, 0)<br>
    )</p><p>    if rayResult then<br>
        local material = rayResult.Material.Name</p><p>        -- Map Roblox materials to our sound categories<br>
        if material == &quot;Metal&quot; or material == &quot;DiamondPlate&quot; then<br>
            return &quot;Metal&quot;<br>
        elseif material == &quot;Wood&quot; or material == &quot;WoodPlanks&quot; then<br>
            return &quot;Wood&quot;<br>
        elseif material == &quot;Grass&quot; or material == &quot;LeafyGrass&quot; then<br>
            return &quot;Grass&quot;<br>
        elseif material == &quot;Water&quot; then<br>
            return &quot;Water&quot;<br>
        end<br>
    end</p><p>    return &quot;Concrete&quot;<br>
end</p><p>local function playFootstep()<br>
    local material = getMaterialUnderFoot()<br>
    local sounds = FOOTSTEP_SOUNDS[material] or FOOTSTEP_SOUNDS.Concrete</p><p>    local soundId = sounds[math.random(#sounds)]</p><p>    local sound = Instance.new(&quot;Sound&quot;)<br>
    sound.SoundId = soundId<br>
    sound.Volume = 0.3<br>
    sound.PlaybackSpeed = 0.9 + math.random() * 0.2  -- Slight variation<br>
    sound.Parent = player.Character.HumanoidRootPart<br>
    sound:Play()<br>
    sound.Ended:Connect(function() sound:Destroy() end)<br>
end</p><p>RunService.Heartbeat:Connect(function()<br>
    local character = player.Character<br>
    if not character then return end</p><p>    local humanoid = character:FindFirstChildOfClass(&quot;Humanoid&quot;)<br>
    if not humanoid then return end</p><p>    local isMoving = humanoid.MoveDirection.Magnitude &gt; 0.1<br>
    local isRunning = humanoid.WalkSpeed &gt; 16</p><p>    if isMoving then<br>
        stepInterval = isRunning and 0.3 or 0.5</p><p>        if tick() - lastStep &gt;= stepInterval then<br>
            playFootstep()<br>
            lastStep = tick()<br>
        end<br>
    end<br>
end)</code></pre><h3>Ambient Sound Layers</h3><pre><code class="language-lua">-- src/client/AmbientSounds.client.luau<br>
local function createAmbientLayer(name, soundId, volume, pitch)<br>
    local sound = Instance.new(&quot;Sound&quot;)<br>
    sound.Name = name<br>
    sound.SoundId = soundId<br>
    sound.Volume = volume or 0.3<br>
    sound.PlaybackSpeed = pitch or 1<br>
    sound.Looped = true<br>
    sound.Parent = game.SoundService<br>
    sound:Play()<br>
    return sound<br>
end</p><p>-- Base layers (always playing)<br>
createAmbientLayer(&quot;BaseDrone&quot;, &quot;rbxassetid://YOUR_DRONE&quot;, 0.2)<br>
createAmbientLayer(&quot;Wind&quot;, &quot;rbxassetid://YOUR_WIND&quot;, 0.15)</p><p>-- Tension layers (fade in based on threat)<br>
local tensionLayer = createAmbientLayer(&quot;Tension&quot;, &quot;rbxassetid://YOUR_TENSION&quot;, 0)<br>
local heartbeatLayer = createAmbientLayer(&quot;Heartbeat&quot;, &quot;rbxassetid://YOUR_HEARTBEAT&quot;, 0)</p><p>local function updateTensionAudio(threatLevel)<br>
    tensionLayer.Volume = threatLevel * 0.4<br>
    heartbeatLayer.Volume = math.max(0, threatLevel - 0.5) * 0.6<br>
    heartbeatLayer.PlaybackSpeed = 0.8 + threatLevel * 0.4<br>
end</p><p>game.ReplicatedStorage.Events.ThreatLevelChanged.OnClientEvent:Connect(updateTensionAudio)</code></pre><h2>Performance Optimization</h2><p>Horror games need consistent frame rates—stuttering breaks immersion.</p><h3>Instance Streaming</h3><p>For large maps:</p><pre><code class="language-lua">-- In default.project.json or via Studio<br>
-- Enable StreamingEnabled in Workspace properties</p><p>-- Server-side streaming configuration<br>
workspace.StreamingEnabled = true<br>
workspace.StreamingMinRadius = 64   -- Minimum loaded radius<br>
workspace.StreamingTargetRadius = 256  -- Target loaded radius<br>
workspace.StreamingPauseMode = Enum.StreamingPauseMode.ClientPhysicsPause</code></pre><h3>LOD (Level of Detail)</h3><pre><code class="language-lua">-- src/server/LODManager.server.luau<br>
local Players = game:GetService(&quot;Players&quot;)<br>
local RunService = game:GetService(&quot;RunService&quot;)</p><p>local LOD_DISTANCES = {<br>
    high = 50,<br>
    medium = 100,<br>
    low = 200,<br>
}</p><p>local function updateLOD(part, distance)<br>
    if distance &lt; LOD_DISTANCES.high then<br>
        -- Full detail<br>
        part.Material = part:GetAttribute(&quot;OriginalMaterial&quot;) or part.Material<br>
    elseif distance &lt; LOD_DISTANCES.medium then<br>
        -- Medium detail<br>
        part.Material = Enum.Material.SmoothPlastic<br>
    else<br>
        -- Low detail<br>
        part.Material = Enum.Material.SmoothPlastic<br>
        -- Could also swap models here<br>
    end<br>
end</p><p>-- Tag parts with &quot;LODEnabled&quot; to optimize them<br>
local CollectionService = game:GetService(&quot;CollectionService&quot;)</p><p>RunService.Heartbeat:Connect(function()<br>
    for _, player in ipairs(Players:GetPlayers()) do<br>
        local character = player.Character<br>
        if not character then continue end</p><p>        local rootPart = character:FindFirstChild(&quot;HumanoidRootPart&quot;)<br>
        if not rootPart then continue end</p><p>        for _, part in ipairs(CollectionService:GetTagged(&quot;LODEnabled&quot;)) do<br>
            local distance = (part.Position - rootPart.Position).Magnitude<br>
            updateLOD(part, distance)<br>
        end<br>
    end<br>
end)</code></pre><h3>Efficient Raycasting</h3><pre><code class="language-lua">-- Bad: Creating new RaycastParams every frame<br>
local function badRaycast()<br>
    local params = RaycastParams.new()  -- Allocates every call<br>
    params.FilterType = Enum.RaycastFilterType.Exclude<br>
    params.FilterDescendantsInstances = {player.Character}<br>
    return workspace:Raycast(origin, direction, params)<br>
end</p><p>-- Good: Reuse RaycastParams<br>
local cachedParams = RaycastParams.new()<br>
cachedParams.FilterType = Enum.RaycastFilterType.Exclude</p><p>local function goodRaycast(origin, direction, ignoreList)<br>
    cachedParams.FilterDescendantsInstances = ignoreList<br>
    return workspace:Raycast(origin, direction, cachedParams)<br>
end</code></pre><h2>Testing Checklist</h2><p>Before publishing, verify:</p><h3>Gameplay</h3><br>
- [ ] Tutorial/onboarding works<br>
- [ ] All objectives completable<br>
- [ ] Creature AI behaves correctly<br>
- [ ] Hiding spots function<br>
- [ ] Items spawn and can be picked up<br>
- [ ] Doors open/close/lock correctly<br>
- [ ] Multiplayer sync works<br>
- [ ] Revival system functions<br>
- [ ] Death and respawn work</p><h3>Technical</h3><br>
- [ ] No script errors in output<br>
- [ ] Frame rate stable (60+ FPS on mid-range devices)<br>
- [ ] Memory usage reasonable<br>
- [ ] Loading time acceptable<br>
- [ ] Mobile controls work (if supported)</p><h3>Audio</h3><br>
- [ ] All sounds play<br>
- [ ] Volume levels balanced<br>
- [ ] No audio clipping<br>
- [ ] Ambient sounds loop seamlessly</p><h3>Visual</h3><br>
- [ ] Lighting looks correct<br>
- [ ] No z-fighting or visual glitches<br>
- [ ] UI readable at all resolutions<br>
- [ ] Effects don't obscure gameplay</p><h2>Publishing to Roblox</h2><h3>Game Settings</h3><p>Configure in Game Settings:</p><pre><code class="language-">Basic Info:<br>
- Name: Your game name<br>
- Description: Hook + what the game is + call to action<br>
- Genre: Horror (important for discovery)<br>
- Playable Devices: Desktop, Phone, Tablet, Console</p><p>Permissions:<br>
- Who Can Play: Public (when ready)<br>
- Voice Chat: Consider for immersion</p><p>Monetization:<br>
- Enable Private Servers (good for horror co-op)<br>
- Consider Game Passes for cosmetics</code></pre><h3>Description Template</h3><pre><code class="language-">[HOOK] Can you survive the night?</p><p>[WHAT IT IS]<br>
A survival horror experience for 1-4 players. Explore the abandoned facility,<br>
gather supplies, and escape before IT finds you.</p><p>[FEATURES]<br>
- Intelligent creature AI that hunts by sight and sound<br>
- Resource management (flashlight batteries, health items)<br>
- Cooperative multiplayer with revival system<br>
- Multiple objectives and endings</p><p>[CONTROLS]<br>
WASD - Move<br>
Shift - Run<br>
F - Flashlight<br>
E - Interact<br>
Tab - Inventory</p><p>[UPDATES]<br>
v1.0 - Initial release</p><p>[CREDITS]<br>
Created with Rojo + Claude Code</code></pre><h3>Thumbnails and Icons</h3><p>Horror thumbnails should:<br>
- Show atmosphere (dark, foggy, mysterious)<br>
- Hint at threat without revealing everything<br>
- Use contrasting colors for visibility<br>
- Include game title clearly</p><pre><code class="language-lua">-- Thumbnail dimensions: 1920x1080 (16:9)<br>
-- Icon dimensions: 512x512</p><p>-- Take screenshots in-game using Studio's built-in tools<br>
-- Or create promotional art separately</code></pre><h3>Marketing</h3><p>1. <strong>Before launch</strong>: Build anticipation on Roblox groups, Discord<br>
2. <strong>Launch day</strong>: Post everywhere, ask friends to play<br>
3. <strong>Post-launch</strong>: Respond to feedback, update regularly</p><h2>Monetization Ethics</h2><p>Horror games can monetize without being predatory:</p><p><strong>Good monetization:</strong><br>
- Cosmetic items (character skins, effects)<br>
- Private servers for friends<br>
- DLC content (new maps, creatures)<br>
- One-time game passes</p><p><strong>Avoid:</strong><br>
- Pay-to-win (buying survival items)<br>
- Loot boxes with random rewards<br>
- Energy systems that limit play<br>
- Paywalled core features</p><h2>Post-Launch</h2><p>Publishing is the beginning, not the end:</p><h3>Analytics</h3><p>Track what matters:<br>
- Play time per session<br>
- Where players quit<br>
- Which objectives cause issues<br>
- Multiplayer vs solo preference</p><h3>Updates</h3><p>Regular updates keep players coming back:<br>
- Bug fixes (priority one)<br>
- Balance adjustments<br>
- New content (maps, items, creatures)<br>
- Community-requested features</p><h3>Community</h3><p>Build a community around your game:<br>
- Roblox group for announcements<br>
- Discord for feedback<br>
- Respond to comments and reviews</p><h2>Vibe Coding Polish</h2><p>When polishing with AI:</p><p>> "Add screen shake when the player takes damage, with intensity based on damage amount"</p><p>> "Create a footstep system that plays different sounds based on floor material"</p><p>> "Implement a vignette effect that intensifies as player health decreases"</p><p>> "Add ambient sound layers that crossfade based on threat level"</p><p>Polish is iterative. Let AI generate the systems, then tune until it feels right.</p><h2>Final Thoughts</h2><p>You've built a survival horror game. From project setup to creature AI, from atmospheric lighting to multiplayer systems, from UI polish to publishing—every piece is in place.</p><p>But the systems aren't the game. The <em>experience</em> is the game. Your creature isn't scary because it has pathfinding—it's scary because you tuned when it appears, how it moves, what sounds it makes.</p><p>Keep iterating. Keep playtesting. Keep asking: "Is this scary?"</p><p>When the answer is yes, you've made something special.</p><p>Now go terrify some players.<br>
</p>
    </section>
  
    </main>

    <footer>
      <p>Generated with <a href="https://claude.ai/code">Claude Code</a> | <a href="https://github.com/bedwards/metavibe">View source</a></p>
    </footer>
  </div>
</body>
</html>