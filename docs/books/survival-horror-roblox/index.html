<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>How to Vibe Code a Survival Horror Game in Roblox | metavibe</title>
  <meta name="description" content="A practical guide to building survival horror games in Roblox using">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #fdfcfa;
      --text: #1a1a1a;
      --text-muted: #666;
      --accent: #6366f1;
      --border: #e5e5e5;
      --code-bg: #f3f4f6;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #111;
        --text: #e5e5e5;
        --text-muted: #999;
        --border: #333;
        --code-bg: #1a1a1a;
      }
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Lexend', 'Roboto Slab', 'Rockwell', 'Courier Bold', serif;
      line-height: 1.7;
      color: var(--text);
      background: var(--bg);
    }
    .container { max-width: 720px; margin: 0 auto; padding: 2rem; }
    header { margin-bottom: 2rem; padding-bottom: 1rem; border-bottom: 1px solid var(--border); }
    h1 { font-size: 1.5rem; font-weight: 600; margin-bottom: 0.5rem; }
    .subtitle { color: var(--text-muted); font-size: 1rem; }
    .back { display: inline-block; margin-bottom: 1rem; color: var(--accent); text-decoration: none; font-size: 0.9rem; }
    .back:hover { text-decoration: underline; }
    nav { margin: 2rem 0; padding: 1.5rem; background: var(--code-bg); border-radius: 8px; }
    nav h2 { font-size: 1rem; margin-bottom: 1rem; }
    nav ul { list-style: none; padding-left: 0; }
    nav li { margin: 0.5rem 0; }
    nav a { color: var(--accent); text-decoration: none; }
    nav a:hover { text-decoration: underline; }
    .chapter { margin: 3rem 0; padding-top: 2rem; border-top: 1px solid var(--border); }
    h2 { font-size: 1.25rem; font-weight: 600; margin: 2rem 0 1rem; }
    h3 { font-size: 1.1rem; font-weight: 600; margin: 1.5rem 0 0.75rem; }
    p { margin: 1rem 0; }
    a { color: var(--accent); }
    code { font-family: 'SF Mono', Monaco, monospace; font-size: 0.9em; background: var(--code-bg); padding: 0.2em 0.4em; border-radius: 3px; }
    pre { background: var(--code-bg); padding: 1rem; border-radius: 6px; overflow-x: auto; margin: 1rem 0; }
    pre code { background: none; padding: 0; font-size: 0.85em; }
    strong { font-weight: 600; }
    ul, ol { margin: 1rem 0; padding-left: 1.5rem; }
    li { margin: 0.5rem 0; }
    footer { margin-top: 4rem; padding-top: 2rem; border-top: 1px solid var(--border); text-align: center; color: var(--text-muted); font-size: 0.9rem; font-family: sans-serif; }
  </style>
</head>
<body>
  <div class="container">
    <a href="../../" class="back">← Back to all books</a>
    <header>
      <h1>How to Vibe Code a Survival Horror Game in Roblox</h1>
      <p class="subtitle">Building atmospheric horror experiences with AI-assisted Luau development</p>
    </header>

    <nav>
      <h2>Table of Contents</h2>
      <ul>
        <li><a href="#chapter-0">Introduction</a></li>
<li><a href="#chapter-1">Project Setup with Rojo</a></li>
<li><a href="#chapter-2">Creating Atmosphere</a></li>
<li><a href="#chapter-3">Creature AI and Threats</a></li>
<li><a href="#chapter-4">Survival Mechanics</a></li>
<li><a href="#chapter-5">Environment and Level Design</a></li>
<li><a href="#chapter-6">Multiplayer Systems</a></li>
<li><a href="#chapter-7">Polish and Publishing</a></li>
      </ul>
    </nav>

    <main>
      
    <section id="chapter-0" class="chapter">
      <h2>Introduction</h2>
      <p>Something strange happens when you sit down to make a horror game. The act of constructing fear requires you to understand it intimately, to dissect the mechanisms that make your own heart race, and then reassemble them into something that will unsettle strangers you'll never meet. It's an odd kind of empathy.</p><p>For decades, horror game development belonged to well-funded studios with artists who could craft photorealistic decay and programmers who spent months tweaking AI patrol routes. Indie developers carved out niches with clever constraints—found footage aesthetics, lo-fi graphics that turned limitation into style. But the barrier remained high. Creating genuine dread demanded either significant resources or years of accumulated craft.</p><p>Roblox changed something fundamental about this equation, though not in the way you might expect.</p><p>The platform emerged as a space for younger players, bright colors and simple avatars populating blocky worlds. Horror seemed antithetical to its DNA. Yet some of the most genuinely unsettling experiences in gaming now live on Roblox. Games like Doors, Apeirophobia, and The Mimic have attracted hundreds of millions of plays. Players who grew up on Minecraft discovered that simplicity doesn't preclude terror—sometimes it amplifies it.</p><p>The Roblox horror renaissance happened because the platform solved distribution. When your potential audience numbers in the hundreds of millions, you can find the players who crave what you're building. The tooling caught up too. Luau, Roblox's typed variant of Lua, offers enough expressiveness for sophisticated systems. The physics engine handles spatial audio and dynamic lighting. Server infrastructure comes free.</p><p>What remained difficult was the coding itself.</p><p>Luau scripting demands understanding Roblox's particular architecture—the client-server split, the replication model, the service-based organization. Traditional learning meant reading documentation, copying examples, debugging endlessly when examples didn't quite fit your needs. The Roblox developer forum overflows with posts from frustrated beginners who can't quite make the pathfinding system cooperate or whose remote events fire in the wrong order.</p><p>Then vibe coding arrived.</p><p>The term came from Andrej Karpathy in early 2025, describing a style of development where you describe what you want in natural language and let AI generate the implementation. You focus on vision and judgment. The AI handles syntax and boilerplate. Karpathy's phrase was deliberately casual—"fully give in to the vibes"—but the implications were profound for anyone trying to build complex interactive experiences.</p><p>Vibe coding doesn't eliminate the need to understand what you're building. It eliminates the friction between understanding and implementation. When you know you want a creature that patrols a corridor and investigates sounds, you can describe that intent directly. The AI knows Roblox's pathfinding APIs. It knows how to structure a behavior state machine. It knows the replication patterns that keep server and client synchronized. You don't need to remember which service handles humanoid movement or whether SimplePath requires a specific configuration.</p><p>What surprised us most, building horror games this way, was how it changed the creative process itself.</p><p>Traditional development involves long cycles. You implement a feature, playtest it, realize it doesn't create the feeling you imagined, revise the implementation, playtest again. Each cycle takes time. By the fifth revision, you've lost some connection to the original vision. You're debugging code, not crafting fear.</p><p>Vibe coding compresses these cycles dramatically. You describe what you want. You see it running within minutes. If it doesn't feel right, you describe what needs to change. The conversation stays at the level of intent and effect rather than dropping into implementation details. You remain in the creative headspace longer.</p><p>This matters enormously for horror.</p><p>Fear is delicate. It depends on timing, on the precise delay before a door creaks open, on the exact volume at which distant footsteps register as threatening rather than ambient. Horror game designers have long known that these calibrations require rapid iteration. When each iteration costs an afternoon of debugging, you settle for "good enough." When each iteration costs a few minutes of conversation, you can chase "genuinely unsettling."</p><p>The horror game design literature emphasizes what researchers call tension flow—the careful modulation of stress and relief that keeps players engaged without overwhelming them. You can't maintain peak terror for thirty minutes straight; players either become desensitized or quit. Great horror games oscillate between dread and release, building toward crescendos and then allowing recovery.</p><p>Implementing good tension flow traditionally required extensive playtesting and careful tuning. With vibe coding, you can experiment with timing parameters conversationally. Make the creature patrol faster. Add a longer delay before it investigates sounds. Let the player hide for ten seconds before the creature loses interest. Each adjustment takes moments instead of hours.</p><p>We discovered these patterns while building survival horror mechanics across several Roblox projects. The techniques accumulated. Some were platform-specific—particular ways of structuring Roblox services, patterns for client-server communication that feel native to the engine. Others were general vibe coding approaches that happen to work beautifully for game development.</p><p>This book captures what we learned.</p><p>We're not going to walk through building a specific game step by step. That approach produces tutorials that feel dated within months as platforms evolve and AI capabilities expand. Instead, we focus on techniques—ways of thinking about horror game development, ways of communicating with AI assistants, ways of structuring projects that remain productive as scope grows.</p><p>You'll learn how to create atmosphere without drowning in lighting calculations. How to build creature AI that feels threatening without being unfair. How to implement survival mechanics that create tension rather than tedium. How to design environments that guide players toward fear. How to handle the particular challenges of multiplayer horror, where other humans introduce chaos into your carefully crafted scares.</p><p>Throughout, we'll share discoveries from actual vibe coding sessions. The prompts that worked. The approaches that failed and why. The moments when AI assistance surprised us with solutions we hadn't considered.</p><p>Horror games trade in uncertainty. The player never quite knows what lurks around the next corner. There's a parallel uncertainty in vibe coding—you're never quite sure what the AI will produce until you see it running. Learning to work productively with that uncertainty, to guide it toward your vision without trying to control every detail, is the core skill this book teaches.</p><p>Before we continue, a word on what this book assumes.</p><p>You don't need to be a Luau expert. Basic programming concepts—variables, functions, loops, conditionals—transfer from any language. The AI will handle Roblox-specific syntax. But you do need Roblox Studio installed and a willingness to experiment. Horror game development rewards the curious and punishes the timid.</p><p>You'll want an AI coding assistant. This book assumes Claude Code, but the techniques translate to Cursor, Copilot, or similar tools. The specific prompts matter less than the patterns of communication.</p><p>And you'll need a tolerance for imperfection. Vibe coding produces working code quickly. It doesn't produce perfect code. You'll ship games with rough edges, then improve them based on player feedback. This iterative approach feels uncomfortable if you're accustomed to polishing before release. It's also how the most successful Roblox horror games actually get built—the developers behind Doors have shipped hundreds of updates since launch, each responding to player behavior they couldn't have predicted.</p><p>The horror genre has always attracted creators who enjoy working within constraints. Limited budgets forced Resident Evil's designers to use fixed camera angles, which became a defining aesthetic choice. The PlayStation's hardware limitations shaped Silent Hill's signature fog. Roblox imposes its own constraints—the avatar system, the blocky geometry, the young-skewing audience—and working creatively within them produces distinctive results.</p><p>Vibe coding adds a new kind of constraint, though it might not feel like one at first. When you can implement any idea quickly, you have to develop stronger taste. You have to know which ideas deserve implementation. The bottleneck shifts from execution to judgment.</p><p>This is actually wonderful news for horror game designers. Horror has always been a genre where restraint outperforms excess. The monster you glimpse briefly terrifies more than the monster you see clearly. The sound you can't identify unsettles more than the obvious crash. Vibe coding lets you execute at the pace of your ideas, which means you can try the restrained approach, see how it feels, and adjust—rather than implementing the obvious solution because the elegant one seemed too expensive.</p><p>The next chapter covers project setup—the tooling and structure that makes vibe coding productive. We'll install Rojo, configure the development environment, and establish patterns that scale as your game grows.</p><p>But first, close your eyes for a moment. Picture the horror game you want to make. The corridors. The shadows. The thing that hunts. Hold that vision clearly.</p><p>Now let's build it.<br>
</p>
    </section>
  

    <section id="chapter-1" class="chapter">
      <h2>Project Setup with Rojo</h2>
      <p>Before the first creature stalks its first corridor, before the fog rolls in and the lights flicker, you need infrastructure. Not the exciting kind—no jump scares here, just the scaffolding that makes everything else possible. This chapter might seem dry. Bear with it. The decisions you make in project setup compound throughout development.</p><p>Roblox Studio works fine for small projects. You click around, create scripts directly in the editor, test by hitting play. Many successful games started this way. But as complexity grows, Studio's limitations emerge. The built-in script editor lacks modern features. There's no version control integration. Collaboration means passing place files around or using Roblox's team create, which has its own quirks.</p><p>Most critically for vibe coding: AI assistants can't see inside Roblox Studio. They work with files on your filesystem. If your code lives only in Studio, you're copying and pasting constantly, losing context, fragmenting the conversation.</p><p>This is where Rojo enters the picture.</p><p>Rojo bridges the gap between your filesystem and Roblox Studio. Scripts live as plain text files—Luau code with the extension that signals their purpose. A server script ends in server.luau. A client script ends in client.luau. Shared modules end simply in luau. You edit these files in whatever environment you prefer, and Rojo synchronizes changes into Studio in real time.</p><p>The practical implication is profound. Your horror game becomes a folder of text files. You can track changes with Git. You can review code in pull requests. Multiple developers can work simultaneously. And your AI assistant can read and modify any script by working with the files directly.</p><p>Installing Rojo takes a few minutes. The Roblox developer community has converged on Aftman as the standard tool manager—think of it as npm or cargo for Roblox tooling. One configuration file lists the tools you need, and Aftman ensures the correct versions are installed. You'll want Rojo for synchronization, Wally for package management if you use external libraries, Selene for linting, and StyLua for consistent formatting.</p><p>When we first set up a Roblox project for vibe coding, we discovered something unexpected about how to communicate with AI assistants about structure.</p><p>The naive approach—"create a project structure for a horror game"—produces generic results. The AI generates something functional but without opinion. You get folders named src and assets with placeholder content.</p><p>The better approach describes intent alongside structure. "I need client-server separation where the server handles creature AI and game state while the client handles player input and UI. Shared modules should define constants that both sides reference." This prompt conveys not just what you want but why, which helps the AI make better decisions about what goes where.</p><p>We found an even better approach: describe a specific scenario and let the AI infer structure from behavior. "When a player makes noise, the server should evaluate whether any creatures can detect it. If so, the creature's behavior state should change, and the client should receive updates about the creature's new position. What project structure supports this cleanly?"</p><p>This kind of prompt treats the AI as a collaborator rather than a code generator. You're thinking together about architecture. The resulting structure reflects actual gameplay needs rather than generic best practices.</p><p>The core architectural pattern in Roblox deserves understanding even if AI handles the details.</p><p>Server scripts run on Roblox's infrastructure. They have authority over game state. When the server says a creature is at a particular position, that's where the creature is. Clients can request actions, but the server decides whether those actions succeed. This matters for horror games because you need to control what players see. If a creature lurks behind a door, only the server knows this. The client receives information when appropriate—when the door opens, when the creature enters detection range.</p><p>Client scripts run on each player's device. They handle input and rendering. When a player presses a key, the client script processes that input and may send a request to the server. The client also renders the game world, plays sounds, and displays UI. For horror, client scripts manage the moment-to-moment experience—the creaking sound when you walk past a certain spot, the slight camera shake during tense sequences, the darkness effect when your flashlight battery dies.</p><p>Shared modules contain code that both server and client need. Type definitions, constants, utility functions. In a horror game, these might include configuration values for creature detection ranges, stamina drain rates, lighting parameters. Having these in one place means consistency—when you adjust a value, both sides see the change.</p><p>The structure we settled on through iteration separates concerns cleanly. Server scripts handle game logic, creature behavior, and state management. Client scripts handle input processing, UI rendering, and local effects. Shared modules define the constants and types that keep everything coherent.</p><p>What about assets? Models, sounds, textures—the visual and auditory elements that make horror visceral. Rojo can sync these too, but we found it more practical to manage them directly in Studio. The large binary files don't version control gracefully. More importantly, placing and adjusting assets benefits from Studio's visual tools. The code-based workflow excels for logic; Studio excels for spatial design.</p><p>One discovery surprised us repeatedly: vibe coding thrives when you establish conventions early.</p><p>In traditional development, conventions emerge organically. You write code, notice patterns, refactor toward consistency over time. With vibe coding, the AI generates code rapidly. Without clear conventions, each generation might follow different patterns. Your codebase becomes a patchwork.</p><p>The solution is to establish conventions explicitly at the start. Not through documentation—through code. Write one example of how server scripts should initialize. Write one example of client-side event handling. Then tell the AI: "Follow the patterns established in the existing code." The AI reads those examples and extends them consistently.</p><p>For our horror project, the initialization pattern became a touchstone. Every server script starts by importing required services, then establishes any listeners, then performs any startup logic. Every client script starts by acquiring references to player elements, then sets up input handlers, then initializes any local state. The AI maintained these patterns once established, producing code that felt cohesive rather than generated.</p><p>Git integration deserves mention, though it's not Roblox-specific.</p><p>Version control transforms how you work with AI assistants. Every change becomes reversible. You can try an experimental approach, see if it works, and easily revert if it doesn't. This safety net encourages bolder experimentation. When the AI suggests a significant refactor, you can accept it without fear—if something breaks, the previous state is always recoverable.</p><p>We developed a rhythm: make a logical change, test it, commit if it works. Small, frequent commits rather than large batches. Each commit message describes what changed and why, creating a narrative of development. Later, when something breaks, this history helps diagnose what went wrong.</p><p>The combination of Rojo, Git, and AI assistance creates something greater than its parts. Files live on your filesystem where AI can access them. Changes sync instantly to Studio where you can test. Git tracks everything, enabling bold experimentation. The cycle from idea to implementation to testing to iteration becomes remarkably fast.</p><p>This matters for horror games specifically because atmosphere requires tuning. The right fog density, the precise distance at which footsteps become audible, the exact speed at which a creature patrols—these values need adjustment based on feel rather than specification. When adjustment is cheap, you can tune toward genuine creepiness rather than settling for approximately scary.</p><p>Before we move on, let's address something the tooling doesn't solve: taste.</p><p>No project structure makes your game fun. No AI assistant understands what frightens your specific audience. The infrastructure we've discussed enables rapid iteration, but iteration toward what? You need a vision. You need to play horror games and notice what works. You need to understand why certain sounds unsettle and others don't register.</p><p>The tooling amplifies your judgment. If your judgment is good, vibe coding lets you manifest it quickly. If your judgment is undeveloped, you'll produce mediocre work faster. This book focuses on techniques, but techniques serve vision. Cultivate your sense of what makes horror work, and the techniques will serve you well.</p><p>The next chapter dives into atmosphere—lighting, sound, environmental design. These are the elements that transform a Roblox place from a collection of parts into a space that generates dread. The project structure we've established here provides the foundation; now we build something worth being afraid of.<br>
</p>
    </section>
  

    <section id="chapter-2" class="chapter">
      <h2>Creating Atmosphere</h2>
      <p>A dark room is just a dark room. We've all sat in darkness—waiting for our eyes to adjust, reaching for a light switch, feeling mildly inconvenienced. Darkness itself holds no fear. What terrifies us is uncertainty within darkness. The shape that might be a coat rack. The sound that might be breathing.</p><p>Horror game designers have known this for decades, but the knowledge often lived as intuition rather than technique. The developers behind Silent Hill discovered through experimentation that fog created more tension than clear sightlines. Resident Evil's fixed camera angles emerged partly from technical limitations but remained because the restricted view generated anxiety. These discoveries accumulated as craft, passed down through years of playtesting and refinement.</p><p>Vibe coding compresses this learning curve dramatically, but only if you understand what you're actually trying to achieve. Asking an AI to "make the lighting scary" produces generic results. Asking it to "reduce visibility in a way that creates uncertainty about what's ahead while still letting players navigate" produces something you can work with.</p><p>This chapter explores how to think about atmosphere and how to communicate that thinking to AI assistants.</p><p>Lighting in horror games serves emotional control, not visibility. This distinction matters. When you adjust brightness or fog density, you're not solving a visibility problem—you're modulating anxiety. The question isn't "can players see?" but "what do players feel about what they can and can't see?"</p><p>Researchers who study horror games describe something called tension flow—the rhythm of stress and relief that keeps players engaged. Pure constant darkness exhausts players; they either become desensitized or quit. The most effective horror oscillates. Safe areas let players recover. Dangerous areas compress. The transition between them creates its own anticipation.</p><p>In Roblox, the Lighting service provides your primary tools. Ambient light affects everything. Fog limits how far players can see. Color correction shifts the emotional temperature—desaturated blues read as cold and clinical, warm ambers suggest decay and age. Bloom makes light sources pop against darkness.</p><p>What we discovered through vibe coding was how to iterate on these parameters conversationally.</p><p>The traditional approach involves setting values, running the game, squinting at the screen, adjusting values, repeating. With AI assistance, you can describe the feeling you want and let the AI translate that into parameter adjustments. "The fog feels too dense—I want players to glimpse shapes in the distance but not identify them clearly. They should wonder if something moved." The AI adjusts fog density and perhaps suggests adding subtle ambient particles that create movement at the edge of visibility.</p><p>This conversational iteration matters because atmosphere is subjective. There's no objectively correct fog density. The right value depends on your level design, your creature behavior, your intended pace. By staying in conversation—describing feelings, receiving adjustments, reacting to results—you explore the parameter space efficiently.</p><p>Dynamic lighting extends this further. Static darkness becomes predictable. Players learn that the dark corner is always dark, and they stop feeling uncertain about it. But lighting that changes—that responds to game state, that flickers when danger approaches, that shifts as the creature draws near—maintains uncertainty even in familiar spaces.</p><p>The technique we found most effective was tying lighting to what we called threat level—an internal number from zero to one representing current danger. At zero, fog retreats, brightness increases slightly, ambient sounds calm. At one, fog thickens, darkness deepens, sound grows tense. The transitions happen gradually enough that players don't consciously notice the change but feel increasing discomfort.</p><p>Implementing this with AI assistance involves describing the relationship rather than the implementation. "Create a system where the lighting responds to a threat level variable. As threat increases from zero to one, visibility should decrease and the atmosphere should feel more oppressive." The AI handles the math—tweening between parameter values, ensuring smooth transitions, managing the technical details of Roblox's lighting system.</p><p>Sound deserves equal attention, though it's often neglected in amateur horror games.</p><p>The horror game design community has a saying: visuals tell you what's there; sound tells you what might be there. This asymmetry is crucial. You can see only what's in your field of view, but you can hear things behind you, around corners, through walls. Sound creates awareness of space beyond the visible.</p><p>Effective horror sound design uses layers. The base layer provides constant low ambience—wind, distant machinery, electrical hum. This layer establishes place and prevents absolute silence, which players find artificial rather than scary. Above this, environmental sounds add specificity—dripping water in this corridor, creaking wood in that room. These sounds anchor players in the physical space.</p><p>The dynamic layers create tension. When danger approaches, the base ambience might gain a subtle heartbeat undertone. A creature nearby might trigger quiet footsteps from off-screen. Stingers—sharp, sudden sounds—punctuate moments of revelation or attack.</p><p>Roblox handles positional audio well, and this matters enormously for horror. A sound that exists in 3D space attenuates with distance and shifts between speakers as the player moves. Hearing footsteps grow louder from behind creates immediate physiological response—the urge to turn, to run.</p><p>When vibe coding sound systems, we found that describing the emotional journey worked better than describing technical implementation. "I want players to hear the creature before they see it. The sounds should give directional information but remain ambiguous—is it ahead or behind? how far? The uncertainty should persist until visual contact." This prompt generates spatial audio configuration with roll-off settings that maintain ambiguity at medium distances.</p><p>Environmental storytelling completes the atmospheric picture.</p><p>Great horror games don't just place players in scary environments—they suggest history. Something happened here. The evidence surrounds you. Bloodstains on walls. Abandoned equipment. Doors torn from hinges. Notes that reveal fragments of a larger story.</p><p>This technique serves multiple purposes. It provides context that makes the horror meaningful—you're not just in danger, you're in a place where something terrible already occurred. It rewards exploration, giving players reasons to examine their surroundings rather than rushing through. And it builds anticipation—if these terrible things happened to others, they might happen to you.</p><p>Implementing environmental storytelling requires thinking about your world's history. What occurred before the player arrived? Who lived or worked here? What went wrong? You don't need elaborate answers, but you need consistent implications. A research facility suggests scientific hubris. An abandoned asylum suggests institutional horror. A family home suggests intimate tragedy.</p><p>With AI assistance, you can generate discoverable content rapidly. "Write a series of researcher's logs that hint at escalating danger without revealing the creature directly. The tone should shift from professional curiosity to growing fear to final desperation." The AI produces text that you can revise and place throughout your environment.</p><p>The vibe coding advantage for atmosphere lies in iteration speed.</p><p>Atmosphere requires tuning. The fog density that creates perfect tension during a chase sequence might feel oppressive during exploration. The ambient sound that establishes dread might become annoying after extended play. These calibrations require testing, adjusting, testing again.</p><p>When each adjustment requires manual code editing, you test less. You settle for values that seem okay because optimal values require more iteration than you can afford. But when adjustment means describing what's wrong and receiving fixes, you iterate freely. You discover that the fog works better at slightly different densities for different areas. You find that the ambient sound needs a brief fade during conversation sequences. You tune toward excellence rather than adequacy.</p><p>We developed a testing rhythm that worked well for atmosphere development.</p><p>First, screenshot key moments with current settings. These provide reference points—you can see whether changes improved or degraded the visual atmosphere. Second, playtest with fresh perspectives. Your own eyes adapt; someone who hasn't seen the game notices what you've become blind to. Third, test audio separately. Close your eyes and listen. Does the soundscape alone create unease? Can you orient yourself spatially from sound?</p><p>Fourth, and most importantly, test the full experience. Atmosphere works holistically. Lighting affects how sound feels. Sound affects how lighting reads. Evaluating them separately matters, but the combined effect determines success.</p><p>A word on platform constraints.</p><p>Roblox's visual capabilities continue to improve, but they remain distinct from dedicated game engines. You won't achieve photorealistic decay. The avatar system imposes a certain aesthetic. These constraints shape what kinds of horror work well on the platform.</p><p>The most successful Roblox horror games lean into abstraction rather than fighting it. Blocky geometry becomes stylized rather than primitive. Limited visual detail shifts emphasis to sound and timing. The avatar's simple face makes subtle expressions impossible, so horror relies on behavior and context rather than facial acting.</p><p>Vibe coding helps here because AI understands platform constraints. When you describe atmospheric goals, the AI generates Roblox-appropriate solutions rather than techniques that would work in Unreal but not in this engine. The conversation stays grounded in what's actually achievable.</p><p>Before moving on, let's address the deeper question: why does atmosphere matter?</p><p>Games can scare through other means. Jump scares work mechanically—sudden loud noise triggers startle reflex regardless of atmosphere. Chase sequences create tension through immediate danger. Gore disturbs through visceral imagery.</p><p>But atmospheric horror does something these techniques can't: it creates sustained dread. Players remain tense even when nothing is happening. They hesitate before opening doors not because a jump scare taught them to hesitate but because the environment has established that anything might lurk behind any door. The fear becomes self-sustaining.</p><p>This matters for game design because it transforms pacing options. With atmospheric horror, quiet moments remain tense. Exploration feels dangerous. Players engage carefully with the environment rather than rushing toward the next event. The game holds attention throughout rather than spiking during set pieces.</p><p>The techniques we've discussed—dynamic lighting, layered sound, environmental storytelling—all serve this goal. They create a place that feels threatening independent of what's currently happening. When you combine this with actual threats, the effect compounds. The creature is scary because the atmosphere already established that scary things exist here.</p><p>The next chapter introduces those threats. We'll build creature AI that stalks players through the atmospheric spaces we've created. The creature benefits from everything we've established—the limited visibility means players hear it before seeing it, the environmental details suggest its nature, the dynamic lighting responds to its approach.</p><p>Atmosphere is the foundation. Now we add what lurks within it.<br>
</p>
    </section>
  

    <section id="chapter-3" class="chapter">
      <h2>Creature AI and Threats</h2>
      <p>Every horror story needs an antagonist. In survival horror games, that antagonist typically takes physical form—something that exists in the game space, that moves through corridors you're exploring, that might be around any corner. The creature.</p><p>Building effective creature AI sits at the intersection of technical programming and psychological manipulation. You need systems that work reliably—pathfinding that doesn't break, detection that behaves consistently, state management that doesn't produce bizarre behaviors. But technical correctness is table stakes. The creature must also feel intelligent, feel threatening, feel like a genuine presence rather than a script executing.</p><p>This distinction matters for vibe coding because AI assistants can produce technically correct creature behavior almost instantly. Ask for a state machine with patrol, investigate, and chase states, and you'll get working code. The challenge lies in tuning that behavior until it creates fear rather than merely creating challenge.</p><p>The traditional game development approach to creature AI starts with what designers call a behavior tree or state machine—a formal structure describing what the creature does under various conditions. When no player is detected, patrol between waypoints. When a sound is heard, move toward the sound and search. When a player is seen, give chase. When close enough, attack.</p><p>This structure works, and AI assistants generate it easily. But pure state machines produce predictable behavior. Players quickly learn the patterns. After three encounters, they know exactly how long the creature searches before giving up, exactly how far they need to run before it loses interest. The creature becomes a puzzle to solve rather than a threat to fear.</p><p>The first technique we discovered was what we called intentional imperfection.</p><p>Real predators aren't optimally efficient. They get distracted. They miss obvious cues. They double back on paths they just traveled. These inefficiencies actually make them scarier because they're unpredictable. You can't count on the creature taking the optimal route, so any route might be the one it takes.</p><p>When communicating this to AI assistants, we found that describing the intended player experience worked better than describing implementation. Rather than "add random delays to the chase behavior," we prompted: "The creature should feel believable rather than optimal. Sometimes it should pause as if listening. Sometimes it should search areas the player already left. The player should never feel completely certain about where the creature will go next."</p><p>This prompt produces behavior variations that serve the horror goal rather than arbitrary randomness. The AI understands that uncertainty creates tension and generates appropriate variation.</p><p>Detection systems deserve careful attention because they define the core loop of gameplay.</p><p>In most horror games, players alternate between two modes: exploring when safe, avoiding when threatened. The transition between modes—the moment the creature detects you—carries enormous emotional weight. If detection feels unfair, players become frustrated. If detection feels too avoidable, tension dissipates.</p><p>We found that layered detection created the best player experience. Sight detection works as you'd expect—if the creature can see you, it knows where you are. But sight alone means safety exists anywhere out of view, which undercuts horror's fundamental uncertainty about what lurks unseen.</p><p>Sound detection adds the crucial dimension. Players making noise—running, opening doors, interacting with objects—create detection opportunities even when hidden from sight. This creates meaningful choices. You can move faster but risk detection, or move slowly and carefully but spend more time in dangerous areas.</p><p>The technical implementation of sound detection involves calculating player noise levels based on actions and checking whether those noises exceed thresholds at the creature's location. AI assistants handle this calculation easily. The design question is how generous or punishing to make the system.</p><p>We discovered that transparency helped significantly. When players understand how detection works, they feel agency over their fate. When a creature hears them, they know why—they chose to run. When detection feels random or inexplicable, horror becomes frustration.</p><p>One prompt that produced excellent results: "Create a detection system where players can intuit the rules through play. Running should clearly be louder than walking. Environmental sounds should mask player sounds when present. Give visual or audio feedback when the creature is listening or suspicious, so players can adjust their behavior."</p><p>This prompt generates detection with clarity. Players learn through experience what actions are safe and what risks detection. The horror comes from choosing to take risks, not from arbitrary punishment.</p><p>The creature's response to detection matters as much as detection itself.</p><p>Immediate chase upon any detection produces exhausting gameplay. Players spend entire sessions running, which quickly loses tension. But slow response to detection makes the creature feel stupid, which undercuts fear.</p><p>The technique we settled on uses what we called alert escalation. The creature has multiple awareness states—unaware, suspicious, alert, hunting. Detection triggers transition between states rather than immediately starting chase. A single noise makes the creature suspicious. It pauses, perhaps turns toward the sound, but doesn't immediately pursue. Continued noise or visual contact escalates to alert, where the creature actively investigates. Confirmed player detection escalates to hunting, the full chase state.</p><p>This escalation creates narrative moments. Players hear the creature pause. They freeze, hoping it didn't notice. The creature moves toward their position. They have seconds to decide—hide or flee? These moments are horror gold, and they emerge from the structure of the detection system rather than scripted sequences.</p><p>Communicating alert escalation to AI assistants requires describing the pacing intent. "The creature shouldn't immediately chase upon detecting the player. There should be a progression: first suspicion, where it pauses and looks around; then investigation, where it moves toward the last known location; then pursuit if it confirms player presence. Each stage should give players a brief window to respond."</p><p>Pathfinding presents its own challenges in horror contexts.</p><p>Roblox provides PathfindingService, which calculates routes through navigable spaces. AI assistants integrate this service readily. But raw pathfinding optimizes for shortest routes, which again creates predictability. Players learn which paths the creature never takes and feel safe there.</p><p>We experimented with what we called territorial awareness—the creature develops familiarity with its environment and preferences about where to patrol. Certain rooms feel more like "its space." Its presence there feels natural in a way that feels like hunting elsewhere. This creates geography of danger that players can learn and use strategically.</p><p>Implementation involves giving the creature preferred patrol routes and having it gravitate toward those routes between active pursuits. When searching for a lost player, it might check its familiar areas first. This produces creature behavior that feels like a presence rather than an algorithm.</p><p>The most effective horror technique we discovered was presence without pursuit.</p><p>Game designers call this the "glimpse"—the moment when players see the creature but the creature doesn't see them. Or the moment when players realize the creature is close but facing away, and they might sneak past. These moments create intense tension because they give players time to feel afraid without immediately forcing action.</p><p>Building glimpse moments requires the creature to sometimes move through spaces without detecting players who are carefully hidden or lucky. It requires the creature to occasionally stand still, letting players observe it. It requires moments where the creature is present but not hunting.</p><p>We prompted for this directly: "The creature should sometimes stand at the end of a hallway, not moving, as if waiting. It should sometimes move through an area while players hide nearby, passing without detecting them if they remain still and silent. Players should have opportunities to watch the creature without being watched back."</p><p>The AI generates behavior that includes pause states and detection thresholds that allow careful players to observe. These moments become the horror memories players share—the time they saw it standing at the end of the corridor, the time they hid under a desk while it walked past.</p><p>Balancing creature lethality requires understanding what you want death to mean.</p><p>If the creature kills instantly upon contact, encounters are binary—escape or die. This can work but creates a particular pacing where most gameplay involves avoiding encounters entirely. Doom becomes background noise because any encounter ends the same way.</p><p>If the creature damages but doesn't instantly kill, encounters become more complex. Players might fight back, might survive wounded, might make desperate decisions. Health becomes another resource to manage.</p><p>The choice depends on your horror goals. We found that for first-time players, forgiving encounters help them learn systems without constant restarts. For experienced players, punishing encounters maintain tension that familiarity otherwise erodes. Some games adjust difficulty dynamically, becoming more forgiving when players are struggling and more punishing when players are succeeding.</p><p>Vibe coding creature AI benefits from iterative conversation.</p><p>The first implementation will be functional but probably not scary. It will chase effectively but predictably. The prompts that follow tune toward fear: "The creature feels too easy to predict—what variations would make it less readable?" Or: "Players are escaping too consistently—what changes would increase catch rate without feeling unfair?" Or: "The creature never feels truly present—what behaviors would make it feel like it inhabits this space?"</p><p>These iterative prompts refine behavior toward horror rather than just functionality. Each adjustment based on playtesting brings the creature closer to genuinely threatening.</p><p>We discovered that creature AI connects to everything else we'd built. The atmosphere systems respond to creature proximity, so the lighting darkens and sounds shift when it's near—reinforcing the creature's presence before players see it. The survival mechanics create stakes for encounters—wounded players move slower, running drains stamina needed for escape. The environment provides hiding spots and escape routes that make the creature's detection meaningful.</p><p>Horror games work as integrated systems. The creature gains menace from its context. A creature that hunts through brightly lit, safe-feeling spaces seems almost silly. A creature that emerges from fog, that causes lights to flicker as it approaches, that appears suddenly in spaces you thought were safe—that creature terrifies.</p><p>The next chapter covers survival mechanics—the systems that give players agency within the horror. Health, stamina, resources. These mechanics determine what players can do when the creature appears, which determines how encounters feel. The creature matters because avoiding it matters. Survival mechanics are what make avoidance meaningful.<br>
</p>
    </section>
  

    <section id="chapter-4" class="chapter">
      <h2>Survival Mechanics</h2>
      <p>Horror without consequences is haunted house theater—startling but ultimately safe. You walk through scares knowing nothing can actually happen to you. Survival mechanics provide the consequences that transform spooky environments into genuine ordeals. When health is limited, when resources are scarce, when every decision carries risk, the emotional stakes compound.</p><p>The earliest survival horror games understood this intuitively. Resident Evil rationed ammunition so severely that players agonized over every shot. Silent Hill's radio crackled when enemies approached, creating anticipation that made encounters feel dangerous even before they began. These games succeeded not because their mechanics were complex but because those mechanics created meaningful scarcity.</p><p>Vibe coding survival mechanics presents an interesting challenge. AI assistants can generate health systems, inventory systems, and resource management instantly. The code is straightforward—variables that track values, functions that modify them, UI that displays current state. What can't be automated is the tuning that makes those systems feel right.</p><p>Too much health and players stop caring about damage. Too little and frustration overwhelms fear. The same tension applies to every resource: stamina, batteries, ammunition, healing items. The sweet spot exists where players constantly feel slightly underpowered but never hopeless.</p><p>Let's examine how each major system contributes to survival horror and how to communicate tuning goals to AI assistants.</p><p>Health in survival horror differs fundamentally from health in action games. Action game health regenerates or replenishes easily—the system exists mainly to gate players from rushing through content. Survival horror health should feel precious. Losing health should feel like a meaningful setback that persists.</p><p>This means healing should be limited. Medical supplies exist but are never abundant. Finding a first aid kit feels like relief rather than routine. Using that kit on a minor wound raises difficult questions—do you heal now when you're only slightly injured, or save the kit for a potentially worse future situation?</p><p>The technique we found most effective was what we called scarring encounters. Some damage heals fully with treatment. Other damage leaves lasting effects—reduced maximum health, slower movement, impaired vision. These lasting effects accumulate across a session, creating the sense that the environment is wearing you down even when individual encounters seem survivable.</p><p>Communicating this to AI assistants requires describing the emotional arc you want. "Health should feel meaningful. Healing items should be rare enough that players seriously consider whether to use them. Some damage types should have lasting consequences that persist even after healing—maybe a limp that slows movement, or blurred vision that clears gradually. Players should end sessions feeling like survivors of an ordeal, not heroes who shrugged off challenges."</p><p>Stamina systems create moment-to-moment tension in a way health systems can't.</p><p>Health decisions happen occasionally—when you find healing items, when you decide whether to engage or avoid an enemy. Stamina decisions happen constantly. Every sprint depletes stamina. Every swing of a weapon drains it. Players must continuously evaluate whether they have enough stamina for the action they're considering.</p><p>Running from a creature should feel desperate. Players should watch their stamina bar drop and feel genuine anxiety about whether they can reach safety before exhaustion forces them to slow down. This creates chase sequences that feel harrowing rather than routine.</p><p>The key to effective stamina design is what we called exhaustion consequences. When stamina depletes fully, players shouldn't simply be unable to run—they should be visibly impaired. Heavy breathing that might attract the creature. Slowed walking that makes escape harder. Blurred screen edges that reduce awareness. Exhaustion should feel like a crisis.</p><p>Recovery should also feel meaningful. Standing still regenerates stamina faster than walking. Finding a safe room might restore stamina fully. These mechanics reward careful play—players who manage stamina well maintain options, while players who sprint constantly find themselves vulnerable at critical moments.</p><p>Inventory systems transform resource management into physical puzzle.</p><p>Limited carrying capacity forces choices. You can't collect everything. When your inventory fills, you must decide what stays and what gets left behind. These decisions create personal narratives—the healing kit you dropped to carry a key item, the weapon you couldn't fit that would have been perfect for the next encounter.</p><p>Weight-based inventory adds nuance beyond simple slot limits. Heavy items impose tradeoffs—you might carry them but move slower, or leave them but move freely. This creates interesting decisions about expedition loadouts. Do you travel light for speed and stealth, or heavy for preparedness?</p><p>We found that item categories helped make inventory decisions cleaner. Tools remain equipped and don't consume slots. Consumables stack but take space. Key items occupy dedicated slots that can't be used for anything else. This structure means players always have room for essential plot items but must manage their consumable supplies.</p><p>Crafting extends resource management into experimentation and creativity.</p><p>Basic crafting lets players transform found materials into useful items. Cloth and alcohol become bandages. Wood and oil become torches. Wire becomes lockpicks. These recipes give purpose to otherwise mundane pickups and reward thorough exploration.</p><p>The design question for crafting is how generous to make it. In some games, crafting materials are common and recipes are the limiting factor—players craft frequently and consider it a core system. In others, materials are rare and crafting is a special occasion—producing a single item feels like an achievement.</p><p>For survival horror, we found that moderate scarcity worked best. Crafting should feel possible but not trivial. Players should discover recipes through play and feel clever when they produce useful items. But crafting shouldn't become the focus of gameplay—it should supplement survival, not define it.</p><p>The flashlight mechanic deserves special attention because it epitomizes survival horror design.</p><p>A flashlight provides exactly what horror denies—visibility. When your flashlight works, the darkness loses some power. You can see what's ahead. The unknown becomes known. This makes flashlight management emotionally significant in a way that other resources aren't.</p><p>Battery drain creates continuous tension. The flashlight always works—until it doesn't. Players watch the battery level drop and wonder whether they should conserve power or maintain visibility. Turning off the flashlight voluntarily feels brave. Having it die unexpectedly feels catastrophic.</p><p>Low battery behaviors amplify this tension. Flickering light at low power warns that darkness approaches. The flicker itself disturbs—the strobing effect makes shadows seem to move. When the battery finally dies, the sudden darkness hits harder because players had those warning signs and couldn't prevent the outcome.</p><p>Battery pickups become precious. Finding batteries feels like finding safety. Using batteries feels like buying time. The simple mechanic of light and darkness gains emotional weight through resource scarcity.</p><p>We discovered that communicating these emotional goals to AI assistants produced better systems than describing technical implementations. Rather than "flashlight drains at 5% per second and flickers below 20%," we prompted: "The flashlight should feel like a lifeline. Battery drain should be slow enough that players can complete exploration objectives but fast enough that they can't keep the light on indefinitely. Low battery should feel like approaching doom—flickering, unreliable light that players desperately want to restore."</p><p>The AI generates appropriate drain rates and behaviors because it understands what the system should feel like. The numbers come out differently than if we'd specified them, but the feel matches our intent.</p><p>Optional systems extend survival mechanics for players who want deeper challenge.</p><p>Hunger and thirst add long-term resource pressure. Even when moment-to-moment survival seems stable, players must plan for sustenance. This works well for longer-form games where sessions span days of in-game time. For shorter experiences, these mechanics often feel like busywork—adding complexity without adding fun.</p><p>Sanity systems let horror affect players beyond physical health. Witnessing terrible things, spending time in darkness, encountering the creature—these might drain sanity. Low sanity could produce hallucinations, unreliable information, impaired decision-making. This system works thematically for Lovecraftian or psychological horror but requires careful implementation to avoid feeling arbitrary.</p><p>Temperature systems force players to manage environmental exposure. Cold areas drain warmth; players must find heat sources or wear appropriate clothing. This works well for outdoor survival horror—frozen wastelands, harsh winters—but adds complexity that may not serve tighter, interior-focused experiences.</p><p>The key question for any optional system: does it enhance the horror? If managing hunger makes players feel desperate and vulnerable, include it. If it just means clicking "eat" periodically, skip it. Mechanics should serve emotion, not exist for their own sake.</p><p>Balancing survival mechanics requires playtesting and iteration.</p><p>The numbers you start with won't be right. They never are. Health regeneration rates, stamina drain speeds, item spawn frequencies—all of these require adjustment based on how actual players experience your game.</p><p>Vibe coding accelerates this iteration. Instead of manually adjusting values and rebuilding, you describe what feels wrong and let the AI suggest corrections. "Players are never running out of batteries—how can we increase scarcity?" Or: "Combat feels too punishing—health drops too fast for players to escape. What changes would give more survivable encounters while maintaining tension?"</p><p>The AI proposes changes. You test them. You describe the new feel. The conversation continues until the experience matches your vision.</p><p>We developed a useful heuristic for survival balance: players should feel relief when they find resources and anxiety when they use them. If finding a medkit feels routine, you have too many. If using a medkit feels wasteful, healing might be too precious. The emotions guide the numbers.</p><p>These survival mechanics connect to everything else in your horror game. The creature feels threatening because players have limited resources to survive encounters. The atmosphere feels oppressive because resources needed to survive that atmosphere are scarce. The environment rewards exploration because exploration yields survival resources.</p><p>The integration matters more than any individual system. A health system in isolation is just a number. A health system connected to rare healing items, dangerous encounters, and persistent consequences becomes central to how players experience your game.</p><p>The next chapter covers environment design—the physical spaces where survival plays out. Corridors, rooms, hiding spots, resource locations. These spaces shape how survival mechanics feel. A medkit in the middle of a safe room feels different from a medkit in a dangerous corridor. Where you place resources matters as much as what those resources do.<br>
</p>
    </section>
  

    <section id="chapter-5" class="chapter">
      <h2>Environment and Level Design</h2>
      <p>The greatest horror environments require no creatures at all. Walk through an abandoned hospital wing. Notice the overturned wheelchair, the papers scattered across the floor, the light flickering at the end of the corridor. Something happened here. The space itself tells you to be afraid.</p><p>Environmental design in horror games works on principles that predate video games entirely. Haunted houses, Gothic architecture, the dark forests of fairy tales—humans have always understood that certain spaces feel dangerous. These feelings aren't random. They emerge from specific characteristics that designers can learn and apply.</p><p>The first principle is occlusion—limiting what players can see. Fear thrives in uncertainty. When you can see an entire room from the doorway, you know immediately whether it's safe. When corners hide possibilities, when furniture blocks sightlines, when darkness pools between light sources, your imagination fills the gaps with threats. The monster you imagine is scarier than the monster you see.</p><p>Traditional horror game design achieved occlusion through fixed camera angles and fog. Resident Evil's cameras often showed just part of a room; players couldn't see what was beside them. Silent Hill's fog meant you couldn't see more than a few meters in any direction. These weren't merely technical limitations—the developers understood that visibility reduction amplifies fear.</p><p>In Roblox, you control sightlines through level geometry. Corridors should turn rather than extend endlessly. Rooms should contain furniture that breaks up space. Windows should be obscured or absent. Every place where a player might look, ask yourself: what can they see? What can they not see? What do they imagine might be in the spaces they can't see?</p><p>Lighting extends this principle. Pools of light separated by darkness create islands of certainty in a sea of possibility. Players naturally move toward light, but reaching that light requires crossing the dark. The creature could be anywhere in the dark. It probably isn't—but it could be.</p><p>We discovered that light placement tells stories. A room lit from a single overhead source feels institutional, clinical. A room lit by a flashlight beam feels intimate and fragile. A room lit by flickering emergency lights feels chaotic, unsafe. Players read these lighting choices emotionally before they consciously analyze them.</p><p>Sound design intersects with environment design in crucial ways.</p><p>Every room should have its own acoustic character. Empty spaces echo differently than furnished spaces. Pipes running through walls create ambient noise. Dripping water establishes a baseline rhythm. These sounds make spaces feel real rather than abstract—and real spaces harbor real threats.</p><p>We used what we called acoustic zones—areas with distinct ambient sound profiles. The main corridor might have distant mechanical humming. The flooded basement might have constant dripping and occasional groaning pipes. The generator room might be loud enough to mask footsteps. These zones create variety but also gameplay implications. In the loud generator room, players can't hear the creature approach but the creature also can't hear them.</p><p>Positional audio makes these zones feel three-dimensional. A sound from your left encourages you to look left. A sound from behind encourages you to turn around. When that sound might be the creature, these simple audio cues become moments of intense decision-making.</p><p>Environmental storytelling deserves extended discussion because it accomplishes multiple goals simultaneously.</p><p>Objects arranged in space tell stories. A barricaded door suggests someone tried to keep something out—or in. A drag mark along the floor suggests someone was taken. A child's drawing on a wall suggests innocence lost. Players piece together narratives from these environmental details, and that narrative engagement keeps them interested even during quiet periods.</p><p>The technique works particularly well in horror because implications are scarier than explanations. A monster that's fully explained becomes a known quantity. A monster suggested by claw marks, bloodstains, and terrified notes remains mysterious. What could make marks like that? What could scare someone into writing that note?</p><p>We found that layered storytelling worked best. Surface-level details communicate immediate danger—the fresh bloodstain, the recently broken window. Deeper details reveal backstory—personnel files, research notes, personal diaries. Completionist players can reconstruct the full narrative, while casual players absorb enough to feel the horror.</p><p>Doors deserve special attention because they're moments of maximum uncertainty.</p><p>Every door represents a decision point. Open it or don't. What's on the other side? The creature? Resources? Nothing? The anticipation before a door opens is often more frightening than what actually lies beyond.</p><p>Door design should support this anticipation. Heavy doors that swing slowly build tension during the reveal. Locked doors that require keys create objectives and force players to explore. Damaged doors—partially open, blocked by debris—suggest that something happened here. Audio cues from beyond doors hint at what awaits.</p><p>We experimented with door behaviors that creatures could trigger. A creature slamming through a door you thought was safe creates genuine shock. A creature standing on the other side when you open a door creates jumpscares you can't blame on random spawning. These moments work because they subvert the player's assumption that they control when doors open.</p><p>Hiding spots represent the flip side of door design—places where players can gain temporary safety.</p><p>Classic horror games offered limited hiding options. Players hid in lockers, under beds, inside closets. These locations provide safety only while occupied and only if the creature doesn't search too thoroughly. The mechanic creates its own tension: you're hidden, but you're also trapped. If the creature finds you, there's no escape.</p><p>The design question is how reliable hiding should be. Perfectly safe hiding trivializes the creature—players just hide whenever it appears. But hiding that never works eliminates an entire strategy. We found that probabilistic detection worked well: hiding usually works, but a creature that comes too close might discover you. This keeps hiding viable while maintaining tension during hide sequences.</p><p>Sound matters enormously while hiding. Players hold their breath metaphorically; if your game has breathing sounds, players might hold their breath literally, triggering audio cues. Heavy breathing, heartbeat sounds, muffled external audio—these create the hiding experience even when the screen shows nothing but darkness inside a locker.</p><p>Resource placement shapes how players move through environments.</p><p>Where you place healing items, batteries, ammunition, and keys determines which routes players take and how much of your environment they explore. Central placement on main paths means players find resources easily; peripheral placement rewards exploration.</p><p>For survival horror, peripheral placement usually serves better. Players should feel that they've earned their resources by taking risks—exploring a dark side room, checking a suspicious alcove. The resource itself becomes a reward for courage.</p><p>Pacing emerges from the arrangement of dangerous and safe spaces.</p><p>Horror can't be constant. Players need recovery periods or they become desensitized or exhausted. Safe rooms—areas where the creature never appears—provide these recovery periods. Players can catch their breath, manage inventory, read notes, and prepare for the next challenge.</p><p>The rhythm should oscillate. Tension builds as players explore dangerous areas. They find a safe room and tension releases. They leave the safe room and tension begins building again. This oscillation keeps players engaged far longer than constant high tension.</p><p>Visual landmarks help players navigate while maintaining horror atmosphere.</p><p>Getting lost in a horror game can be frustrating rather than scary. Players need enough spatial information to form mental maps while still feeling uncertain about what lies ahead. Distinctive elements—a broken window in one corridor, a particular painting in another—help players orient without requiring obvious signage.</p><p>We found that landmark placement affected pacing. Placing landmarks near decision points helps players remember where they've been and what they've tried. Placing landmarks near danger zones creates memorable associations—"the corridor with the red painting is where I almost died."</p><p>When vibe coding environments, we communicated design intent rather than technical implementation.</p><p>Rather than specifying exact Part positions and dimensions, we described the experience we wanted. "Create a medical wing with examination rooms branching off a main corridor. The corridor should have poor lighting with pools of darkness between fixtures. Each room should feel like it was abandoned quickly—equipment overturned, papers scattered. Place a hiding spot in at least one room and ensure there are multiple ways to navigate through the wing."</p><p>This prompt lets the AI handle Roblox specifics—CFrame positioning, collision groups, lighting values—while producing spaces that serve our design goals. We could then iterate on the result: "The corridor feels too bright. Reduce the lighting and add more objects that break up sightlines." The conversation stays at the level of experience rather than dropping into technical details.</p><p>Testing environments requires playing as a first-time player would.</p><p>Once you've built and tested an area dozens of times, you know where everything is. The fear of the unknown evaporates. You need fresh perspectives—playtesters who haven't seen the space before. Watch where they look, where they hesitate, where they get lost, where they feel comfortable.</p><p>We developed a testing protocol. First playthrough: observe without comment. Note where the player seems tense, relaxed, confused, or bored. Second playthrough: ask for verbal reactions. What did they expect behind that door? What made them hesitate in that corridor? Third playthrough: discuss specific design choices. Did the barricaded door communicate danger? Did the lighting feel appropriately scary?</p><p>This feedback shapes iteration. Areas that felt tense to playtesters get preserved. Areas that felt boring get modified—more occlusion, different lighting, additional environmental details. Areas that felt frustrating get clarified—better landmarks, more consistent rules.</p><p>Environment design connects everything we've discussed.</p><p>The atmosphere systems create mood. The creature provides threat. The survival mechanics create stakes. But the environment is where these elements combine into experience. A perfectly coded creature feels threatening only in spaces designed to make encounters scary. Survival resources feel precious only when obtaining them requires navigating dangerous environments.</p><p>The next chapter covers multiplayer—adding other humans to your carefully designed horror. This changes everything. Other players introduce chaos, provide emotional support, and create social dynamics that transform the experience. The environments you've built will host not just individual survival but shared terror.<br>
</p>
    </section>
  

    <section id="chapter-6" class="chapter">
      <h2>Multiplayer Systems</h2>
      <p>Something peculiar happens when you experience horror with other people. The fear should diminish—more eyes watching for threats, more hands to help if something goes wrong, simple safety in numbers. Instead, the opposite often occurs. Horror with companions becomes more intense, not less. The psychology is fascinating and directly applicable to game design.</p><p>Social horror works because fear is contagious. When your friend screams, you startle even before knowing why. When someone hesitates at a doorway, their uncertainty becomes yours. Multiplayer horror games leverage this emotional contagion, turning a group of players into an amplifier for whatever fear the game itself generates.</p><p>But multiplayer also introduces challenges that single-player horror doesn't face. Players can coordinate. They can cover each other's blind spots. They can share resources, revive fallen teammates, strategize against the creature. Without careful design, these capabilities trivialize the horror entirely.</p><p>The games that succeed at multiplayer horror understand this tension and design around it. They create systems where cooperation is necessary but never sufficient. Where helping your friend might mean exposing yourself. Where communication itself carries risk.</p><p>The most important multiplayer horror principle we discovered was this: resources that help individuals should harm groups.</p><p>Consider the flashlight. A single player with a flashlight has visibility. Two players with flashlights have twice the visibility. This seems to suggest that multiplayer makes the darkness less threatening—but only if you design flashlights as pure benefit.</p><p>Instead, imagine the flashlight as a signal. Every player with their light on is visible from further away than they can see. The creature spots the lights. A group of four players, all with flashlights blazing, becomes a beacon that draws attention from across the map.</p><p>Now flashlight management involves coordination. Who needs light? Who can navigate without it? When a player turns off their flashlight to conserve detection risk, they're making a choice that affects the whole group. The individual benefit creates collective vulnerability.</p><p>This pattern extends to many multiplayer systems. Communication attracts the creature—proximity chat reaches nearby players but also nearby threats. Reviving a downed teammate requires standing still for precious seconds, exposed. Opening doors creates noise that might be heard. Every helpful action carries risk that affects everyone.</p><p>The second principle emerged from playtesting: separated players create more tension than grouped players.</p><p>A tight group of four players moving through a corridor feels relatively safe. They can watch each direction. They can respond quickly to threats. The creature faces a coordinated opposition.</p><p>But split that group—two players went left while two went right—and suddenly both pairs feel vulnerable. Neither knows what's happening to the other. Was that distant scream the other pair? Should they go help? Will helping expose them?</p><p>Creature AI should exploit this tendency. When players cluster, the creature can force them to separate through environmental pressure—blocking the main route, appearing on one side of the group, creating situations where splitting up seems smart. Once split, the creature can hunt the weaker pair while the stronger pair can't respond in time.</p><p>We implemented what we called isolation targeting. The creature's AI evaluates each player's support level—how many allies are nearby, how quickly help could arrive. Isolated players become priority targets. This creates a natural rhythm where the group tries to stay together, the creature forces separation, and reunification becomes a tense objective.</p><p>Player revival systems deserve careful attention because they directly address the death problem.</p><p>In single-player horror, death means restarting. The consequence is time and progress lost. In multiplayer, death could mean the same—respawn elsewhere, rejoin the group. But this feels wrong for horror. Death should matter. It should affect the group emotionally.</p><p>The down-but-not-out system addresses this. When a player takes lethal damage, they enter a downed state rather than dying immediately. They can't move, can't fight, can only wait. Teammates can revive them, but revival takes time during which the reviver is vulnerable. A bleedout timer creates urgency—take too long and the downed player dies permanently.</p><p>This system creates drama that simple respawning doesn't. The downed player watches their timer tick down, hoping rescue arrives. The potential rescuer weighs risk against reward—is reviving worth the danger? The rest of the group covers or chooses not to, each decision affecting group dynamics.</p><p>When we playtested revival systems, the most memorable moments weren't successful revives. They were failed rescues. The player who arrived just too late. The reviver who got caught during the attempt. The group that argued about whether to try. These moments create stories players share afterward, which is exactly what horror games should produce.</p><p>Communication systems present design challenges specific to horror.</p><p>Voice chat in multiplayer games typically operates globally—everyone hears everyone regardless of location. For horror, this breaks immersion entirely. The player across the map shouldn't hear your panicked whisper. Your scream should reach nearby allies, not the whole server.</p><p>Proximity-based communication solves this while creating new gameplay considerations. If your voice only reaches nearby players, then a scattered group loses coordination. You might hear your ally's warning but not know who's warning whom. You might not hear it at all.</p><p>This ambiguity serves horror. Real scary situations don't come with clear information channels. You hear sounds but don't know their source. You lose contact with allies and don't know their status. Proximity chat replicates this uncertainty.</p><p>We added risk layers to communication. Normal speech reaches a certain radius—far enough to coordinate with nearby allies, close enough that the creature in the next room might hear. Whispering reduces both ranges. Shouting expands hearing range but also detection range. Players choose their communication mode based on situation, adding another decision layer.</p><p>Some games include radio items that enable long-distance communication at the cost of noise generation. Finding and keeping radios becomes strategically important for split groups while also creating detection risk. The tradeoff enriches gameplay without requiring complex systems.</p><p>Resource sharing creates social dynamics that single-player games can't replicate.</p><p>When healing items are personal, each player manages their own survival. When healing items can be shared, social considerations emerge. The wounded player needs the medkit; the healthy player carrying it might need it later. Who decides?</p><p>Trading systems formalize these negotiations. Players within range can exchange items, but the exchange takes time during which both participants are vulnerable. You might choose to drop items instead—faster but risky, since anything on the ground can be taken by anyone.</p><p>The tragedy of the commons applies to shared resources. A health kit in the middle of the safe room belongs to whoever takes it. If everyone exercises restraint, the kit remains available for whoever needs it most. If anyone grabs it selfishly, trust erodes.</p><p>We saw playtest groups develop internal resource allocation norms without any mechanical enforcement. "Healers carry medkits." "Lowest health gets priority." These emergent social contracts create team cohesion that mechanical systems can't replicate.</p><p>Objective design in multiplayer horror must account for varied skill levels and playstyles.</p><p>A survive-until-timer-expires objective works well because it requires no individual heroism. Everyone just needs to not die. Players can contribute according to their abilities—aggressive players draw creature attention while cautious players conserve resources.</p><p>Collect-the-items objectives create more interesting dynamics. Someone needs to actively explore, which means exposure to danger. The question becomes who explores and who supports. Natural role differentiation emerges from these choices.</p><p>Escape objectives create climactic endings but risk unfair outcomes. If one player reaches the exit while others die, was that success or failure? Some games require all survivors to escape. Others count individual escapes. The choice affects how players relate to each other throughout the experience.</p><p>We found that sequential objectives worked best for pacing. Early objectives might be easy, establishing cooperation patterns. Middle objectives increase pressure, testing those patterns. Final objectives require everyone to coordinate under maximum threat. This arc gives groups time to develop teamwork before requiring it.</p><p>The creature's AI needs redesign for multiplayer scenarios.</p><p>Single-player creature AI optimizes for scariness to one player. Multiplayer creature AI must consider group dynamics. Should it target the weakest player to get quick kills? The strongest to remove threat? Should it split the group or pressure them together?</p><p>We implemented threat scoring that evaluated each player on multiple factors: health, isolation, noise generation, flashlight status, position. The creature considers these scores but doesn't always target the highest—predictability reduces fear. Sometimes it targets randomly among viable options. Sometimes it deliberately ignores the obvious target to create false security.</p><p>Creature behavior visible to multiple players carries different implications than behavior only one player sees. If the creature walks past a hiding player while others watch, those watchers learn something about detection thresholds. They might hide differently next time. The creature's actions teach the group, which affects difficulty scaling.</p><p>Some multiplayer horror games include multiple creatures or escalating threat levels as groups get better at survival. We found that threat escalation worked better than multiple simultaneous creatures—tracking one threat is scary; tracking multiple becomes strategic rather than frightening.</p><p>Testing multiplayer horror requires specific approaches.</p><p>Solo testing catches obvious bugs but misses emergent social dynamics entirely. You need actual groups playing together to see how communication flows, how resources get shared, how groups respond to pressure.</p><p>We developed a testing protocol: first, groups of strangers to see how systems work without established relationships; then, groups of friends to see how systems work with trust; then, mixed groups to see how different familiarity levels interact. Each group type revealed different issues.</p><p>The grief testing question matters especially for horror. Can players harm each other deliberately? Should they be able to? Some games allow friendly fire, creating genuine danger from ally mistakes but also enabling toxic behavior. Others prevent any player-versus-player interaction, sacrificing some emergent drama for guaranteed cooperation.</p><p>Our solution was contextual grief prevention. Players can't directly damage allies, but they can indirectly endanger them—making noise that attracts the creature, closing doors that allies need open, taking resources others need. These indirect harms feel natural in horror contexts without enabling pure trolling.</p><p>The final multiplayer principle we discovered was that successful groups tell stories afterward.</p><p>Horror games are experiences, and multiplayer experiences become shared memories. "Remember when you closed the door on me?" "Remember when I ran back to save you?" These moments define not just the game experience but the real relationships between players.</p><p>Design toward memorable moments. Create situations where players must make dramatic choices about each other. Enable sacrifice, betrayal, redemption, heroism. The mechanical systems exist to generate these narratives, and the narratives are what players remember.</p><p>When playtesting revealed that groups consistently shared certain stories afterward—the clutch revive, the sacrifice play, the miraculous escape—we knew those moments were working. When groups had nothing interesting to say about their session, something was missing from the design.</p><p>The next chapter covers polish and publishing—the final steps before your horror enters the world. Multiplayer systems are complex, but they're also invisible to players who experience only their effects. Polish makes those effects feel professional rather than amateur.<br>
</p>
    </section>
  

    <section id="chapter-7" class="chapter">
      <h2>Polish and Publishing</h2>
      <p>A game that functions is not the same as a game that shines. The gap between working prototype and polished release contains countless small decisions—audio levels, animation timing, feedback clarity, visual coherence. None of these individually matter much. Together, they determine whether players feel like they're experiencing something professional or something amateur.</p><p>Polish is where vibe coding faces its most interesting challenge. AI assistants excel at generating functional systems. Describing "create a health bar that displays current player health" produces something that works. But describing the feel of that health bar—the way it should throb at low health, the sound it should make when depleted, the way losing health should affect screen clarity—requires understanding the emotional experience you're creating.</p><p>Horror polish specifically aims at sustaining dread. Every element of your game should contribute to or at least not undermine the atmosphere you've built. A playful sound effect, an overly bright UI element, a jarring font choice—these break the spell. Polish means auditing everything for tonal consistency.</p><p>User interface in horror games faces a fundamental tension. Players need information to make meaningful decisions—health, stamina, inventory, objectives. But information displays pull attention from the game world toward abstract representations of game state. Heavy UI creates distance between player and experience.</p><p>The solution is what designers call diegetic UI—interface elements that exist within the game world rather than overlaid on it. The classic example is Dead Space, where the player's health displays as a glowing bar on their character's spine. You check your health by looking at your character, not at a corner of the screen.</p><p>In Roblox horror, purely diegetic UI is difficult, but you can move in that direction. Health might be represented by visual effects on the player's view—reddening edges at low health, desaturation as damage accumulates, blurring at critical levels. These effects exist within the game rather than commenting on it from outside.</p><p>When UI elements must exist—inventory screens, objective displays, interaction prompts—minimize their visual footprint. Small fonts. Muted colors. Transparency that lets the game world show through. The UI should feel like whispered information, not a billboard.</p><p>We discovered that UI animations affected horror feel more than we expected. A health bar that updates instantly feels mechanical. A health bar that drains smoothly, especially one that seems to hesitate before major drops, creates anticipation even in an abstract display. Animation gives UI elements weight.</p><p>Audio polish separates amateur games from professional ones more than any other element.</p><p>Players forgive rough graphics. They won't forgive bad audio. Sounds that are too loud or too quiet, audio that clips or cuts off abruptly, music that doesn't fit the mood—these problems pull players out of the experience immediately.</p><p>Footstep systems deserve particular attention. Every step the player takes produces sound. In horror, those sounds should feel meaningful. Different surfaces should sound different—metal grating distinct from concrete flooring, wood creaking under weight, water splashing when you walk through puddles. This variety makes the environment feel physical rather than abstract.</p><p>We implemented what we called audio layering for ambient soundscapes. Rather than one continuous ambient track, we created multiple layers that play simultaneously. A base drone provides constant low-frequency rumble. An environment layer adds location-specific sounds—mechanical hum in industrial areas, dripping water in flooded sections. A tension layer grows as threat increases—subtle heartbeat, dissonant tones, increasing frequency. These layers crossfade based on game state, creating dynamic audio that responds to player situation.</p><p>Sound positioning matters enormously for horror. A sound from behind you creates immediate tension. A sound from above suggests something you haven't seen. Roblox's spatial audio handles this well, but you need to configure sounds to use it properly. Sounds that should have physical presence in the world need roll-off settings that make them quieter with distance. Sounds that represent internal states—heartbeat, breathing—should be non-positional.</p><p>Visual polish extends beyond UI into every graphical element.</p><p>Lighting consistency means your carefully designed atmosphere remains consistent across the game. Bright spots that shouldn't exist, dark areas that feel arbitrary, color temperatures that shift between areas without reason—these break the visual coherence that sustains mood.</p><p>Particle effects can enhance or destroy atmosphere depending on execution. Dust motes in light beams create depth and physicality. Fog that responds to movement makes the environment feel reactive. But effects that are too prominent or too colorful draw attention to themselves rather than serving the experience.</p><p>We found that visual polish often meant removal rather than addition. The first pass on a horror game tends to add effects—more particles, more post-processing, more visual activity. Subsequent passes should question each addition: does this serve the horror? Often the answer is no, and removing the effect improves the experience.</p><p>Performance polish is invisible to players but defines whether your game feels smooth or stuttery.</p><p>Horror depends on player immersion. Frame rate drops break immersion instantly. The player stops experiencing the horror and starts experiencing the game as a technical artifact. Maintaining consistent performance is therefore essential even though players never consciously appreciate it.</p><p>Roblox's streaming system helps with large maps. Rather than loading everything at once, the engine loads content as players approach it. Configuration for streaming involves balancing load radius against visual pop-in—you want content loaded before players can see it but not so much content that the load becomes expensive.</p><p>Raycasting efficiency matters for horror games because many systems use raycasts: detection systems checking whether the creature can see the player, sound propagation checking for walls between noise sources and listeners, flashlight systems determining what the beam illuminates. Each raycast has cost. Batching raycasts, caching results where appropriate, and avoiding redundant calculations keeps performance smooth.</p><p>We developed a performance testing protocol: play through the entire game while monitoring frame rate. Note where drops occur. Investigate those specific areas for expensive operations. Often the issue is obvious once you look—a loop that runs every frame when it should run occasionally, a calculation that could be cached, a visual effect that's more complex than necessary.</p><p>Testing before publication catches issues that development blindness hides.</p><p>After building a game for weeks or months, you know it intimately. You know where to go, what to do, how systems work. Players don't have this knowledge. Things that seem obvious to you might be completely unclear to them.</p><p>Playtesting with fresh eyes reveals these blind spots. Watch players who haven't seen your game before. Where do they get confused? Where do they miss obvious interactions? Where do they do something you didn't anticipate? Each observation suggests polish work.</p><p>Horror games have specific testing needs. Does the creature feel scary? Do quiet moments still feel tense? Does the ending satisfy? These questions can't be answered by checking functionality—they require experiential evaluation that only actual play provides.</p><p>We kept a testing checklist: all objectives completable, all items interactable, all doors functional, creature behavior consistent, multiplayer sync working, performance acceptable across target devices. Running through this checklist before each significant update prevented embarrassing bugs from reaching players.</p><p>Publishing on Roblox requires understanding the platform's discovery systems.</p><p>Your game competes with millions of others. Discovery depends on multiple factors: game quality, thumbnail appeal, description clarity, player retention, and social sharing. A great game with poor presentation won't be found. A mediocre game with perfect marketing might find players but won't retain them.</p><p>Thumbnails and icons deserve significant attention. These are often the only impression potential players have before deciding whether to try your game. Horror thumbnails should communicate atmosphere—darkness, tension, threat suggested rather than shown. They should also be visually distinctive enough to stand out in browse lists.</p><p>Descriptions need to communicate quickly. What is this game? What makes it different? What can players expect? Horror game descriptions should hint at experience without spoiling it. "Survive the night in an abandoned facility" communicates more about gameplay than "my scary game please play it."</p><p>Genre tagging affects discovery. Horror games should be marked as Horror—obvious but important. Relevant additional tags help players with specific interests find your game. Multiplayer tags matter if your game supports it.</p><p>Monetization requires ethical consideration especially for horror games.</p><p>Horror works through emotional manipulation—creating fear, then relief, then fear again. Monetization schemes that exploit these emotions feel predatory. Selling safety, selling advantages against the creature, selling escapes from danger—these cheapen the experience and feel wrong.</p><p>Ethical monetization for horror games focuses on cosmetics and expansion. Players might pay for character customization that doesn't affect gameplay. They might pay for additional maps or creatures. Private servers let friend groups play together without strangers. These monetization approaches add value without undermining the horror experience.</p><p>We avoided any monetization that affected survival probability. No purchased healing items, no bought advantages against the creature, no pay-to-win elements. Players should succeed or fail based on skill and luck, not wallet size.</p><p>Post-launch work often exceeds pre-launch work.</p><p>The game that launches is not the game that endures. Player feedback reveals issues you didn't anticipate. Usage patterns show which content gets played and which gets ignored. Community requests suggest features you hadn't considered.</p><p>Bug fixing takes priority. Nothing damages a game's reputation faster than prominent bugs. Players who encounter bugs might not return. Each bug fix improves retention, which improves visibility, which brings more players.</p><p>Balance adjustments come from observing actual play. The creature might be too easy once players learn patterns. Resource spawns might be too generous or too stingy. These values need adjustment based on data rather than designer intuition.</p><p>Content updates keep players coming back. New maps, new creatures, new objectives, new items—each update gives players reason to return and experience something fresh. The most successful Roblox games update frequently, treating launch as beginning rather than ending.</p><p>Community building sustains games beyond updates.</p><p>Players who feel connected to a game's community remain engaged longer than players who experience the game in isolation. Discord servers, Roblox groups, social media presence—these create spaces for players to discuss, share, and anticipate.</p><p>Responding to player feedback, even when you can't act on it, demonstrates that someone cares about the experience. Players who feel heard become advocates. They bring friends, defend the game in discussions, spread awareness.</p><p>The community also catches bugs faster than any testing process. Thousands of players exploring your game find edge cases you never imagined. Making it easy for players to report issues helps you improve the game faster.</p><p>Vibe coding carries through every phase of polish and publication.</p><p>Describing desired effects to AI assistants works as well for polish as for core systems. "Create screen shake that responds to damage intensity, with high damage causing larger shake that decays over time." "Implement footstep sounds that vary based on floor material, with different volumes for walking versus running." "Build a thumbnail generation system that captures the game at dramatic angles with appropriate lighting."</p><p>The iterative pattern remains: describe intent, see result, refine toward vision. Polish iterations are smaller than core system iterations—adjusting animation timing rather than rebuilding animation systems—but the process is the same.</p><p>Your horror game is now complete. From project setup through creature AI, from atmospheric lighting through multiplayer systems, from polish to publication—you've built something that can terrify players.</p><p>But remember: the systems aren't the horror. The horror is the experience those systems create. Keep playing. Keep tuning. Keep asking whether each element serves the fear you're trying to generate.</p><p>When players share their terrified reactions, their close calls, their failures and triumphs—when they bring friends to experience what scared them—you'll know you've built something worthwhile.</p><p>Now go make something that haunts people.<br>
</p>
    </section>
  
    </main>

    <footer>
      <p>Generated with <a href="https://claude.ai/code">Claude Code</a> | <a href="https://github.com/bedwards/metavibe">View source</a></p>
    </footer>
  </div>
</body>
</html>