<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>How to Vibe Code a Personal Reading Library with TTS | metavibe</title>
  <meta name="description" content="A practical guide to building a personal reading library using vibe coding">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #fdfcfa;
      --text: #1a1a1a;
      --text-muted: #666;
      --accent: #6366f1;
      --border: #e5e5e5;
      --code-bg: #f3f4f6;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #111;
        --text: #e5e5e5;
        --text-muted: #999;
        --border: #333;
        --code-bg: #1a1a1a;
      }
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Lexend', 'Roboto Slab', 'Rockwell', 'Courier Bold', serif;
      line-height: 1.7;
      color: var(--text);
      background: var(--bg);
    }
    .container { max-width: 720px; margin: 0 auto; padding: 2rem; }
    header { margin-bottom: 2rem; padding-bottom: 1rem; border-bottom: 1px solid var(--border); }
    h1 { font-size: 1.5rem; font-weight: 600; margin-bottom: 0.5rem; }
    .subtitle { color: var(--text-muted); font-size: 1rem; }
    .back { display: inline-block; margin-bottom: 1rem; color: var(--accent); text-decoration: none; font-size: 0.9rem; }
    .back:hover { text-decoration: underline; }
    nav { margin: 2rem 0; padding: 1.5rem; background: var(--code-bg); border-radius: 8px; }
    nav h2 { font-size: 1rem; margin-bottom: 1rem; }
    nav ul { list-style: none; padding-left: 0; }
    nav li { margin: 0.5rem 0; }
    nav a { color: var(--accent); text-decoration: none; }
    nav a:hover { text-decoration: underline; }
    .chapter { margin: 3rem 0; padding-top: 2rem; border-top: 1px solid var(--border); }
    h2 { font-size: 1.25rem; font-weight: 600; margin: 2rem 0 1rem; }
    h3 { font-size: 1.1rem; font-weight: 600; margin: 1.5rem 0 0.75rem; }
    p { margin: 1rem 0; }
    a { color: var(--accent); }
    code { font-family: 'SF Mono', Monaco, monospace; font-size: 0.9em; background: var(--code-bg); padding: 0.2em 0.4em; border-radius: 3px; }
    pre { background: var(--code-bg); padding: 1rem; border-radius: 6px; overflow-x: auto; margin: 1rem 0; }
    pre code { background: none; padding: 0; font-size: 0.85em; }
    strong { font-weight: 600; }
    ul, ol { margin: 1rem 0; padding-left: 1.5rem; }
    li { margin: 0.5rem 0; }
    footer { margin-top: 4rem; padding-top: 2rem; border-top: 1px solid var(--border); text-align: center; color: var(--text-muted); font-size: 0.9rem; font-family: sans-serif; }
  </style>
</head>
<body>
  <div class="container">
    <a href="../../" class="back">← Back to all books</a>
    <header>
      <h1>How to Vibe Code a Personal Reading Library with TTS</h1>
      <p class="subtitle">Building a distraction-free reading experience with RSS discovery and text-to-speech</p>
    </header>

    <nav>
      <h2>Table of Contents</h2>
      <ul>
        <li><a href="#chapter-0">Introduction</a></li>
<li><a href="#chapter-1">Project Setup</a></li>
<li><a href="#chapter-2">Content Discovery with RSS</a></li>
<li><a href="#chapter-3">Content Ingestion and Storage</a></li>
<li><a href="#chapter-4">Building the Reader Interface</a></li>
<li><a href="#chapter-5">Text-to-Speech Integration</a></li>
<li><a href="#chapter-6">Organization and Search</a></li>
<li><a href="#chapter-7">Deployment and Sync</a></li>
      </ul>
    </nav>

    <main>
      
    <section id="chapter-0" class="chapter">
      <h2>Introduction</h2>
      <h2>Why Build a Personal Reading Library?</h2><p>The modern internet drowns us in content. RSS feeds, newsletters, Substack posts, blog articles—the firehose never stops. Yet the tools we have for reading this content are designed for skimming, not understanding.</p><p>Browser tabs accumulate. Bookmarks rot. Read-it-later apps become guilt-inducing graveyards of good intentions. The content we actually want to consume—thoughtful long-form writing—gets lost in the noise.</p><p>A personal reading library solves this differently. Instead of yet another inbox to manage, you build a curated collection. Content you've actively chosen to save, cleaned of ads and distractions, available offline, readable or listenable whenever you want.</p><h2>Why Text-to-Speech?</h2><p>Here's a secret: most "reading" time isn't reading time. It's commuting, exercising, cooking, cleaning. Time when your eyes are occupied but your ears are free.</p><p>Text-to-speech transforms your reading library into an audio library. That 20-minute article becomes a podcast-length listen during your morning run. That newsletter backlog becomes your driving companion.</p><p>Modern TTS has crossed the uncanny valley. Services like Speechify, ElevenLabs, and even browser-native speech synthesis produce natural-sounding audio. The bottleneck isn't the technology—it's getting your content into a TTS-friendly format.</p><p>This is harder than it sounds. Web content is polluted with:</p><p>- Navigation menus and footers<br>
- Subscription prompts and paywalls<br>
- Social sharing widgets<br>
- Related article links<br>
- Inline ads and sponsored content</p><p>Feed all that to a TTS engine and you get garbage audio. Your personal reading library needs to extract the actual article content, clean it, and present it in a format that sounds good when spoken.</p><h2>Why RSS for Discovery?</h2><p>RSS is the cockroach of the internet—it refuses to die. Despite Google Reader's shutdown, despite the social media pivot, despite everyone declaring it dead—RSS persists.</p><p>And it persists for good reason:</p><p>1. <strong>No algorithm</strong> - You see everything you subscribe to, in chronological order<br>
2. <strong>No account required</strong> - Most feeds are public URLs<br>
3. <strong>Universal format</strong> - Works with any content source that supports it<br>
4. <strong>Decentralized</strong> - No single company controls the ecosystem</p><p>Substack, the newsletter platform that's revitalized long-form writing, exposes RSS feeds for every publication. WordPress sites have had RSS for decades. Many blogs still syndicate via RSS even if they don't advertise it.</p><p>Building on RSS means you're building on a stable foundation. The feeds will still work in five years. You can't say that about platform APIs.</p><h2>Why Vibe Code It?</h2><p>You could use existing tools. Pocket, Instapaper, Feedly, Readwise—they all exist. Some even have TTS features. So why build your own?</p><p><strong>Control</strong>. You control the reading experience. Typography, colors, spacing—tuned exactly to your preferences. No corporate design committee decided what's "best" for millions of users.</p><p><strong>Ownership</strong>. Your library lives on your hardware. No subscription fees. No service shutdown. No "we're pivoting to AI" announcement that deprecates your workflow.</p><p><strong>Integration</strong>. Connect to any TTS service. Export to any format. Build exactly the workflow you want, not the workflow someone's product team prioritized.</p><p><strong>Learning</strong>. Building a reading library touches full-stack development: RSS parsing, web scraping, database design, clean typography, audio integration, API design. It's a complete education in practical software development.</p><p>And with vibe coding, you can build it in days, not months. Describe what you want. See it materialize. Iterate until it's right.</p><h2>What We're Building</h2><p>By the end of this book, you'll have a complete personal reading library with:</p><p><strong>Content Discovery</strong><br>
- RSS feed management<br>
- Automatic feed fetching on schedule<br>
- Support for Substack, blogs, and any RSS source</p><p><strong>Content Ingestion</strong><br>
- Full article extraction from URLs<br>
- HTML cleaning and sanitization<br>
- Metadata extraction (author, date, reading time)<br>
- Deduplication to avoid storing the same article twice</p><p><strong>Reader Interface</strong><br>
- Clean, distraction-free reading view<br>
- Customizable typography and themes<br>
- Dark mode for night reading<br>
- Reading progress tracking</p><p><strong>Text-to-Speech</strong><br>
- Browser-native speech synthesis<br>
- Integration with premium TTS services<br>
- Audio playback controls<br>
- Progress tracking for audio</p><p><strong>Organization</strong><br>
- Tagging and categorization<br>
- Full-text search<br>
- Reading lists and queues<br>
- Archive for completed articles</p><p><strong>Deployment</strong><br>
- Self-hosting on your own hardware<br>
- Cross-device sync<br>
- Offline support<br>
- Backup strategies</p><h2>The Technology Stack</h2><p>We'll build with:</p><p>- <strong>TypeScript</strong> - Type safety for a robust application<br>
- <strong>Node.js + Express</strong> - Simple, proven backend<br>
- <strong>PostgreSQL</strong> - Reliable database for content storage<br>
- <strong>Vite</strong> - Fast frontend tooling<br>
- <strong>RSS Parser</strong> - Library for parsing RSS/Atom feeds<br>
- <strong>Readability</strong> - Mozilla's algorithm for extracting article content<br>
- <strong>Web Speech API</strong> - Browser-native TTS</p><p>This stack prioritizes simplicity and reliability over trendiness. Every component is battle-tested and well-documented.</p><h2>Prerequisites</h2><p>To follow along, you should have:</p><p>- <strong>TypeScript proficiency</strong> - We won't explain basic syntax<br>
- <strong>Node.js experience</strong> - Comfortable with npm and async/await<br>
- <strong>Basic database knowledge</strong> - SQL fundamentals<br>
- <strong>An AI coding assistant</strong> - Claude Code, Cursor, or similar</p><p>You don't need prior experience with:</p><p>- RSS parsing (we'll cover it)<br>
- Web scraping (we'll cover it)<br>
- TTS APIs (we'll cover it)<br>
- Typography (we'll cover it)</p><h2>Let's Build</h2><p>The best software solves your own problems first. A personal reading library scratches an itch we all have: too much content, too little time, and tools that don't respect how we actually consume information.</p><p>Let's build something better.<br>
</p>
    </section>
  

    <section id="chapter-1" class="chapter">
      <h2>Project Setup</h2>
      <h2>Architecture Overview</h2><p>A reading library has a simple architecture:</p><pre><code class="language-">┌─────────────────────────────────────────────────────────────┐<br>
│                         Frontend                             │<br>
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │<br>
│  │ Feed Manager │  │ Article List│  │    Reader View      │  │<br>
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │<br>
└─────────────────────────────────────────────────────────────┘<br>
                              │<br>
                              ▼<br>
┌─────────────────────────────────────────────────────────────┐<br>
│                        REST API                              │<br>
│  /feeds  /articles  /tags  /reading-lists  /tts             │<br>
└─────────────────────────────────────────────────────────────┘<br>
                              │<br>
                              ▼<br>
┌─────────────────────────────────────────────────────────────┐<br>
│                       Services                               │<br>
│  ┌────────────┐  ┌──────────────┐  ┌───────────────────┐   │<br>
│  │FeedService │  │ArticleService│  │ ReadabilityService│   │<br>
│  └────────────┘  └──────────────┘  └───────────────────┘   │<br>
└─────────────────────────────────────────────────────────────┘<br>
                              │<br>
                              ▼<br>
┌─────────────────────────────────────────────────────────────┐<br>
│                      PostgreSQL                              │<br>
│  feeds │ articles │ tags │ reading_lists │ reading_progress │<br>
└─────────────────────────────────────────────────────────────┘</code></pre><p>No microservices. No message queues. No distributed caching. Just a monolithic application that does one thing well.</p><h2>Project Structure</h2><pre><code class="language-">reading-library/<br>
├── src/<br>
│   ├── api/<br>
│   │   ├── index.ts              # Express app entry<br>
│   │   ├── routes/<br>
│   │   │   ├── feeds.ts          # Feed CRUD endpoints<br>
│   │   │   ├── articles.ts       # Article endpoints<br>
│   │   │   ├── tags.ts           # Tag management<br>
│   │   │   ├── reading-lists.ts  # Reading list endpoints<br>
│   │   │   └── tts.ts            # TTS generation<br>
│   │   └── middleware/<br>
│   │       ├── error.ts          # Error handling<br>
│   │       └── validation.ts     # Request validation<br>
│   ├── services/<br>
│   │   ├── feed-service.ts       # RSS fetching and parsing<br>
│   │   ├── article-service.ts    # Article CRUD<br>
│   │   ├── readability-service.ts # Content extraction<br>
│   │   ├── tts-service.ts        # Text-to-speech<br>
│   │   └── scheduler-service.ts  # Background jobs<br>
│   ├── db/<br>
│   │   ├── client.ts             # Database connection<br>
│   │   ├── migrations/           # Schema migrations<br>
│   │   └── queries/              # SQL query functions<br>
│   ├── types/<br>
│   │   └── index.ts              # TypeScript interfaces<br>
│   └── utils/<br>
│       ├── html-cleaner.ts       # HTML sanitization<br>
│       └── text-utils.ts         # Text processing<br>
├── web/<br>
│   ├── src/<br>
│   │   ├── main.ts               # Vite entry<br>
│   │   ├── components/           # UI components<br>
│   │   ├── pages/                # Page components<br>
│   │   ├── api/                  # API client<br>
│   │   └── styles/               # CSS<br>
│   ├── index.html<br>
│   └── vite.config.ts<br>
├── package.json<br>
├── tsconfig.json<br>
├── tsconfig.api.json<br>
├── docker-compose.yml<br>
└── .env.example</code></pre><h2>Database Schema</h2><p>The database design prioritizes simplicity. Six tables cover everything:</p><pre><code class="language-sql">-- Feeds you're subscribed to<br>
CREATE TABLE feeds (<br>
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),<br>
    url TEXT NOT NULL UNIQUE,<br>
    title TEXT NOT NULL,<br>
    description TEXT,<br>
    site_url TEXT,<br>
    favicon_url TEXT,<br>
    last_fetched_at TIMESTAMP WITH TIME ZONE,<br>
    fetch_error TEXT,<br>
    is_active BOOLEAN DEFAULT true,<br>
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),<br>
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()<br>
);</p><p>-- Articles from feeds (or manually added)<br>
CREATE TABLE articles (<br>
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),<br>
    feed_id UUID REFERENCES feeds(id) ON DELETE SET NULL,<br>
    url TEXT NOT NULL UNIQUE,<br>
    title TEXT NOT NULL,<br>
    author TEXT,<br>
    published_at TIMESTAMP WITH TIME ZONE,<br>
    content TEXT NOT NULL,           -- Cleaned HTML content<br>
    text_content TEXT NOT NULL,      -- Plain text for search/TTS<br>
    excerpt TEXT,<br>
    word_count INTEGER,<br>
    reading_time_minutes INTEGER,<br>
    image_url TEXT,<br>
    is_read BOOLEAN DEFAULT false,<br>
    is_archived BOOLEAN DEFAULT false,<br>
    is_favorite BOOLEAN DEFAULT false,<br>
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),<br>
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()<br>
);</p><p>-- Tags for organization<br>
CREATE TABLE tags (<br>
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),<br>
    name TEXT NOT NULL UNIQUE,<br>
    color TEXT DEFAULT '#6B7280',<br>
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()<br>
);</p><p>-- Many-to-many relationship between articles and tags<br>
CREATE TABLE article_tags (<br>
    article_id UUID REFERENCES articles(id) ON DELETE CASCADE,<br>
    tag_id UUID REFERENCES tags(id) ON DELETE CASCADE,<br>
    PRIMARY KEY (article_id, tag_id)<br>
);</p><p>-- Reading lists (collections of articles)<br>
CREATE TABLE reading_lists (<br>
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),<br>
    name TEXT NOT NULL,<br>
    description TEXT,<br>
    is_default BOOLEAN DEFAULT false,<br>
    position INTEGER DEFAULT 0,<br>
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),<br>
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()<br>
);</p><p>-- Articles in reading lists<br>
CREATE TABLE reading_list_articles (<br>
    reading_list_id UUID REFERENCES reading_lists(id) ON DELETE CASCADE,<br>
    article_id UUID REFERENCES articles(id) ON DELETE CASCADE,<br>
    position INTEGER DEFAULT 0,<br>
    added_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),<br>
    PRIMARY KEY (reading_list_id, article_id)<br>
);</p><p>-- Reading progress (for both text and audio)<br>
CREATE TABLE reading_progress (<br>
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),<br>
    article_id UUID REFERENCES articles(id) ON DELETE CASCADE,<br>
    scroll_position REAL DEFAULT 0,        -- 0-1 percentage<br>
    audio_position REAL DEFAULT 0,         -- seconds<br>
    last_read_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),<br>
    UNIQUE (article_id)<br>
);</p><p>-- Full-text search index<br>
CREATE INDEX articles_search_idx ON articles<br>
    USING GIN (to_tsvector('english', title || ' ' || text_content));</p><p>-- Performance indexes<br>
CREATE INDEX articles_feed_id_idx ON articles(feed_id);<br>
CREATE INDEX articles_published_at_idx ON articles(published_at DESC);<br>
CREATE INDEX articles_is_read_idx ON articles(is_read);<br>
CREATE INDEX articles_is_archived_idx ON articles(is_archived);<br>
CREATE INDEX feeds_is_active_idx ON feeds(is_active);</code></pre><h3>Design Decisions</h3><p><strong>UUID primary keys</strong>: Allows generating IDs client-side, which simplifies optimistic updates and offline support.</p><p><strong>Separate content and text_content</strong>: We store both the cleaned HTML (for rendering) and plain text (for search and TTS). The duplication is worth it for query performance.</p><p><strong>Soft deletes via archiving</strong>: Articles aren't deleted, just archived. This preserves reading history and allows recovery.</p><p><strong>Position fields for ordering</strong>: Reading lists need user-defined ordering. Integer positions allow reordering without updating every row.</p><h2>TypeScript Configuration</h2><p>Strict TypeScript catches bugs before they happen:</p><pre><code class="language-json">// tsconfig.json<br>
{<br>
  &quot;compilerOptions&quot;: {<br>
    &quot;target&quot;: &quot;ES2022&quot;,<br>
    &quot;module&quot;: &quot;NodeNext&quot;,<br>
    &quot;moduleResolution&quot;: &quot;NodeNext&quot;,<br>
    &quot;strict&quot;: true,<br>
    &quot;noUncheckedIndexedAccess&quot;: true,<br>
    &quot;noImplicitReturns&quot;: true,<br>
    &quot;noFallthroughCasesInSwitch&quot;: true,<br>
    &quot;exactOptionalPropertyTypes&quot;: true,<br>
    &quot;skipLibCheck&quot;: true,<br>
    &quot;declaration&quot;: true,<br>
    &quot;declarationMap&quot;: true,<br>
    &quot;sourceMap&quot;: true,<br>
    &quot;outDir&quot;: &quot;dist&quot;<br>
  },<br>
  &quot;include&quot;: [&quot;src/<em>*/</em>&quot;],<br>
  &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;dist&quot;]<br>
}</code></pre><pre><code class="language-json">// tsconfig.api.json<br>
{<br>
  &quot;extends&quot;: &quot;./tsconfig.json&quot;,<br>
  &quot;compilerOptions&quot;: {<br>
    &quot;outDir&quot;: &quot;dist/api&quot;<br>
  },<br>
  &quot;include&quot;: [&quot;src/api/<strong>/<em>&quot;, &quot;src/services/</strong>/</em>&quot;, &quot;src/db/<strong>/<em>&quot;, &quot;src/types/</strong>/</em>&quot;, &quot;src/utils/<em>*/</em>&quot;]<br>
}</code></pre><p>The key settings:</p><p>- <strong>noUncheckedIndexedAccess</strong>: Array access returns <code>T | undefined</code>, not <code>T</code><br>
- <strong>exactOptionalPropertyTypes</strong>: <code>{ a?: string }</code> means <code>a</code> can be <code>string</code> or missing, not <code>string | undefined</code><br>
- <strong>noImplicitReturns</strong>: Every code path must return explicitly</p><h2>Core Types</h2><p>Define your domain types first:</p><pre><code class="language-typescript">// src/types/index.ts</p><p>export interface Feed {<br>
  id: string;<br>
  url: string;<br>
  title: string;<br>
  description: string | null;<br>
  siteUrl: string | null;<br>
  faviconUrl: string | null;<br>
  lastFetchedAt: Date | null;<br>
  fetchError: string | null;<br>
  isActive: boolean;<br>
  createdAt: Date;<br>
  updatedAt: Date;<br>
}</p><p>export interface Article {<br>
  id: string;<br>
  feedId: string | null;<br>
  url: string;<br>
  title: string;<br>
  author: string | null;<br>
  publishedAt: Date | null;<br>
  content: string;<br>
  textContent: string;<br>
  excerpt: string | null;<br>
  wordCount: number;<br>
  readingTimeMinutes: number;<br>
  imageUrl: string | null;<br>
  isRead: boolean;<br>
  isArchived: boolean;<br>
  isFavorite: boolean;<br>
  createdAt: Date;<br>
  updatedAt: Date;<br>
}</p><p>export interface Tag {<br>
  id: string;<br>
  name: string;<br>
  color: string;<br>
  createdAt: Date;<br>
}</p><p>export interface ReadingList {<br>
  id: string;<br>
  name: string;<br>
  description: string | null;<br>
  isDefault: boolean;<br>
  position: number;<br>
  createdAt: Date;<br>
  updatedAt: Date;<br>
}</p><p>export interface ReadingProgress {<br>
  id: string;<br>
  articleId: string;<br>
  scrollPosition: number;<br>
  audioPosition: number;<br>
  lastReadAt: Date;<br>
}</p><p>// API request/response types<br>
export interface CreateFeedRequest {<br>
  url: string;<br>
}</p><p>export interface CreateArticleRequest {<br>
  url: string;<br>
  feedId?: string;<br>
}</p><p>export interface UpdateArticleRequest {<br>
  isRead?: boolean;<br>
  isArchived?: boolean;<br>
  isFavorite?: boolean;<br>
}</p><p>export interface UpdateReadingProgressRequest {<br>
  scrollPosition?: number;<br>
  audioPosition?: number;<br>
}</p><p>export interface ArticleWithTags extends Article {<br>
  tags: Tag[];<br>
}</p><p>export interface FeedWithStats extends Feed {<br>
  articleCount: number;<br>
  unreadCount: number;<br>
}</code></pre><h2>Database Connection</h2><p>A simple connection pool:</p><pre><code class="language-typescript">// src/db/client.ts<br>
import { Pool } from 'pg';</p><p>const pool = new Pool({<br>
  connectionString: process.env.DATABASE_URL,<br>
  max: 20,<br>
  idleTimeoutMillis: 30000,<br>
  connectionTimeoutMillis: 2000,<br>
});</p><p>pool.on('error', (err) =&gt; {<br>
  console.error('Unexpected database error:', err);<br>
});</p><p>export async function query&lt;T&gt;(<br>
  text: string,<br>
  params?: unknown[]<br>
): Promise&lt;T[]&gt; {<br>
  const result = await pool.query(text, params);<br>
  return result.rows as T[];<br>
}</p><p>export async function queryOne&lt;T&gt;(<br>
  text: string,<br>
  params?: unknown[]<br>
): Promise&lt;T | null&gt; {<br>
  const rows = await query&lt;T&gt;(text, params);<br>
  return rows[0] ?? null;<br>
}</p><p>export async function execute(<br>
  text: string,<br>
  params?: unknown[]<br>
): Promise&lt;number&gt; {<br>
  const result = await pool.query(text, params);<br>
  return result.rowCount ?? 0;<br>
}</p><p>export async function transaction&lt;T&gt;(<br>
  callback: (client: Pool) =&gt; Promise&lt;T&gt;<br>
): Promise&lt;T&gt; {<br>
  const client = await pool.connect();<br>
  try {<br>
    await client.query('BEGIN');<br>
    const result = await callback(pool);<br>
    await client.query('COMMIT');<br>
    return result;<br>
  } catch (error) {<br>
    await client.query('ROLLBACK');<br>
    throw error;<br>
  } finally {<br>
    client.release();<br>
  }<br>
}</p><p>export { pool };</code></pre><h2>Express API Setup</h2><p>Minimal Express configuration:</p><pre><code class="language-typescript">// src/api/index.ts<br>
import express from 'express';<br>
import cors from 'cors';<br>
import helmet from 'helmet';<br>
import { feedsRouter } from './routes/feeds.js';<br>
import { articlesRouter } from './routes/articles.js';<br>
import { tagsRouter } from './routes/tags.js';<br>
import { readingListsRouter } from './routes/reading-lists.js';<br>
import { ttsRouter } from './routes/tts.js';<br>
import { errorHandler } from './middleware/error.js';</p><p>const app = express();</p><p>// Security<br>
app.use(helmet());<br>
app.use(cors({<br>
  origin: process.env.CORS_ORIGIN ?? 'http://localhost:5173',<br>
  credentials: true,<br>
}));</p><p>// Parsing<br>
app.use(express.json({ limit: '10mb' }));</p><p>// Routes<br>
app.use('/api/feeds', feedsRouter);<br>
app.use('/api/articles', articlesRouter);<br>
app.use('/api/tags', tagsRouter);<br>
app.use('/api/reading-lists', readingListsRouter);<br>
app.use('/api/tts', ttsRouter);</p><p>// Health check<br>
app.get('/health', (_req, res) =&gt; {<br>
  res.json({ status: 'ok', timestamp: new Date().toISOString() });<br>
});</p><p>// Error handling<br>
app.use(errorHandler);</p><p>const PORT = process.env.PORT ?? 3000;</p><p>app.listen(PORT, () =&gt; {<br>
  console.log(<code>API server running on port ${PORT}</code>);<br>
});</code></pre><p>Error handling middleware:</p><pre><code class="language-typescript">// src/api/middleware/error.ts<br>
import { Request, Response, NextFunction } from 'express';</p><p>export class AppError extends Error {<br>
  constructor(<br>
    public statusCode: number,<br>
    message: string,<br>
    public code?: string<br>
  ) {<br>
    super(message);<br>
    this.name = 'AppError';<br>
  }<br>
}</p><p>export function errorHandler(<br>
  err: Error,<br>
  _req: Request,<br>
  res: Response,<br>
  _next: NextFunction<br>
): void {<br>
  console.error('Error:', err);</p><p>  if (err instanceof AppError) {<br>
    res.status(err.statusCode).json({<br>
      error: {<br>
        message: err.message,<br>
        code: err.code,<br>
      },<br>
    });<br>
    return;<br>
  }</p><p>  res.status(500).json({<br>
    error: {<br>
      message: 'Internal server error',<br>
      code: 'INTERNAL_ERROR',<br>
    },<br>
  });<br>
}</code></pre><h2>Docker Compose for Development</h2><pre><code class="language-yaml"># docker-compose.yml<br>
version: '3.8'</p><p>services:<br>
  db:<br>
    image: postgres:16-alpine<br>
    environment:<br>
      POSTGRES_USER: library<br>
      POSTGRES_PASSWORD: library<br>
      POSTGRES_DB: reading_library<br>
    ports:<br>
      - &quot;5432:5432&quot;<br>
    volumes:<br>
      - postgres_data:/var/lib/postgresql/data<br>
      - ./src/db/migrations:/docker-entrypoint-initdb.d<br>
    healthcheck:<br>
      test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U library&quot;]<br>
      interval: 5s<br>
      timeout: 5s<br>
      retries: 5</p><p>volumes:<br>
  postgres_data:</code></pre><h2>Environment Configuration</h2><pre><code class="language-bash"># .env.example<br>
DATABASE_URL=postgresql://library:library@localhost:5432/reading_library<br>
PORT=3000<br>
CORS_ORIGIN=http://localhost:5173</p><h1>Optional: Premium TTS services</h1><br>
SPEECHIFY_API_KEY=<br>
ELEVENLABS_API_KEY=</code></pre><h2>Frontend Setup with Vite</h2><p>Initialize the frontend:</p><pre><code class="language-typescript">// web/vite.config.ts<br>
import { defineConfig } from 'vite';</p><p>export default defineConfig({<br>
  root: 'web',<br>
  server: {<br>
    port: 5173,<br>
    proxy: {<br>
      '/api': {<br>
        target: 'http://localhost:3000',<br>
        changeOrigin: true,<br>
      },<br>
    },<br>
  },<br>
  build: {<br>
    outDir: '../dist/web',<br>
    emptyOutDir: true,<br>
  },<br>
});</code></pre><p>Basic HTML shell:</p><pre><code class="language-html">&lt;!-- web/index.html --&gt;<br>
&lt;!DOCTYPE html&gt;<br>
&lt;html lang=&quot;en&quot;&gt;<br>
&lt;head&gt;<br>
  &lt;meta charset=&quot;UTF-8&quot; /&gt;<br>
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;<br>
  &lt;title&gt;Reading Library&lt;/title&gt;<br>
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/src/styles/main.css&quot; /&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>
  &lt;script type=&quot;module&quot; src=&quot;/src/main.ts&quot;&gt;&lt;/script&gt;<br>
&lt;/body&gt;<br>
&lt;/html&gt;</code></pre><h2>Package Dependencies</h2><pre><code class="language-json">{<br>
  &quot;name&quot;: &quot;reading-library&quot;,<br>
  &quot;version&quot;: &quot;1.0.0&quot;,<br>
  &quot;type&quot;: &quot;module&quot;,<br>
  &quot;scripts&quot;: {<br>
    &quot;dev&quot;: &quot;concurrently \&quot;npm run dev:api\&quot; \&quot;npm run dev:web\&quot;&quot;,<br>
    &quot;dev:api&quot;: &quot;tsx watch src/api/index.ts&quot;,<br>
    &quot;dev:web&quot;: &quot;vite&quot;,<br>
    &quot;build&quot;: &quot;npm run build:api &amp;&amp; npm run build:web&quot;,<br>
    &quot;build:api&quot;: &quot;tsc -p tsconfig.api.json&quot;,<br>
    &quot;build:web&quot;: &quot;vite build&quot;,<br>
    &quot;db:up&quot;: &quot;docker-compose up -d db&quot;,<br>
    &quot;db:down&quot;: &quot;docker-compose down&quot;,<br>
    &quot;lint&quot;: &quot;eslint src web/src&quot;,<br>
    &quot;typecheck&quot;: &quot;tsc --noEmit&quot;,<br>
    &quot;test&quot;: &quot;vitest&quot;<br>
  },<br>
  &quot;dependencies&quot;: {<br>
    &quot;cors&quot;: &quot;^2.8.5&quot;,<br>
    &quot;express&quot;: &quot;^4.21.0&quot;,<br>
    &quot;helmet&quot;: &quot;^8.0.0&quot;,<br>
    &quot;pg&quot;: &quot;^8.13.0&quot;,<br>
    &quot;rss-parser&quot;: &quot;^3.13.0&quot;,<br>
    &quot;@mozilla/readability&quot;: &quot;^0.5.0&quot;,<br>
    &quot;jsdom&quot;: &quot;^25.0.0&quot;,<br>
    &quot;sanitize-html&quot;: &quot;^2.13.0&quot;<br>
  },<br>
  &quot;devDependencies&quot;: {<br>
    &quot;@types/cors&quot;: &quot;^2.8.17&quot;,<br>
    &quot;@types/express&quot;: &quot;^5.0.0&quot;,<br>
    &quot;@types/jsdom&quot;: &quot;^21.1.7&quot;,<br>
    &quot;@types/node&quot;: &quot;^22.0.0&quot;,<br>
    &quot;@types/pg&quot;: &quot;^8.11.0&quot;,<br>
    &quot;@types/sanitize-html&quot;: &quot;^2.13.0&quot;,<br>
    &quot;concurrently&quot;: &quot;^9.0.0&quot;,<br>
    &quot;eslint&quot;: &quot;^9.0.0&quot;,<br>
    &quot;tsx&quot;: &quot;^4.19.0&quot;,<br>
    &quot;typescript&quot;: &quot;^5.6.0&quot;,<br>
    &quot;vite&quot;: &quot;^6.0.0&quot;,<br>
    &quot;vitest&quot;: &quot;^2.0.0&quot;<br>
  }<br>
}</code></pre><h2>Running the Application</h2><pre><code class="language-bash"># Start the database<br>
npm run db:up</p><h1>Wait for database to be ready, then start development</h1><br>
npm run dev</code></pre><p>The API runs on port 3000, the frontend on port 5173 with proxy to the API.</p><h2>Next Steps</h2><p>With the foundation in place, we can start building features:</p><p>1. <strong>Feed discovery</strong> - Parse RSS feeds and store metadata<br>
2. <strong>Article ingestion</strong> - Fetch full content and clean HTML<br>
3. <strong>Reader interface</strong> - Display articles beautifully<br>
4. <strong>TTS integration</strong> - Convert text to speech</p><p>The architecture supports all these features without modification. We just add routes, services, and components.<br>
</p>
    </section>
  

    <section id="chapter-2" class="chapter">
      <h2>Content Discovery with RSS</h2>
      <h2>Understanding RSS</h2><p>RSS (Really Simple Syndication) is an XML format for content feeds. Every RSS feed contains:</p><p>- Channel metadata (title, description, link)<br>
- A list of items (articles, posts, episodes)<br>
- Per-item metadata (title, link, description, date, author)</p><p>Here's what a typical RSS feed looks like:</p><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>
&lt;rss version=&quot;2.0&quot;&gt;<br>
  &lt;channel&gt;<br>
    &lt;title&gt;Example Blog&lt;/title&gt;<br>
    &lt;link&gt;https://example.com&lt;/link&gt;<br>
    &lt;description&gt;Thoughts on technology&lt;/description&gt;<br>
    &lt;item&gt;<br>
      &lt;title&gt;Building Better Software&lt;/title&gt;<br>
      &lt;link&gt;https://example.com/building-better-software&lt;/link&gt;<br>
      &lt;description&gt;Some thoughts on software quality...&lt;/description&gt;<br>
      &lt;pubDate&gt;Mon, 15 Jan 2024 10:00:00 GMT&lt;/pubDate&gt;<br>
      &lt;author&gt;author@example.com&lt;/author&gt;<br>
    &lt;/item&gt;<br>
  &lt;/channel&gt;<br>
&lt;/rss&gt;</code></pre><p>Atom is a similar format with slightly different structure. Most RSS libraries handle both transparently.</p><h2>The Feed Service</h2><p>The feed service handles discovery, parsing, and storage:</p><pre><code class="language-typescript">// src/services/feed-service.ts<br>
import Parser from 'rss-parser';<br>
import { query, queryOne, execute } from '../db/client.js';<br>
import type { Feed, FeedWithStats } from '../types/index.js';</p><p>const parser = new Parser({<br>
  timeout: 10000,<br>
  headers: {<br>
    'User-Agent': 'ReadingLibrary/1.0',<br>
  },<br>
});</p><p>interface RSSItem {<br>
  title?: string;<br>
  link?: string;<br>
  pubDate?: string;<br>
  creator?: string;<br>
  content?: string;<br>
  contentSnippet?: string;<br>
  isoDate?: string;<br>
}</p><p>interface RSSFeed {<br>
  title?: string;<br>
  description?: string;<br>
  link?: string;<br>
  items: RSSItem[];<br>
}</p><p>export class FeedService {<br>
  /**<br>
   * Add a new feed by URL<br>
   */<br>
  async addFeed(feedUrl: string): Promise&lt;Feed&gt; {<br>
    // Normalize URL<br>
    const normalizedUrl = this.normalizeUrl(feedUrl);</p><p>    // Check if feed already exists<br>
    const existing = await queryOne&lt;Feed&gt;(<br>
      'SELECT * FROM feeds WHERE url = $1',<br>
      [normalizedUrl]<br>
    );</p><p>    if (existing) {<br>
      return existing;<br>
    }</p><p>    // Fetch and parse the feed to get metadata<br>
    const feedData = await this.fetchFeed(normalizedUrl);</p><p>    // Insert the feed<br>
    const feed = await queryOne&lt;Feed&gt;(<br>
      <code>INSERT INTO feeds (url, title, description, site_url)<br>
       VALUES ($1, $2, $3, $4)<br>
       RETURNING *</code>,<br>
      [<br>
        normalizedUrl,<br>
        feedData.title ?? 'Untitled Feed',<br>
        feedData.description ?? null,<br>
        feedData.link ?? null,<br>
      ]<br>
    );</p><p>    if (!feed) {<br>
      throw new Error('Failed to create feed');<br>
    }</p><p>    return feed;<br>
  }</p><p>  /**<br>
   * Fetch and parse an RSS feed<br>
   */<br>
  async fetchFeed(url: string): Promise&lt;RSSFeed&gt; {<br>
    try {<br>
      const feed = await parser.parseURL(url);<br>
      return {<br>
        title: feed.title,<br>
        description: feed.description,<br>
        link: feed.link,<br>
        items: feed.items,<br>
      };<br>
    } catch (error) {<br>
      throw new Error(<br>
        <code>Failed to fetch feed: ${error instanceof Error ? error.message : 'Unknown error'}</code><br>
      );<br>
    }<br>
  }</p><p>  /**<br>
   * Refresh a feed and return new items<br>
   */<br>
  async refreshFeed(feedId: string): Promise&lt;RSSItem[]&gt; {<br>
    const feed = await queryOne&lt;Feed&gt;(<br>
      'SELECT * FROM feeds WHERE id = $1',<br>
      [feedId]<br>
    );</p><p>    if (!feed) {<br>
      throw new Error('Feed not found');<br>
    }</p><p>    try {<br>
      const feedData = await this.fetchFeed(feed.url);</p><p>      // Update feed metadata<br>
      await execute(<br>
        <code>UPDATE feeds<br>
         SET title = $1,<br>
             description = $2,<br>
             site_url = $3,<br>
             last_fetched_at = NOW(),<br>
             fetch_error = NULL,<br>
             updated_at = NOW()<br>
         WHERE id = $4</code>,<br>
        [<br>
          feedData.title ?? feed.title,<br>
          feedData.description ?? feed.description,<br>
          feedData.link ?? feed.siteUrl,<br>
          feedId,<br>
        ]<br>
      );</p><p>      return feedData.items;<br>
    } catch (error) {<br>
      // Record the error but don't throw<br>
      await execute(<br>
        <code>UPDATE feeds<br>
         SET fetch_error = $1,<br>
             last_fetched_at = NOW(),<br>
             updated_at = NOW()<br>
         WHERE id = $2</code>,<br>
        [<br>
          error instanceof Error ? error.message : 'Unknown error',<br>
          feedId,<br>
        ]<br>
      );</p><p>      return [];<br>
    }<br>
  }</p><p>  /**<br>
   * Get all feeds with article stats<br>
   */<br>
  async getAllFeeds(): Promise&lt;FeedWithStats[]&gt; {<br>
    return query&lt;FeedWithStats&gt;(<br>
      <code>SELECT<br>
         f.*,<br>
         COUNT(a.id)::int AS article_count,<br>
         COUNT(a.id) FILTER (WHERE NOT a.is_read)::int AS unread_count<br>
       FROM feeds f<br>
       LEFT JOIN articles a ON a.feed_id = f.id AND NOT a.is_archived<br>
       WHERE f.is_active<br>
       GROUP BY f.id<br>
       ORDER BY f.title</code><br>
    );<br>
  }</p><p>  /**<br>
   * Get a single feed by ID<br>
   */<br>
  async getFeed(feedId: string): Promise&lt;Feed | null&gt; {<br>
    return queryOne&lt;Feed&gt;(<br>
      'SELECT * FROM feeds WHERE id = $1',<br>
      [feedId]<br>
    );<br>
  }</p><p>  /**<br>
   * Delete a feed (articles are preserved with null feed_id)<br>
   */<br>
  async deleteFeed(feedId: string): Promise&lt;void&gt; {<br>
    await execute(<br>
      'DELETE FROM feeds WHERE id = $1',<br>
      [feedId]<br>
    );<br>
  }</p><p>  /**<br>
   * Toggle feed active status<br>
   */<br>
  async toggleFeedActive(feedId: string): Promise&lt;Feed | null&gt; {<br>
    return queryOne&lt;Feed&gt;(<br>
      <code>UPDATE feeds<br>
       SET is_active = NOT is_active,<br>
           updated_at = NOW()<br>
       WHERE id = $1<br>
       RETURNING *</code>,<br>
      [feedId]<br>
    );<br>
  }</p><p>  /**<br>
   * Normalize a feed URL<br>
   */<br>
  private normalizeUrl(url: string): string {<br>
    // Ensure protocol<br>
    if (!url.startsWith('http://') &amp;&amp; !url.startsWith('https://')) {<br>
      url = 'https://' + url;<br>
    }</p><p>    // Parse and reconstruct<br>
    const parsed = new URL(url);<br>
    return parsed.href;<br>
  }<br>
}</p><p>export const feedService = new FeedService();</code></pre><h2>Discovering Substack Feeds</h2><p>Substack publications all follow the same pattern:</p><pre><code class="language-">https://[publication].substack.com/feed</code></pre><p>We can auto-discover feeds from Substack URLs:</p><pre><code class="language-typescript">// src/services/feed-discovery.ts</p><p>export interface DiscoveredFeed {<br>
  url: string;<br>
  title: string;<br>
  type: 'rss' | 'atom' | 'substack';<br>
}</p><p>export class FeedDiscoveryService {<br>
  /**<br>
   * Discover RSS feeds from a URL<br>
   */<br>
  async discoverFeeds(url: string): Promise&lt;DiscoveredFeed[]&gt; {<br>
    const normalizedUrl = this.normalizeUrl(url);<br>
    const discovered: DiscoveredFeed[] = [];</p><p>    // Check for Substack<br>
    if (this.isSubstackUrl(normalizedUrl)) {<br>
      const substackFeed = this.getSubstackFeed(normalizedUrl);<br>
      if (substackFeed) {<br>
        discovered.push(substackFeed);<br>
      }<br>
    }</p><p>    // Check for common feed paths<br>
    const commonPaths = [<br>
      '/feed',<br>
      '/feed/',<br>
      '/rss',<br>
      '/rss/',<br>
      '/atom.xml',<br>
      '/feed.xml',<br>
      '/rss.xml',<br>
      '/index.xml',<br>
    ];</p><p>    const baseUrl = new URL(normalizedUrl).origin;</p><p>    for (const path of commonPaths) {<br>
      const feedUrl = baseUrl + path;<br>
      if (await this.isValidFeed(feedUrl)) {<br>
        discovered.push({<br>
          url: feedUrl,<br>
          title: await this.getFeedTitle(feedUrl),<br>
          type: path.includes('atom') ? 'atom' : 'rss',<br>
        });<br>
        break; // Found a feed, stop searching<br>
      }<br>
    }</p><p>    // Try to find feed links in HTML<br>
    if (discovered.length === 0) {<br>
      const htmlFeeds = await this.discoverFromHtml(normalizedUrl);<br>
      discovered.push(...htmlFeeds);<br>
    }</p><p>    return discovered;<br>
  }</p><p>  /**<br>
   * Check if URL is a Substack publication<br>
   */<br>
  private isSubstackUrl(url: string): boolean {<br>
    return url.includes('.substack.com') || url.includes('substack.com/@');<br>
  }</p><p>  /**<br>
   * Get feed URL for a Substack publication<br>
   */<br>
  private getSubstackFeed(url: string): DiscoveredFeed | null {<br>
    const parsed = new URL(url);</p><p>    // Format: publication.substack.com<br>
    if (parsed.hostname.endsWith('.substack.com')) {<br>
      return {<br>
        url: <code>${parsed.origin}/feed</code>,<br>
        title: parsed.hostname.replace('.substack.com', ''),<br>
        type: 'substack',<br>
      };<br>
    }</p><p>    // Format: substack.com/@publication<br>
    const atMatch = parsed.pathname.match(/^\/@([^/]+)/);<br>
    if (atMatch?.[1]) {<br>
      return {<br>
        url: <code>https://${atMatch[1]}.substack.com/feed</code>,<br>
        title: atMatch[1],<br>
        type: 'substack',<br>
      };<br>
    }</p><p>    return null;<br>
  }</p><p>  /**<br>
   * Check if URL returns a valid RSS/Atom feed<br>
   */<br>
  private async isValidFeed(url: string): Promise&lt;boolean&gt; {<br>
    try {<br>
      const response = await fetch(url, {<br>
        method: 'HEAD',<br>
        headers: { 'User-Agent': 'ReadingLibrary/1.0' },<br>
        signal: AbortSignal.timeout(5000),<br>
      });</p><p>      const contentType = response.headers.get('content-type') ?? '';<br>
      return (<br>
        contentType.includes('xml') ||<br>
        contentType.includes('rss') ||<br>
        contentType.includes('atom')<br>
      );<br>
    } catch {<br>
      return false;<br>
    }<br>
  }</p><p>  /**<br>
   * Get feed title from URL<br>
   */<br>
  private async getFeedTitle(url: string): Promise&lt;string&gt; {<br>
    try {<br>
      const Parser = (await import('rss-parser')).default;<br>
      const parser = new Parser({ timeout: 5000 });<br>
      const feed = await parser.parseURL(url);<br>
      return feed.title ?? 'Untitled Feed';<br>
    } catch {<br>
      return new URL(url).hostname;<br>
    }<br>
  }</p><p>  /**<br>
   * Discover feeds from HTML page link tags<br>
   */<br>
  private async discoverFromHtml(url: string): Promise&lt;DiscoveredFeed[]&gt; {<br>
    try {<br>
      const response = await fetch(url, {<br>
        headers: { 'User-Agent': 'ReadingLibrary/1.0' },<br>
        signal: AbortSignal.timeout(10000),<br>
      });</p><p>      const html = await response.text();<br>
      const discovered: DiscoveredFeed[] = [];</p><p>      // Find &lt;link&gt; tags with RSS/Atom types<br>
      const linkRegex =<br>
        /&lt;link[^&gt;]+type=<a href="application\/(rss|atom">&quot;'</a>\+xml)[&quot;'][^&gt;]*&gt;/gi;<br>
      let match;</p><p>      while ((match = linkRegex.exec(html)) !== null) {<br>
        const linkTag = match[0];</p><p>        // Extract href<br>
        const hrefMatch = linkTag.match(/href=<a href="[^&quot;']+">&quot;'</a>[&quot;']/);<br>
        if (!hrefMatch?.[1]) continue;</p><p>        let feedUrl = hrefMatch[1];</p><p>        // Handle relative URLs<br>
        if (!feedUrl.startsWith('http')) {<br>
          feedUrl = new URL(feedUrl, url).href;<br>
        }</p><p>        // Extract title<br>
        const titleMatch = linkTag.match(/title=<a href="[^&quot;']+">&quot;'</a>[&quot;']/);<br>
        const title = titleMatch?.[1] ?? new URL(feedUrl).hostname;</p><p>        discovered.push({<br>
          url: feedUrl,<br>
          title,<br>
          type: match[2] === 'atom' ? 'atom' : 'rss',<br>
        });<br>
      }</p><p>      return discovered;<br>
    } catch {<br>
      return [];<br>
    }<br>
  }</p><p>  private normalizeUrl(url: string): string {<br>
    if (!url.startsWith('http://') &amp;&amp; !url.startsWith('https://')) {<br>
      url = 'https://' + url;<br>
    }<br>
    return new URL(url).href;<br>
  }<br>
}</p><p>export const feedDiscoveryService = new FeedDiscoveryService();</code></pre><h2>Feed Management API</h2><p>Expose feed operations via REST:</p><pre><code class="language-typescript">// src/api/routes/feeds.ts<br>
import { Router } from 'express';<br>
import { feedService } from '../../services/feed-service.js';<br>
import { feedDiscoveryService } from '../../services/feed-discovery.js';<br>
import { AppError } from '../middleware/error.js';</p><p>export const feedsRouter = Router();</p><p>// Get all feeds<br>
feedsRouter.get('/', async (_req, res, next) =&gt; {<br>
  try {<br>
    const feeds = await feedService.getAllFeeds();<br>
    res.json(feeds);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Add a new feed<br>
feedsRouter.post('/', async (req, res, next) =&gt; {<br>
  try {<br>
    const { url } = req.body as { url?: string };</p><p>    if (!url) {<br>
      throw new AppError(400, 'URL is required', 'MISSING_URL');<br>
    }</p><p>    const feed = await feedService.addFeed(url);<br>
    res.status(201).json(feed);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Discover feeds from URL<br>
feedsRouter.post('/discover', async (req, res, next) =&gt; {<br>
  try {<br>
    const { url } = req.body as { url?: string };</p><p>    if (!url) {<br>
      throw new AppError(400, 'URL is required', 'MISSING_URL');<br>
    }</p><p>    const feeds = await feedDiscoveryService.discoverFeeds(url);<br>
    res.json(feeds);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Get single feed<br>
feedsRouter.get('/:id', async (req, res, next) =&gt; {<br>
  try {<br>
    const feed = await feedService.getFeed(req.params.id);</p><p>    if (!feed) {<br>
      throw new AppError(404, 'Feed not found', 'FEED_NOT_FOUND');<br>
    }</p><p>    res.json(feed);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Refresh a feed<br>
feedsRouter.post('/:id/refresh', async (req, res, next) =&gt; {<br>
  try {<br>
    const items = await feedService.refreshFeed(req.params.id);<br>
    res.json({ itemCount: items.length, items });<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Toggle feed active status<br>
feedsRouter.post('/:id/toggle', async (req, res, next) =&gt; {<br>
  try {<br>
    const feed = await feedService.toggleFeedActive(req.params.id);</p><p>    if (!feed) {<br>
      throw new AppError(404, 'Feed not found', 'FEED_NOT_FOUND');<br>
    }</p><p>    res.json(feed);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Delete a feed<br>
feedsRouter.delete('/:id', async (req, res, next) =&gt; {<br>
  try {<br>
    await feedService.deleteFeed(req.params.id);<br>
    res.status(204).send();<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</code></pre><h2>Scheduled Feed Fetching</h2><p>Background job to refresh feeds periodically:</p><pre><code class="language-typescript">// src/services/scheduler-service.ts<br>
import { query } from '../db/client.js';<br>
import { feedService } from './feed-service.js';<br>
import { articleService } from './article-service.js';<br>
import type { Feed } from '../types/index.js';</p><p>export class SchedulerService {<br>
  private intervalId: NodeJS.Timeout | null = null;<br>
  private isRunning = false;</p><p>  /**<br>
   * Start the scheduler<br>
   */<br>
  start(intervalMinutes: number = 30): void {<br>
    if (this.intervalId) {<br>
      console.log('Scheduler already running');<br>
      return;<br>
    }</p><p>    console.log(<code>Starting feed scheduler (interval: ${intervalMinutes}m)</code>);</p><p>    // Run immediately<br>
    this.refreshAllFeeds();</p><p>    // Then run on interval<br>
    this.intervalId = setInterval(<br>
      () =&gt; this.refreshAllFeeds(),<br>
      intervalMinutes <em> 60 </em> 1000<br>
    );<br>
  }</p><p>  /**<br>
   * Stop the scheduler<br>
   */<br>
  stop(): void {<br>
    if (this.intervalId) {<br>
      clearInterval(this.intervalId);<br>
      this.intervalId = null;<br>
      console.log('Feed scheduler stopped');<br>
    }<br>
  }</p><p>  /**<br>
   * Refresh all active feeds<br>
   */<br>
  async refreshAllFeeds(): Promise&lt;void&gt; {<br>
    if (this.isRunning) {<br>
      console.log('Feed refresh already in progress, skipping');<br>
      return;<br>
    }</p><p>    this.isRunning = true;<br>
    console.log('Starting feed refresh cycle');</p><p>    try {<br>
      // Get all active feeds<br>
      const feeds = await query&lt;Feed&gt;(<br>
        'SELECT * FROM feeds WHERE is_active = true'<br>
      );</p><p>      console.log(<code>Refreshing ${feeds.length} feeds</code>);</p><p>      let totalNewArticles = 0;</p><p>      for (const feed of feeds) {<br>
        try {<br>
          const items = await feedService.refreshFeed(feed.id);</p><p>          // Ingest new articles<br>
          for (const item of items) {<br>
            if (!item.link) continue;</p><p>            try {<br>
              const created = await articleService.ingestArticle(<br>
                item.link,<br>
                feed.id<br>
              );<br>
              if (created) {<br>
                totalNewArticles++;<br>
              }<br>
            } catch (error) {<br>
              // Log but continue with other items<br>
              console.error(<br>
                <code>Error ingesting article ${item.link}:</code>,<br>
                error instanceof Error ? error.message : error<br>
              );<br>
            }<br>
          }<br>
        } catch (error) {<br>
          console.error(<br>
            <code>Error refreshing feed ${feed.url}:</code>,<br>
            error instanceof Error ? error.message : error<br>
          );<br>
        }<br>
      }</p><p>      console.log(<code>Feed refresh complete. New articles: ${totalNewArticles}</code>);<br>
    } finally {<br>
      this.isRunning = false;<br>
    }<br>
  }</p><p>  /**<br>
   * Check if scheduler is running<br>
   */<br>
  isSchedulerRunning(): boolean {<br>
    return this.intervalId !== null;<br>
  }<br>
}</p><p>export const schedulerService = new SchedulerService();</code></pre><p>Start the scheduler when the API starts:</p><pre><code class="language-typescript">// src/api/index.ts (add at the end)<br>
import { schedulerService } from '../services/scheduler-service.js';</p><p>// Start feed scheduler<br>
const FEED_REFRESH_INTERVAL = parseInt(<br>
  process.env.FEED_REFRESH_INTERVAL ?? '30',<br>
  10<br>
);<br>
schedulerService.start(FEED_REFRESH_INTERVAL);</p><p>// Graceful shutdown<br>
process.on('SIGTERM', () =&gt; {<br>
  console.log('Shutting down...');<br>
  schedulerService.stop();<br>
  process.exit(0);<br>
});</code></pre><h2>OPML Import/Export</h2><p>OPML is the standard format for exchanging feed subscriptions:</p><pre><code class="language-typescript">// src/services/opml-service.ts<br>
import { query, queryOne, execute } from '../db/client.js';<br>
import { feedService } from './feed-service.js';<br>
import type { Feed } from '../types/index.js';</p><p>export class OpmlService {<br>
  /**<br>
   * Export feeds to OPML format<br>
   */<br>
  async exportOpml(): Promise&lt;string&gt; {<br>
    const feeds = await query&lt;Feed&gt;(<br>
      'SELECT * FROM feeds WHERE is_active = true ORDER BY title'<br>
    );</p><p>    const items = feeds<br>
      .map(<br>
        (feed) =&gt;<br>
          <code>    &lt;outline type=&quot;rss&quot; text=&quot;${this.escapeXml(feed.title)}&quot; </code> +<br>
          <code>title=&quot;${this.escapeXml(feed.title)}&quot; </code> +<br>
          <code>xmlUrl=&quot;${this.escapeXml(feed.url)}&quot;</code> +<br>
          (feed.siteUrl ? <code> htmlUrl=&quot;${this.escapeXml(feed.siteUrl)}&quot;</code> : '') +<br>
          '/&gt;'<br>
      )<br>
      .join('\n');</p><p>    return <code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>
&lt;opml version=&quot;2.0&quot;&gt;<br>
  &lt;head&gt;<br>
    &lt;title&gt;Reading Library Subscriptions&lt;/title&gt;<br>
    &lt;dateCreated&gt;${new Date().toISOString()}&lt;/dateCreated&gt;<br>
  &lt;/head&gt;<br>
  &lt;body&gt;<br>
${items}<br>
  &lt;/body&gt;<br>
&lt;/opml&gt;</code>;<br>
  }</p><p>  /**<br>
   * Import feeds from OPML<br>
   */<br>
  async importOpml(opmlContent: string): Promise&lt;{<br>
    imported: number;<br>
    skipped: number;<br>
    errors: string[];<br>
  }&gt; {<br>
    const results = {<br>
      imported: 0,<br>
      skipped: 0,<br>
      errors: [] as string[],<br>
    };</p><p>    // Parse OPML - simple regex approach<br>
    const outlineRegex = /&lt;outline[^&gt;]+xmlUrl=<a href="[^&quot;']+">&quot;'</a>[&quot;'][^&gt;]*&gt;/gi;<br>
    let match;</p><p>    while ((match = outlineRegex.exec(opmlContent)) !== null) {<br>
      const feedUrl = this.unescapeXml(match[1]);</p><p>      try {<br>
        // Check if already exists<br>
        const existing = await queryOne&lt;Feed&gt;(<br>
          'SELECT id FROM feeds WHERE url = $1',<br>
          [feedUrl]<br>
        );</p><p>        if (existing) {<br>
          results.skipped++;<br>
          continue;<br>
        }</p><p>        await feedService.addFeed(feedUrl);<br>
        results.imported++;<br>
      } catch (error) {<br>
        results.errors.push(<br>
          <code>${feedUrl}: ${error instanceof Error ? error.message : 'Unknown error'}</code><br>
        );<br>
      }<br>
    }</p><p>    return results;<br>
  }</p><p>  private escapeXml(str: string): string {<br>
    return str<br>
      .replace(/&amp;/g, '&amp;amp;')<br>
      .replace(/&lt;/g, '&amp;lt;')<br>
      .replace(/&gt;/g, '&amp;gt;')<br>
      .replace(/&quot;/g, '&amp;quot;')<br>
      .replace(/'/g, '&amp;apos;');<br>
  }</p><p>  private unescapeXml(str: string): string {<br>
    return str<br>
      .replace(/&amp;amp;/g, '&amp;')<br>
      .replace(/&amp;lt;/g, '&lt;')<br>
      .replace(/&amp;gt;/g, '&gt;')<br>
      .replace(/&amp;quot;/g, '&quot;')<br>
      .replace(/&amp;apos;/g, &quot;'&quot;);<br>
  }<br>
}</p><p>export const opmlService = new OpmlService();</code></pre><h2>Feed Discovery UI Component</h2><pre><code class="language-typescript">// web/src/components/FeedDiscovery.ts</p><p>export class FeedDiscovery {<br>
  private container: HTMLElement;<br>
  private input: HTMLInputElement;<br>
  private results: HTMLElement;</p><p>  constructor(containerId: string) {<br>
    const container = document.getElementById(containerId);<br>
    if (!container) throw new Error('Container not found');<br>
    this.container = container;</p><p>    this.render();<br>
    this.input = this.container.querySelector('input')!;<br>
    this.results = this.container.querySelector('.results')!;</p><p>    this.setupEventListeners();<br>
  }</p><p>  private render(): void {<br>
    this.container.innerHTML = <code><br>
      &lt;div class=&quot;feed-discovery&quot;&gt;<br>
        &lt;form class=&quot;discovery-form&quot;&gt;<br>
          &lt;input<br>
            type=&quot;text&quot;<br>
            placeholder=&quot;Enter a blog URL or Substack publication...&quot;<br>
            autocomplete=&quot;off&quot;<br>
          /&gt;<br>
          &lt;button type=&quot;submit&quot;&gt;Find Feeds&lt;/button&gt;<br>
        &lt;/form&gt;<br>
        &lt;div class=&quot;results&quot;&gt;&lt;/div&gt;<br>
      &lt;/div&gt;<br>
    </code>;<br>
  }</p><p>  private setupEventListeners(): void {<br>
    const form = this.container.querySelector('form')!;</p><p>    form.addEventListener('submit', async (e) =&gt; {<br>
      e.preventDefault();<br>
      await this.discover();<br>
    });<br>
  }</p><p>  private async discover(): Promise&lt;void&gt; {<br>
    const url = this.input.value.trim();<br>
    if (!url) return;</p><p>    this.results.innerHTML = '&lt;div class=&quot;loading&quot;&gt;Searching for feeds...&lt;/div&gt;';</p><p>    try {<br>
      const response = await fetch('/api/feeds/discover', {<br>
        method: 'POST',<br>
        headers: { 'Content-Type': 'application/json' },<br>
        body: JSON.stringify({ url }),<br>
      });</p><p>      if (!response.ok) {<br>
        throw new Error('Discovery failed');<br>
      }</p><p>      const feeds = await response.json();<br>
      this.renderResults(feeds);<br>
    } catch (error) {<br>
      this.results.innerHTML = <code><br>
        &lt;div class=&quot;error&quot;&gt;<br>
          Could not find any feeds. Try entering the direct RSS URL.<br>
        &lt;/div&gt;<br>
      </code>;<br>
    }<br>
  }</p><p>  private renderResults(feeds: Array&lt;{<br>
    url: string;<br>
    title: string;<br>
    type: string;<br>
  }&gt;): void {<br>
    if (feeds.length === 0) {<br>
      this.results.innerHTML = <code><br>
        &lt;div class=&quot;no-results&quot;&gt;<br>
          No feeds found. Try entering the direct RSS URL.<br>
        &lt;/div&gt;<br>
      </code>;<br>
      return;<br>
    }</p><p>    this.results.innerHTML = feeds<br>
      .map(<br>
        (feed) =&gt; <code><br>
        &lt;div class=&quot;feed-result&quot;&gt;<br>
          &lt;div class=&quot;feed-info&quot;&gt;<br>
            &lt;span class=&quot;feed-title&quot;&gt;${this.escapeHtml(feed.title)}&lt;/span&gt;<br>
            &lt;span class=&quot;feed-type&quot;&gt;${feed.type.toUpperCase()}&lt;/span&gt;<br>
          &lt;/div&gt;<br>
          &lt;div class=&quot;feed-url&quot;&gt;${this.escapeHtml(feed.url)}&lt;/div&gt;<br>
          &lt;button class=&quot;subscribe-btn&quot; data-url=&quot;${this.escapeHtml(feed.url)}&quot;&gt;<br>
            Subscribe<br>
          &lt;/button&gt;<br>
        &lt;/div&gt;<br>
      </code><br>
      )<br>
      .join('');</p><p>    // Add click handlers<br>
    this.results.querySelectorAll('.subscribe-btn').forEach((btn) =&gt; {<br>
      btn.addEventListener('click', async () =&gt; {<br>
        const feedUrl = btn.getAttribute('data-url');<br>
        if (feedUrl) {<br>
          await this.subscribe(feedUrl, btn as HTMLButtonElement);<br>
        }<br>
      });<br>
    });<br>
  }</p><p>  private async subscribe(<br>
    url: string,<br>
    button: HTMLButtonElement<br>
  ): Promise&lt;void&gt; {<br>
    button.disabled = true;<br>
    button.textContent = 'Adding...';</p><p>    try {<br>
      const response = await fetch('/api/feeds', {<br>
        method: 'POST',<br>
        headers: { 'Content-Type': 'application/json' },<br>
        body: JSON.stringify({ url }),<br>
      });</p><p>      if (!response.ok) {<br>
        throw new Error('Failed to add feed');<br>
      }</p><p>      button.textContent = 'Added!';<br>
      button.classList.add('success');</p><p>      // Dispatch event for parent to handle<br>
      this.container.dispatchEvent(<br>
        new CustomEvent('feed-added', {<br>
          detail: await response.json(),<br>
        })<br>
      );<br>
    } catch (error) {<br>
      button.textContent = 'Error';<br>
      button.classList.add('error');<br>
      setTimeout(() =&gt; {<br>
        button.textContent = 'Subscribe';<br>
        button.disabled = false;<br>
        button.classList.remove('error');<br>
      }, 2000);<br>
    }<br>
  }</p><p>  private escapeHtml(str: string): string {<br>
    const div = document.createElement('div');<br>
    div.textContent = str;<br>
    return div.innerHTML;<br>
  }<br>
}</code></pre><h2>Next Steps</h2><p>With feed discovery in place, the next chapter covers ingesting the actual article content—fetching full articles, cleaning HTML, and storing them in the database.<br>
</p>
    </section>
  

    <section id="chapter-3" class="chapter">
      <h2>Content Ingestion and Storage</h2>
      <h2>The Problem with Web Content</h2><p>RSS feeds give you metadata and maybe a preview, but rarely the full article. You need to fetch the original URL and extract the content.</p><p>This is harder than it sounds. Web pages are cluttered:</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;<br>
&lt;html&gt;<br>
&lt;head&gt;<br>
  &lt;!-- 50 meta tags --&gt;<br>
  &lt;!-- 20 script tags --&gt;<br>
  &lt;!-- Analytics, tracking pixels --&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
  &lt;header&gt;&lt;!-- Navigation, logo, search --&gt;&lt;/header&gt;<br>
  &lt;aside&gt;&lt;!-- Author bio, related posts --&gt;&lt;/aside&gt;<br>
  &lt;main&gt;<br>
    &lt;article&gt;<br>
      &lt;!-- The actual content you want --&gt;<br>
      &lt;h1&gt;Article Title&lt;/h1&gt;<br>
      &lt;p&gt;The content...&lt;/p&gt;<br>
      &lt;!-- But also: newsletter signup forms, social buttons --&gt;<br>
    &lt;/article&gt;<br>
  &lt;/main&gt;<br>
  &lt;footer&gt;&lt;!-- Links, copyright --&gt;&lt;/footer&gt;<br>
  &lt;!-- More scripts, chat widgets --&gt;<br>
&lt;/body&gt;<br>
&lt;/html&gt;</code></pre><p>You want the <code><article></code> content, cleaned of cruft. Mozilla's Readability algorithm does exactly this—it's what Firefox's Reader View uses.</p><h2>Mozilla Readability</h2><p>Readability analyzes page structure and extracts the main content:</p><pre><code class="language-typescript">// src/services/readability-service.ts<br>
import { JSDOM } from 'jsdom';<br>
import { Readability } from '@mozilla/readability';</p><p>export interface ExtractedContent {<br>
  title: string;<br>
  content: string;        // Clean HTML<br>
  textContent: string;    // Plain text<br>
  excerpt: string | null;<br>
  byline: string | null;<br>
  siteName: string | null;<br>
  length: number;         // Character count<br>
}</p><p>export class ReadabilityService {<br>
  /**<br>
   * Extract article content from URL<br>
   */<br>
  async extract(url: string): Promise&lt;ExtractedContent&gt; {<br>
    // Fetch the page<br>
    const response = await fetch(url, {<br>
      headers: {<br>
        'User-Agent':<br>
          'Mozilla/5.0 (compatible; ReadingLibrary/1.0; +http://localhost)',<br>
        'Accept': 'text/html,application/xhtml+xml',<br>
      },<br>
      signal: AbortSignal.timeout(15000),<br>
    });</p><p>    if (!response.ok) {<br>
      throw new Error(<code>Failed to fetch: ${response.status}</code>);<br>
    }</p><p>    const html = await response.text();<br>
    return this.extractFromHtml(html, url);<br>
  }</p><p>  /**<br>
   * Extract article content from HTML string<br>
   */<br>
  extractFromHtml(html: string, url: string): ExtractedContent {<br>
    // Parse HTML<br>
    const dom = new JSDOM(html, { url });<br>
    const document = dom.window.document;</p><p>    // Run Readability<br>
    const reader = new Readability(document);<br>
    const article = reader.parse();</p><p>    if (!article) {<br>
      throw new Error('Could not extract article content');<br>
    }</p><p>    return {<br>
      title: article.title,<br>
      content: article.content,<br>
      textContent: article.textContent,<br>
      excerpt: article.excerpt,<br>
      byline: article.byline,<br>
      siteName: article.siteName,<br>
      length: article.length,<br>
    };<br>
  }<br>
}</p><p>export const readabilityService = new ReadabilityService();</code></pre><h2>HTML Sanitization</h2><p>Readability output is cleaner than the original page, but still contains HTML you might not want:</p><p>- Inline styles<br>
- Data attributes<br>
- Potentially dangerous elements</p><p>Sanitize before storage:</p><pre><code class="language-typescript">// src/utils/html-cleaner.ts<br>
import sanitizeHtml from 'sanitize-html';</p><p>const ALLOWED_TAGS = [<br>
  // Structure<br>
  'article', 'section', 'div', 'span',<br>
  // Headings<br>
  'h1', 'h2', 'h3', 'h4', 'h5', 'h6',<br>
  // Text<br>
  'p', 'br', 'hr',<br>
  // Formatting<br>
  'strong', 'b', 'em', 'i', 'u', 's', 'mark', 'small',<br>
  'sub', 'sup',<br>
  // Lists<br>
  'ul', 'ol', 'li', 'dl', 'dt', 'dd',<br>
  // Links and media<br>
  'a', 'img', 'figure', 'figcaption',<br>
  // Quotes and code<br>
  'blockquote', 'pre', 'code', 'kbd',<br>
  // Tables<br>
  'table', 'thead', 'tbody', 'tfoot', 'tr', 'th', 'td',<br>
];</p><p>const ALLOWED_ATTRIBUTES: Record&lt;string, string[]&gt; = {<br>
  a: ['href', 'title', 'target', 'rel'],<br>
  img: ['src', 'alt', 'title', 'width', 'height', 'loading'],<br>
  '*': ['id', 'class'],<br>
};</p><p>export function cleanHtml(html: string): string {<br>
  return sanitizeHtml(html, {<br>
    allowedTags: ALLOWED_TAGS,<br>
    allowedAttributes: ALLOWED_ATTRIBUTES,<br>
    allowedSchemes: ['http', 'https', 'mailto'],<br>
    transformTags: {<br>
      // Open links in new tab<br>
      a: (tagName, attribs) =&gt; ({<br>
        tagName,<br>
        attribs: {<br>
          ...attribs,<br>
          target: '_blank',<br>
          rel: 'noopener noreferrer',<br>
        },<br>
      }),<br>
      // Lazy load images<br>
      img: (tagName, attribs) =&gt; ({<br>
        tagName,<br>
        attribs: {<br>
          ...attribs,<br>
          loading: 'lazy',<br>
        },<br>
      }),<br>
    },<br>
  });<br>
}</p><p>/**<br>
 * Extract plain text from HTML<br>
 * Better than Readability's textContent for TTS<br>
 */<br>
export function htmlToText(html: string): string {<br>
  // Remove tags but preserve structure<br>
  let text = html<br>
    // Add newlines for block elements<br>
    .replace(/&lt;\/(p|div|h[1-6]|li|blockquote|br|hr)[^&gt;]*&gt;/gi, '\n')<br>
    .replace(/&lt;(p|div|h[1-6]|li|blockquote|br|hr)[^&gt;]*&gt;/gi, '\n')<br>
    // Remove all other tags<br>
    .replace(/&lt;[^&gt;]+&gt;/g, '')<br>
    // Decode entities<br>
    .replace(/&amp;nbsp;/g, ' ')<br>
    .replace(/&amp;amp;/g, '&amp;')<br>
    .replace(/&amp;lt;/g, '&lt;')<br>
    .replace(/&amp;gt;/g, '&gt;')<br>
    .replace(/&amp;quot;/g, '&quot;')<br>
    .replace(/&amp;#39;/g, &quot;'&quot;)<br>
    // Collapse whitespace<br>
    .replace(/[ \t]+/g, ' ')<br>
    // Collapse multiple newlines<br>
    .replace(/\n{3,}/g, '\n\n')<br>
    .trim();</p><p>  return text;<br>
}</p><p>/**<br>
 * Clean text specifically for TTS<br>
 * Removes elements that sound bad when spoken<br>
 */<br>
export function cleanForTts(text: string): string {<br>
  return text<br>
    // Remove URLs (they sound terrible spoken)<br>
    .replace(/https?:\/\/[^\s]+/g, '')<br>
    // Remove email addresses<br>
    .replace(/[^\s]+@[^\s]+\.[^\s]+/g, '')<br>
    // Remove excessive punctuation<br>
    .replace(/[.]{2,}/g, '.')<br>
    .replace(/[!]{2,}/g, '!')<br>
    .replace(/[?]{2,}/g, '?')<br>
    // Remove code blocks (usually not readable)<br>
    .replace(/</code></pre>[\s\S]*?``<code>/g, '')<br>
    .replace(/</code>[^<code>]+</code>/g, '')<br>
    // Clean up whitespace<br>
    .replace(/\s+/g, ' ')<br>
    .trim();<br>
}<br>
<pre><code class="language-">## The Article Service</p><p>Combining extraction, cleaning, and storage:</code></pre>typescript<br>
// src/services/article-service.ts<br>
import { query, queryOne, execute } from '../db/client.js';<br>
import { readabilityService } from './readability-service.js';<br>
import { cleanHtml, htmlToText } from '../utils/html-cleaner.js';<br>
import type { Article, ArticleWithTags, Tag } from '../types/index.js';</p><p>export class ArticleService {<br>
  /**<br>
   * Ingest an article from URL<br>
   * Returns the article if created, null if already exists<br>
   */<br>
  async ingestArticle(<br>
    url: string,<br>
    feedId?: string<br>
  ): Promise<Article | null> {<br>
    // Normalize URL<br>
    const normalizedUrl = this.normalizeUrl(url);</p><p>    // Check for existing article<br>
    const existing = await queryOne<Article>(<br>
      'SELECT * FROM articles WHERE url = $1',<br>
      [normalizedUrl]<br>
    );</p><p>    if (existing) {<br>
      return null; // Already have this article<br>
    }</p><p>    // Extract content<br>
    const extracted = await readabilityService.extract(normalizedUrl);</p><p>    // Clean HTML and extract text<br>
    const content = cleanHtml(extracted.content);<br>
    const textContent = htmlToText(extracted.content);</p><p>    // Calculate reading time (average 200 words per minute)<br>
    const wordCount = textContent.split(/\s+/).length;<br>
    const readingTimeMinutes = Math.ceil(wordCount / 200);</p><p>    // Insert article<br>
    const article = await queryOne<Article>(<br>
      <code>INSERT INTO articles (<br>
         feed_id, url, title, author, content, text_content,<br>
         excerpt, word_count, reading_time_minutes<br>
       ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)<br>
       RETURNING *</code>,<br>
      [<br>
        feedId ?? null,<br>
        normalizedUrl,<br>
        extracted.title,<br>
        extracted.byline,<br>
        content,<br>
        textContent,<br>
        extracted.excerpt,<br>
        wordCount,<br>
        readingTimeMinutes,<br>
      ]<br>
    );</p><p>    return article;<br>
  }</p><p>  /**<br>
   * Get article by ID with tags<br>
   */<br>
  async getArticle(id: string): Promise<ArticleWithTags | null> {<br>
    const article = await queryOne<Article>(<br>
      'SELECT * FROM articles WHERE id = $1',<br>
      [id]<br>
    );</p><p>    if (!article) return null;</p><p>    const tags = await query<Tag>(<br>
      <code>SELECT t.* FROM tags t<br>
       JOIN article_tags at ON at.tag_id = t.id<br>
       WHERE at.article_id = $1<br>
       ORDER BY t.name</code>,<br>
      [id]<br>
    );</p><p>    return { ...article, tags };<br>
  }</p><p>  /**<br>
   * List articles with pagination and filters<br>
   */<br>
  async listArticles(options: {<br>
    feedId?: string;<br>
    tagId?: string;<br>
    isRead?: boolean;<br>
    isArchived?: boolean;<br>
    isFavorite?: boolean;<br>
    search?: string;<br>
    limit?: number;<br>
    offset?: number;<br>
  } = {}): Promise<{ articles: ArticleWithTags[]; total: number }> {<br>
    const conditions: string[] = [];<br>
    const params: unknown[] = [];<br>
    let paramIndex = 1;</p><p>    // Build WHERE clause<br>
    if (options.feedId) {<br>
      conditions.push(<code>a.feed_id = $${paramIndex++}</code>);<br>
      params.push(options.feedId);<br>
    }</p><p>    if (options.tagId) {<br>
      conditions.push(<br>
        <code>EXISTS (SELECT 1 FROM article_tags at WHERE at.article_id = a.id AND at.tag_id = $${paramIndex++})</code><br>
      );<br>
      params.push(options.tagId);<br>
    }</p><p>    if (options.isRead !== undefined) {<br>
      conditions.push(<code>a.is_read = $${paramIndex++}</code>);<br>
      params.push(options.isRead);<br>
    }</p><p>    if (options.isArchived !== undefined) {<br>
      conditions.push(<code>a.is_archived = $${paramIndex++}</code>);<br>
      params.push(options.isArchived);<br>
    }</p><p>    if (options.isFavorite !== undefined) {<br>
      conditions.push(<code>a.is_favorite = $${paramIndex++}</code>);<br>
      params.push(options.isFavorite);<br>
    }</p><p>    if (options.search) {<br>
      conditions.push(<br>
        <code>to_tsvector('english', a.title || ' ' || a.text_content) @@ plainto_tsquery('english', $${paramIndex++})</code><br>
      );<br>
      params.push(options.search);<br>
    }</p><p>    const whereClause =<br>
      conditions.length > 0 ? <code>WHERE ${conditions.join(' AND ')}</code> : '';</p><p>    // Get total count<br>
    const countResult = await queryOne<{ count: string }>(<br>
      <code>SELECT COUNT(*)::text as count FROM articles a ${whereClause}</code>,<br>
      params<br>
    );<br>
    const total = parseInt(countResult?.count ?? '0', 10);</p><p>    // Get articles with pagination<br>
    const limit = options.limit ?? 50;<br>
    const offset = options.offset ?? 0;</p><p>    const articles = await query<Article>(<br>
      <code>SELECT a.* FROM articles a<br>
       ${whereClause}<br>
       ORDER BY a.created_at DESC<br>
       LIMIT $${paramIndex++} OFFSET $${paramIndex++}</code>,<br>
      [...params, limit, offset]<br>
    );</p><p>    // Get tags for all articles<br>
    const articleIds = articles.map((a) => a.id);</p><p>    if (articleIds.length === 0) {<br>
      return { articles: [], total };<br>
    }</p><p>    const tagRows = await query<{ article_id: string } & Tag>(<br>
      <code>SELECT at.article_id, t.*<br>
       FROM tags t<br>
       JOIN article_tags at ON at.tag_id = t.id<br>
       WHERE at.article_id = ANY($1)<br>
       ORDER BY t.name</code>,<br>
      [articleIds]<br>
    );</p><p>    // Group tags by article<br>
    const tagsByArticle = new Map<string, Tag[]>();<br>
    for (const row of tagRows) {<br>
      const { article_id, ...tag } = row;<br>
      if (!tagsByArticle.has(article_id)) {<br>
        tagsByArticle.set(article_id, []);<br>
      }<br>
      tagsByArticle.get(article_id)!.push(tag);<br>
    }</p><p>    const articlesWithTags: ArticleWithTags[] = articles.map((article) => ({<br>
      ...article,<br>
      tags: tagsByArticle.get(article.id) ?? [],<br>
    }));</p><p>    return { articles: articlesWithTags, total };<br>
  }</p><p>  /**<br>
   * Update article properties<br>
   */<br>
  async updateArticle(<br>
    id: string,<br>
    updates: {<br>
      isRead?: boolean;<br>
      isArchived?: boolean;<br>
      isFavorite?: boolean;<br>
    }<br>
  ): Promise<Article | null> {<br>
    const setClauses: string[] = [];<br>
    const params: unknown[] = [];<br>
    let paramIndex = 1;</p><p>    if (updates.isRead !== undefined) {<br>
      setClauses.push(<code>is_read = $${paramIndex++}</code>);<br>
      params.push(updates.isRead);<br>
    }</p><p>    if (updates.isArchived !== undefined) {<br>
      setClauses.push(<code>is_archived = $${paramIndex++}</code>);<br>
      params.push(updates.isArchived);<br>
    }</p><p>    if (updates.isFavorite !== undefined) {<br>
      setClauses.push(<code>is_favorite = $${paramIndex++}</code>);<br>
      params.push(updates.isFavorite);<br>
    }</p><p>    if (setClauses.length === 0) {<br>
      return this.getArticle(id);<br>
    }</p><p>    setClauses.push('updated_at = NOW()');<br>
    params.push(id);</p><p>    return queryOne<Article>(<br>
      <code>UPDATE articles<br>
       SET ${setClauses.join(', ')}<br>
       WHERE id = $${paramIndex}<br>
       RETURNING *</code>,<br>
      params<br>
    );<br>
  }</p><p>  /**<br>
   * Add tags to article<br>
   */<br>
  async addTags(articleId: string, tagIds: string[]): Promise<void> {<br>
    for (const tagId of tagIds) {<br>
      await execute(<br>
        <code>INSERT INTO article_tags (article_id, tag_id)<br>
         VALUES ($1, $2)<br>
         ON CONFLICT DO NOTHING</code>,<br>
        [articleId, tagId]<br>
      );<br>
    }<br>
  }</p><p>  /**<br>
   * Remove tags from article<br>
   */<br>
  async removeTags(articleId: string, tagIds: string[]): Promise<void> {<br>
    await execute(<br>
      <code>DELETE FROM article_tags<br>
       WHERE article_id = $1 AND tag_id = ANY($2)</code>,<br>
      [articleId, tagIds]<br>
    );<br>
  }</p><p>  /**<br>
   * Delete article permanently<br>
   */<br>
  async deleteArticle(id: string): Promise<void> {<br>
    await execute('DELETE FROM articles WHERE id = $1', [id]);<br>
  }</p><p>  private normalizeUrl(url: string): string {<br>
    const parsed = new URL(url);<br>
    // Remove tracking parameters<br>
    const cleanParams = ['utm_source', 'utm_medium', 'utm_campaign', 'ref'];<br>
    for (const param of cleanParams) {<br>
      parsed.searchParams.delete(param);<br>
    }<br>
    return parsed.href;<br>
  }<br>
}</p><p>export const articleService = new ArticleService();<br>
<pre><code class="language-">## Content Deduplication</p><p>Duplicate detection beyond URL matching:</code></pre>typescript<br>
// src/services/deduplication-service.ts<br>
import { query, queryOne } from '../db/client.js';<br>
import type { Article } from '../types/index.js';</p><p>export class DeduplicationService {<br>
  /**<br>
   * Check if similar article already exists<br>
   */<br>
  async findSimilar(<br>
    title: string,<br>
    textContent: string<br>
  ): Promise<Article | null> {<br>
    // First, check for exact title match<br>
    const exactMatch = await queryOne<Article>(<br>
      <code>SELECT * FROM articles<br>
       WHERE LOWER(title) = LOWER($1)<br>
       LIMIT 1</code>,<br>
      [title]<br>
    );</p><p>    if (exactMatch) {<br>
      return exactMatch;<br>
    }</p><p>    // Check for similar content using trigram similarity<br>
    // Requires pg_trgm extension<br>
    const similarContent = await queryOne<Article>(<br>
      <code>SELECT *,<br>
              similarity(text_content, $1) as sim<br>
       FROM articles<br>
       WHERE similarity(text_content, $1) > 0.7<br>
       ORDER BY sim DESC<br>
       LIMIT 1</code>,<br>
      [textContent.slice(0, 10000)] // First 10k chars for comparison<br>
    );</p><p>    return similarContent;<br>
  }</p><p>  /**<br>
   * Generate content fingerprint for deduplication<br>
   */<br>
  generateFingerprint(text: string): string {<br>
    // Simple approach: hash of normalized text<br>
    const normalized = text<br>
      .toLowerCase()<br>
      .replace(/\s+/g, ' ')<br>
      .replace(/[^\w\s]/g, '')<br>
      .trim();</p><p>    // Use first 1000 chars for fingerprint<br>
    const sample = normalized.slice(0, 1000);</p><p>    // Simple hash (for production, use crypto.createHash)<br>
    let hash = 0;<br>
    for (let i = 0; i < sample.length; i++) {<br>
      const char = sample.charCodeAt(i);<br>
      hash = (hash << 5) - hash + char;<br>
      hash = hash & hash; // Convert to 32bit integer<br>
    }</p><p>    return hash.toString(16);<br>
  }<br>
}</p><p>export const deduplicationService = new DeduplicationService();<br>
<pre><code class="language-">## Article API Routes</code></pre>typescript<br>
// src/api/routes/articles.ts<br>
import { Router } from 'express';<br>
import { articleService } from '../../services/article-service.js';<br>
import { AppError } from '../middleware/error.js';</p><p>export const articlesRouter = Router();</p><p>// List articles<br>
articlesRouter.get('/', async (req, res, next) => {<br>
  try {<br>
    const {<br>
      feedId,<br>
      tagId,<br>
      isRead,<br>
      isArchived,<br>
      isFavorite,<br>
      search,<br>
      limit,<br>
      offset,<br>
    } = req.query;</p><p>    const result = await articleService.listArticles({<br>
      feedId: feedId as string | undefined,<br>
      tagId: tagId as string | undefined,<br>
      isRead: isRead === 'true' ? true : isRead === 'false' ? false : undefined,<br>
      isArchived:<br>
        isArchived === 'true' ? true : isArchived === 'false' ? false : undefined,<br>
      isFavorite:<br>
        isFavorite === 'true' ? true : isFavorite === 'false' ? false : undefined,<br>
      search: search as string | undefined,<br>
      limit: limit ? parseInt(limit as string, 10) : undefined,<br>
      offset: offset ? parseInt(offset as string, 10) : undefined,<br>
    });</p><p>    res.json(result);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Add article from URL<br>
articlesRouter.post('/', async (req, res, next) => {<br>
  try {<br>
    const { url, feedId } = req.body as { url?: string; feedId?: string };</p><p>    if (!url) {<br>
      throw new AppError(400, 'URL is required', 'MISSING_URL');<br>
    }</p><p>    const article = await articleService.ingestArticle(url, feedId);</p><p>    if (!article) {<br>
      throw new AppError(409, 'Article already exists', 'DUPLICATE_ARTICLE');<br>
    }</p><p>    res.status(201).json(article);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Get single article<br>
articlesRouter.get('/:id', async (req, res, next) => {<br>
  try {<br>
    const article = await articleService.getArticle(req.params.id);</p><p>    if (!article) {<br>
      throw new AppError(404, 'Article not found', 'ARTICLE_NOT_FOUND');<br>
    }</p><p>    res.json(article);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Update article<br>
articlesRouter.patch('/:id', async (req, res, next) => {<br>
  try {<br>
    const { isRead, isArchived, isFavorite } = req.body;</p><p>    const article = await articleService.updateArticle(req.params.id, {<br>
      isRead,<br>
      isArchived,<br>
      isFavorite,<br>
    });</p><p>    if (!article) {<br>
      throw new AppError(404, 'Article not found', 'ARTICLE_NOT_FOUND');<br>
    }</p><p>    res.json(article);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Mark as read<br>
articlesRouter.post('/:id/read', async (req, res, next) => {<br>
  try {<br>
    const article = await articleService.updateArticle(req.params.id, {<br>
      isRead: true,<br>
    });</p><p>    if (!article) {<br>
      throw new AppError(404, 'Article not found', 'ARTICLE_NOT_FOUND');<br>
    }</p><p>    res.json(article);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Toggle favorite<br>
articlesRouter.post('/:id/favorite', async (req, res, next) => {<br>
  try {<br>
    const current = await articleService.getArticle(req.params.id);</p><p>    if (!current) {<br>
      throw new AppError(404, 'Article not found', 'ARTICLE_NOT_FOUND');<br>
    }</p><p>    const article = await articleService.updateArticle(req.params.id, {<br>
      isFavorite: !current.isFavorite,<br>
    });</p><p>    res.json(article);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Archive article<br>
articlesRouter.post('/:id/archive', async (req, res, next) => {<br>
  try {<br>
    const article = await articleService.updateArticle(req.params.id, {<br>
      isArchived: true,<br>
    });</p><p>    if (!article) {<br>
      throw new AppError(404, 'Article not found', 'ARTICLE_NOT_FOUND');<br>
    }</p><p>    res.json(article);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Manage tags<br>
articlesRouter.post('/:id/tags', async (req, res, next) => {<br>
  try {<br>
    const { tagIds } = req.body as { tagIds?: string[] };</p><p>    if (!tagIds || !Array.isArray(tagIds)) {<br>
      throw new AppError(400, 'tagIds array required', 'MISSING_TAG_IDS');<br>
    }</p><p>    await articleService.addTags(req.params.id, tagIds);<br>
    const article = await articleService.getArticle(req.params.id);</p><p>    res.json(article);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>articlesRouter.delete('/:id/tags', async (req, res, next) => {<br>
  try {<br>
    const { tagIds } = req.body as { tagIds?: string[] };</p><p>    if (!tagIds || !Array.isArray(tagIds)) {<br>
      throw new AppError(400, 'tagIds array required', 'MISSING_TAG_IDS');<br>
    }</p><p>    await articleService.removeTags(req.params.id, tagIds);<br>
    const article = await articleService.getArticle(req.params.id);</p><p>    res.json(article);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Delete article<br>
articlesRouter.delete('/:id', async (req, res, next) => {<br>
  try {<br>
    await articleService.deleteArticle(req.params.id);<br>
    res.status(204).send();<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});<br>
<pre><code class="language-">## Handling Edge Cases</p><p>Real-world content extraction faces many challenges:</code></pre>typescript<br>
// src/services/readability-service.ts (extended)</p><p>export class ReadabilityService {<br>
  // ... previous methods ...</p><p>  /**<br>
   * Handle sites that need special treatment<br>
   */<br>
  async extractWithFallbacks(url: string): Promise<ExtractedContent> {<br>
    const hostname = new URL(url).hostname;</p><p>    // Substack-specific handling<br>
    if (hostname.includes('substack.com')) {<br>
      return this.extractSubstack(url);<br>
    }</p><p>    // Medium-specific handling<br>
    if (hostname.includes('medium.com')) {<br>
      return this.extractMedium(url);<br>
    }</p><p>    // Default extraction<br>
    try {<br>
      return await this.extract(url);<br>
    } catch (error) {<br>
      // Try with different headers (some sites block bots)<br>
      return this.extractWithBrowserHeaders(url);<br>
    }<br>
  }</p><p>  private async extractSubstack(url: string): Promise<ExtractedContent> {<br>
    // Substack serves clean content if you request the right format<br>
    const response = await fetch(url, {<br>
      headers: {<br>
        'User-Agent':<br>
          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',<br>
        Accept: 'text/html',<br>
      },<br>
    });</p><p>    const html = await response.text();<br>
    return this.extractFromHtml(html, url);<br>
  }</p><p>  private async extractMedium(url: string): Promise<ExtractedContent> {<br>
    // Medium requires specific handling due to their paywall<br>
    // This works for free articles<br>
    const response = await fetch(url, {<br>
      headers: {<br>
        'User-Agent':<br>
          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',<br>
        Accept: 'text/html',<br>
        // Don't send cookies to avoid metered paywall<br>
      },<br>
      credentials: 'omit',<br>
    });</p><p>    const html = await response.text();<br>
    return this.extractFromHtml(html, url);<br>
  }</p><p>  private async extractWithBrowserHeaders(<br>
    url: string<br>
  ): Promise<ExtractedContent> {<br>
    const response = await fetch(url, {<br>
      headers: {<br>
        'User-Agent':<br>
          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',<br>
        Accept:<br>
          'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<em>/</em>;q=0.8',<br>
        'Accept-Language': 'en-US,en;q=0.5',<br>
        'Accept-Encoding': 'gzip, deflate, br',<br>
        Connection: 'keep-alive',<br>
        'Upgrade-Insecure-Requests': '1',<br>
      },<br>
    });</p><p>    const html = await response.text();<br>
    return this.extractFromHtml(html, url);<br>
  }<br>
}<br>
<pre><code class="language-">## Metadata Extraction</p><p>Extract additional metadata beyond Readability:</code></pre>typescript<br>
// src/utils/metadata-extractor.ts<br>
import { JSDOM } from 'jsdom';</p><p>export interface ArticleMetadata {<br>
  title: string | null;<br>
  description: string | null;<br>
  author: string | null;<br>
  publishedAt: Date | null;<br>
  imageUrl: string | null;<br>
  siteName: string | null;<br>
  canonicalUrl: string | null;<br>
}</p><p>export function extractMetadata(html: string, url: string): ArticleMetadata {<br>
  const dom = new JSDOM(html, { url });<br>
  const document = dom.window.document;</p><p>  return {<br>
    title: getMetaContent(document, [<br>
      'og:title',<br>
      'twitter:title',<br>
      'title',<br>
    ]) ?? document.title ?? null,</p><p>    description: getMetaContent(document, [<br>
      'og:description',<br>
      'twitter:description',<br>
      'description',<br>
    ]),</p><p>    author: getMetaContent(document, [<br>
      'author',<br>
      'article:author',<br>
      'twitter:creator',<br>
    ]) ?? getJsonLdAuthor(document),</p><p>    publishedAt: parsePublishedDate(document),</p><p>    imageUrl: getMetaContent(document, [<br>
      'og:image',<br>
      'twitter:image',<br>
      'twitter:image:src',<br>
    ]),</p><p>    siteName: getMetaContent(document, ['og:site_name']),</p><p>    canonicalUrl:<br>
      document.querySelector('link[rel="canonical"]')?.getAttribute('href') ??<br>
      null,<br>
  };<br>
}</p><p>function getMetaContent(<br>
  document: Document,<br>
  names: string[]<br>
): string | null {<br>
  for (const name of names) {<br>
    // Try name attribute<br>
    const byName = document.querySelector(<code>meta[name="${name}"]</code>);<br>
    if (byName) {<br>
      return byName.getAttribute('content');<br>
    }</p><p>    // Try property attribute (OpenGraph)<br>
    const byProperty = document.querySelector(<code>meta[property="${name}"]</code>);<br>
    if (byProperty) {<br>
      return byProperty.getAttribute('content');<br>
    }<br>
  }<br>
  return null;<br>
}</p><p>function getJsonLdAuthor(document: Document): string | null {<br>
  const scripts = document.querySelectorAll('script[type="application/ld+json"]');</p><p>  for (const script of scripts) {<br>
    try {<br>
      const data = JSON.parse(script.textContent ?? '');</p><p>      if (data.author) {<br>
        if (typeof data.author === 'string') {<br>
          return data.author;<br>
        }<br>
        if (data.author.name) {<br>
          return data.author.name;<br>
        }<br>
      }<br>
    } catch {<br>
      // Invalid JSON, continue<br>
    }<br>
  }</p><p>  return null;<br>
}</p><p>function parsePublishedDate(document: Document): Date | null {<br>
  // Try meta tags<br>
  const dateStr = getMetaContent(document, [<br>
    'article:published_time',<br>
    'datePublished',<br>
    'date',<br>
    'DC.date.issued',<br>
  ]);</p><p>  if (dateStr) {<br>
    const date = new Date(dateStr);<br>
    if (!isNaN(date.getTime())) {<br>
      return date;<br>
    }<br>
  }</p><p>  // Try JSON-LD<br>
  const scripts = document.querySelectorAll('script[type="application/ld+json"]');</p><p>  for (const script of scripts) {<br>
    try {<br>
      const data = JSON.parse(script.textContent ?? '');</p><p>      if (data.datePublished) {<br>
        const date = new Date(data.datePublished);<br>
        if (!isNaN(date.getTime())) {<br>
          return date;<br>
        }<br>
      }<br>
    } catch {<br>
      // Invalid JSON, continue<br>
    }<br>
  }</p><p>  // Try time element<br>
  const time = document.querySelector('time[datetime]');<br>
  if (time) {<br>
    const datetime = time.getAttribute('datetime');<br>
    if (datetime) {<br>
      const date = new Date(datetime);<br>
      if (!isNaN(date.getTime())) {<br>
        return date;<br>
      }<br>
    }<br>
  }</p><p>  return null;<br>
}<br>
```</p><h2>Next Steps</h2><p>With content ingestion working, we can now build the reader interface—displaying articles with clean typography, dark mode, and reading progress tracking.<br>
</p>
    </section>
  

    <section id="chapter-4" class="chapter">
      <h2>Building the Reader Interface</h2>
      <h2>Typography for Reading</h2><p>Good reading typography is invisible. Bad typography causes eyestrain, fatigue, and abandonment. The difference is attention to detail.</p><h3>Font Selection</h3><p>For long-form reading, serif fonts outperform sans-serif. The serifs guide the eye along the baseline, reducing cognitive load. But the web complicates this—system fonts vary wildly.</p><p>A safe approach: use a font stack that degrades gracefully.</p><pre><code class="language-css">/<em> styles/reader.css </em>/</p><p>:root {<br>
  /<em> Reading fonts </em>/<br>
  --font-serif: 'Charter', 'Bitstream Charter', 'Sitka Text', Cambria,<br>
    'Noto Serif', serif;<br>
  --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,<br>
    'Helvetica Neue', Arial, sans-serif;<br>
  --font-mono: 'SF Mono', SFMono-Regular, ui-monospace, 'DejaVu Sans Mono',<br>
    Menlo, Consolas, monospace;</p><p>  /<em> Spacing scale </em>/<br>
  --space-1: 0.25rem;<br>
  --space-2: 0.5rem;<br>
  --space-3: 0.75rem;<br>
  --space-4: 1rem;<br>
  --space-6: 1.5rem;<br>
  --space-8: 2rem;<br>
  --space-12: 3rem;</p><p>  /<em> Colors - light mode </em>/<br>
  --color-bg: #fdfcfa;<br>
  --color-bg-secondary: #f5f3f0;<br>
  --color-text: #1a1a1a;<br>
  --color-text-secondary: #666666;<br>
  --color-border: #e5e5e5;<br>
  --color-link: #0066cc;<br>
  --color-link-visited: #551a8b;<br>
  --color-highlight: #fff3cd;<br>
}</p><p>/<em> Dark mode </em>/<br>
@media (prefers-color-scheme: dark) {<br>
  :root {<br>
    --color-bg: #1a1a1a;<br>
    --color-bg-secondary: #2a2a2a;<br>
    --color-text: #e5e5e5;<br>
    --color-text-secondary: #999999;<br>
    --color-border: #404040;<br>
    --color-link: #6db3f2;<br>
    --color-link-visited: #b794f4;<br>
    --color-highlight: #4a4520;<br>
  }<br>
}</p><p>/<em> Manual dark mode toggle </em>/<br>
[data-theme='dark'] {<br>
  --color-bg: #1a1a1a;<br>
  --color-bg-secondary: #2a2a2a;<br>
  --color-text: #e5e5e5;<br>
  --color-text-secondary: #999999;<br>
  --color-border: #404040;<br>
  --color-link: #6db3f2;<br>
  --color-link-visited: #b794f4;<br>
  --color-highlight: #4a4520;<br>
}</p><p>[data-theme='light'] {<br>
  --color-bg: #fdfcfa;<br>
  --color-bg-secondary: #f5f3f0;<br>
  --color-text: #1a1a1a;<br>
  --color-text-secondary: #666666;<br>
  --color-border: #e5e5e5;<br>
  --color-link: #0066cc;<br>
  --color-link-visited: #551a8b;<br>
  --color-highlight: #fff3cd;<br>
}</code></pre><h3>Line Length and Spacing</h3><p>The optimal line length for reading is 50-75 characters. Too short causes excessive eye movement. Too long causes readers to lose their place.</p><pre><code class="language-css">/<em> Reader container </em>/<br>
.reader {<br>
  max-width: 65ch;<br>
  margin: 0 auto;<br>
  padding: var(--space-4);<br>
  background: var(--color-bg);<br>
  color: var(--color-text);<br>
}</p><p>/<em> Typography </em>/<br>
.reader-content {<br>
  font-family: var(--font-serif);<br>
  font-size: 1.125rem; /<em> 18px base </em>/<br>
  line-height: 1.7;<br>
  letter-spacing: -0.003em;<br>
}</p><p>.reader-content p {<br>
  margin-bottom: var(--space-4);<br>
}</p><p>.reader-content h1,<br>
.reader-content h2,<br>
.reader-content h3,<br>
.reader-content h4 {<br>
  font-family: var(--font-sans);<br>
  font-weight: 600;<br>
  line-height: 1.3;<br>
  margin-top: var(--space-8);<br>
  margin-bottom: var(--space-4);<br>
}</p><p>.reader-content h1 {<br>
  font-size: 2rem;<br>
}</p><p>.reader-content h2 {<br>
  font-size: 1.5rem;<br>
}</p><p>.reader-content h3 {<br>
  font-size: 1.25rem;<br>
}</p><p>/<em> Links </em>/<br>
.reader-content a {<br>
  color: var(--color-link);<br>
  text-decoration: underline;<br>
  text-decoration-thickness: 1px;<br>
  text-underline-offset: 2px;<br>
}</p><p>.reader-content a:visited {<br>
  color: var(--color-link-visited);<br>
}</p><p>.reader-content a:hover {<br>
  text-decoration-thickness: 2px;<br>
}</p><p>/<em> Code </em>/<br>
.reader-content code {<br>
  font-family: var(--font-mono);<br>
  font-size: 0.9em;<br>
  background: var(--color-bg-secondary);<br>
  padding: 0.1em 0.3em;<br>
  border-radius: 3px;<br>
}</p><p>.reader-content pre {<br>
  background: var(--color-bg-secondary);<br>
  padding: var(--space-4);<br>
  border-radius: 6px;<br>
  overflow-x: auto;<br>
  margin: var(--space-6) 0;<br>
}</p><p>.reader-content pre code {<br>
  background: none;<br>
  padding: 0;<br>
}</p><p>/<em> Blockquotes </em>/<br>
.reader-content blockquote {<br>
  border-left: 3px solid var(--color-border);<br>
  padding-left: var(--space-4);<br>
  margin-left: 0;<br>
  font-style: italic;<br>
  color: var(--color-text-secondary);<br>
}</p><p>/<em> Lists </em>/<br>
.reader-content ul,<br>
.reader-content ol {<br>
  padding-left: var(--space-6);<br>
  margin-bottom: var(--space-4);<br>
}</p><p>.reader-content li {<br>
  margin-bottom: var(--space-2);<br>
}</p><p>/<em> Images </em>/<br>
.reader-content img {<br>
  max-width: 100%;<br>
  height: auto;<br>
  border-radius: 6px;<br>
  margin: var(--space-6) 0;<br>
}</p><p>.reader-content figure {<br>
  margin: var(--space-6) 0;<br>
}</p><p>.reader-content figcaption {<br>
  font-size: 0.875rem;<br>
  color: var(--color-text-secondary);<br>
  text-align: center;<br>
  margin-top: var(--space-2);<br>
}</code></pre><h2>Reader Component</h2><pre><code class="language-typescript">// web/src/components/Reader.ts</p><p>interface ReaderOptions {<br>
  articleId: string;<br>
  onProgressUpdate?: (progress: number) =&gt; void;<br>
}</p><p>export class Reader {<br>
  private container: HTMLElement;<br>
  private article: Article | null = null;<br>
  private options: ReaderOptions;<br>
  private scrollObserver: IntersectionObserver | null = null;</p><p>  constructor(containerId: string, options: ReaderOptions) {<br>
    const container = document.getElementById(containerId);<br>
    if (!container) throw new Error('Container not found');<br>
    this.container = container;<br>
    this.options = options;</p><p>    this.load();<br>
  }</p><p>  private async load(): Promise&lt;void&gt; {<br>
    this.container.innerHTML = '&lt;div class=&quot;reader-loading&quot;&gt;Loading...&lt;/div&gt;';</p><p>    try {<br>
      const response = await fetch(<code>/api/articles/${this.options.articleId}</code>);<br>
      if (!response.ok) throw new Error('Failed to load article');</p><p>      this.article = await response.json();<br>
      this.render();<br>
      this.setupScrollTracking();<br>
      this.restoreProgress();<br>
    } catch (error) {<br>
      this.container.innerHTML = <code><br>
        &lt;div class=&quot;reader-error&quot;&gt;<br>
          Failed to load article. &lt;button onclick=&quot;location.reload()&quot;&gt;Retry&lt;/button&gt;<br>
        &lt;/div&gt;<br>
      </code>;<br>
    }<br>
  }</p><p>  private render(): void {<br>
    if (!this.article) return;</p><p>    const readingTime = this.article.readingTimeMinutes;<br>
    const readingTimeText =<br>
      readingTime === 1 ? '1 min read' : <code>${readingTime} min read</code>;</p><p>    this.container.innerHTML = <code><br>
      &lt;article class=&quot;reader&quot;&gt;<br>
        &lt;header class=&quot;reader-header&quot;&gt;<br>
          &lt;h1 class=&quot;reader-title&quot;&gt;${this.escapeHtml(this.article.title)}&lt;/h1&gt;<br>
          &lt;div class=&quot;reader-meta&quot;&gt;<br>
            ${this.article.author ? </code>&lt;span class=&quot;reader-author&quot;&gt;${this.escapeHtml(this.article.author)}&lt;/span&gt;<code> : ''}<br>
            ${this.article.publishedAt ? </code>&lt;time datetime=&quot;${this.article.publishedAt}&quot;&gt;${this.formatDate(this.article.publishedAt)}&lt;/time&gt;<code> : ''}<br>
            &lt;span class=&quot;reader-reading-time&quot;&gt;${readingTimeText}&lt;/span&gt;<br>
          &lt;/div&gt;<br>
        &lt;/header&gt;</p><p>        &lt;div class=&quot;reader-progress&quot;&gt;<br>
          &lt;div class=&quot;reader-progress-bar&quot;&gt;&lt;/div&gt;<br>
        &lt;/div&gt;</p><p>        &lt;div class=&quot;reader-content&quot;&gt;<br>
          ${this.article.content}<br>
        &lt;/div&gt;</p><p>        &lt;footer class=&quot;reader-footer&quot;&gt;<br>
          &lt;div class=&quot;reader-actions&quot;&gt;<br>
            &lt;button class=&quot;action-favorite ${this.article.isFavorite ? 'active' : ''}&quot;<br>
                    data-action=&quot;favorite&quot;&gt;<br>
              ${this.article.isFavorite ? '★' : '☆'} Favorite<br>
            &lt;/button&gt;<br>
            &lt;button class=&quot;action-archive&quot; data-action=&quot;archive&quot;&gt;<br>
              Archive<br>
            &lt;/button&gt;<br>
            &lt;a href=&quot;${this.escapeHtml(this.article.url)}&quot;<br>
               target=&quot;_blank&quot; rel=&quot;noopener&quot;<br>
               class=&quot;action-original&quot;&gt;<br>
              View Original<br>
            &lt;/a&gt;<br>
          &lt;/div&gt;<br>
        &lt;/footer&gt;<br>
      &lt;/article&gt;<br>
    </code>;</p><p>    this.setupEventListeners();<br>
  }</p><p>  private setupEventListeners(): void {<br>
    // Action buttons<br>
    this.container.querySelectorAll('[data-action]').forEach((btn) =&gt; {<br>
      btn.addEventListener('click', (e) =&gt; {<br>
        const action = (e.currentTarget as HTMLElement).dataset.action;<br>
        if (action === 'favorite') this.toggleFavorite();<br>
        if (action === 'archive') this.archive();<br>
      });<br>
    });<br>
  }</p><p>  private setupScrollTracking(): void {<br>
    // Track reading progress via scroll position<br>
    const content = this.container.querySelector('.reader-content');<br>
    if (!content) return;</p><p>    const progressBar = this.container.querySelector(<br>
      '.reader-progress-bar'<br>
    ) as HTMLElement;</p><p>    const updateProgress = () =&gt; {<br>
      const scrollTop = window.scrollY;<br>
      const docHeight = document.documentElement.scrollHeight;<br>
      const winHeight = window.innerHeight;<br>
      const scrollPercent = scrollTop / (docHeight - winHeight);<br>
      const progress = Math.min(Math.max(scrollPercent, 0), 1);</p><p>      if (progressBar) {<br>
        progressBar.style.width = <code>${progress * 100}%</code>;<br>
      }</p><p>      // Debounced save<br>
      this.saveProgress(progress);</p><p>      // Notify callback<br>
      this.options.onProgressUpdate?.(progress);<br>
    };</p><p>    window.addEventListener('scroll', updateProgress, { passive: true });<br>
    updateProgress();<br>
  }</p><p>  private saveProgressTimeout: number | null = null;</p><p>  private saveProgress(progress: number): void {<br>
    if (this.saveProgressTimeout) {<br>
      clearTimeout(this.saveProgressTimeout);<br>
    }</p><p>    this.saveProgressTimeout = window.setTimeout(async () =&gt; {<br>
      if (!this.article) return;</p><p>      await fetch(<code>/api/articles/${this.article.id}/progress</code>, {<br>
        method: 'PUT',<br>
        headers: { 'Content-Type': 'application/json' },<br>
        body: JSON.stringify({ scrollPosition: progress }),<br>
      });</p><p>      // Mark as read when 90% scrolled<br>
      if (progress &gt; 0.9 &amp;&amp; !this.article.isRead) {<br>
        await fetch(<code>/api/articles/${this.article.id}/read</code>, {<br>
          method: 'POST',<br>
        });<br>
        this.article.isRead = true;<br>
      }<br>
    }, 1000);<br>
  }</p><p>  private async restoreProgress(): Promise&lt;void&gt; {<br>
    if (!this.article) return;</p><p>    try {<br>
      const response = await fetch(<br>
        <code>/api/articles/${this.article.id}/progress</code><br>
      );<br>
      if (!response.ok) return;</p><p>      const progress = await response.json();<br>
      if (progress.scrollPosition &gt; 0.05) {<br>
        // Scroll to saved position<br>
        const docHeight = document.documentElement.scrollHeight;<br>
        const winHeight = window.innerHeight;<br>
        const scrollTo = progress.scrollPosition * (docHeight - winHeight);</p><p>        window.scrollTo({ top: scrollTo, behavior: 'instant' });<br>
      }<br>
    } catch {<br>
      // Ignore errors<br>
    }<br>
  }</p><p>  private async toggleFavorite(): Promise&lt;void&gt; {<br>
    if (!this.article) return;</p><p>    const response = await fetch(<code>/api/articles/${this.article.id}/favorite</code>, {<br>
      method: 'POST',<br>
    });</p><p>    if (response.ok) {<br>
      this.article = await response.json();<br>
      const btn = this.container.querySelector('.action-favorite');<br>
      if (btn) {<br>
        btn.classList.toggle('active', this.article.isFavorite);<br>
        btn.innerHTML = <code>${this.article.isFavorite ? '★' : '☆'} Favorite</code>;<br>
      }<br>
    }<br>
  }</p><p>  private async archive(): Promise&lt;void&gt; {<br>
    if (!this.article) return;</p><p>    const response = await fetch(<code>/api/articles/${this.article.id}/archive</code>, {<br>
      method: 'POST',<br>
    });</p><p>    if (response.ok) {<br>
      // Navigate back to list<br>
      window.history.back();<br>
    }<br>
  }</p><p>  private formatDate(dateStr: string): string {<br>
    const date = new Date(dateStr);<br>
    return date.toLocaleDateString('en-US', {<br>
      year: 'numeric',<br>
      month: 'short',<br>
      day: 'numeric',<br>
    });<br>
  }</p><p>  private escapeHtml(str: string): string {<br>
    const div = document.createElement('div');<br>
    div.textContent = str;<br>
    return div.innerHTML;<br>
  }<br>
}</code></pre><h2>Reading Progress API</h2><pre><code class="language-typescript">// src/api/routes/progress.ts<br>
import { Router } from 'express';<br>
import { query, queryOne, execute } from '../../db/client.js';<br>
import type { ReadingProgress } from '../../types/index.js';</p><p>export const progressRouter = Router();</p><p>// Get progress for article<br>
progressRouter.get('/:articleId/progress', async (req, res, next) =&gt; {<br>
  try {<br>
    const progress = await queryOne&lt;ReadingProgress&gt;(<br>
      <code>SELECT * FROM reading_progress WHERE article_id = $1</code>,<br>
      [req.params.articleId]<br>
    );</p><p>    if (!progress) {<br>
      res.json({ scrollPosition: 0, audioPosition: 0 });<br>
      return;<br>
    }</p><p>    res.json(progress);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Update progress<br>
progressRouter.put('/:articleId/progress', async (req, res, next) =&gt; {<br>
  try {<br>
    const { scrollPosition, audioPosition } = req.body;</p><p>    const progress = await queryOne&lt;ReadingProgress&gt;(<br>
      <code>INSERT INTO reading_progress (article_id, scroll_position, audio_position, last_read_at)<br>
       VALUES ($1, COALESCE($2, 0), COALESCE($3, 0), NOW())<br>
       ON CONFLICT (article_id) DO UPDATE SET<br>
         scroll_position = COALESCE($2, reading_progress.scroll_position),<br>
         audio_position = COALESCE($3, reading_progress.audio_position),<br>
         last_read_at = NOW()<br>
       RETURNING *</code>,<br>
      [req.params.articleId, scrollPosition, audioPosition]<br>
    );</p><p>    res.json(progress);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</code></pre><h2>Article List Component</h2><pre><code class="language-typescript">// web/src/components/ArticleList.ts</p><p>interface ArticleListOptions {<br>
  feedId?: string;<br>
  tagId?: string;<br>
  showUnreadOnly?: boolean;<br>
}</p><p>export class ArticleList {<br>
  private container: HTMLElement;<br>
  private options: ArticleListOptions;<br>
  private articles: Article[] = [];<br>
  private total = 0;<br>
  private page = 0;<br>
  private pageSize = 20;<br>
  private loading = false;</p><p>  constructor(containerId: string, options: ArticleListOptions = {}) {<br>
    const container = document.getElementById(containerId);<br>
    if (!container) throw new Error('Container not found');<br>
    this.container = container;<br>
    this.options = options;</p><p>    this.render();<br>
    this.loadArticles();<br>
    this.setupInfiniteScroll();<br>
  }</p><p>  private render(): void {<br>
    this.container.innerHTML = <code><br>
      &lt;div class=&quot;article-list&quot;&gt;<br>
        &lt;header class=&quot;list-header&quot;&gt;<br>
          &lt;div class=&quot;list-filters&quot;&gt;<br>
            &lt;button class=&quot;filter-btn active&quot; data-filter=&quot;unread&quot;&gt;Unread&lt;/button&gt;<br>
            &lt;button class=&quot;filter-btn&quot; data-filter=&quot;all&quot;&gt;All&lt;/button&gt;<br>
            &lt;button class=&quot;filter-btn&quot; data-filter=&quot;favorites&quot;&gt;Favorites&lt;/button&gt;<br>
          &lt;/div&gt;<br>
          &lt;div class=&quot;list-search&quot;&gt;<br>
            &lt;input type=&quot;search&quot; placeholder=&quot;Search articles...&quot; /&gt;<br>
          &lt;/div&gt;<br>
        &lt;/header&gt;<br>
        &lt;div class=&quot;list-items&quot;&gt;&lt;/div&gt;<br>
        &lt;div class=&quot;list-loading&quot; style=&quot;display: none;&quot;&gt;Loading...&lt;/div&gt;<br>
        &lt;div class=&quot;list-empty&quot; style=&quot;display: none;&quot;&gt;No articles found&lt;/div&gt;<br>
      &lt;/div&gt;<br>
    </code>;</p><p>    this.setupEventListeners();<br>
  }</p><p>  private setupEventListeners(): void {<br>
    // Filter buttons<br>
    this.container.querySelectorAll('.filter-btn').forEach((btn) =&gt; {<br>
      btn.addEventListener('click', (e) =&gt; {<br>
        const filter = (e.currentTarget as HTMLElement).dataset.filter;<br>
        this.setFilter(filter);<br>
      });<br>
    });</p><p>    // Search<br>
    const searchInput = this.container.querySelector(<br>
      'input[type=&quot;search&quot;]'<br>
    ) as HTMLInputElement;<br>
    let searchTimeout: number;</p><p>    searchInput?.addEventListener('input', () =&gt; {<br>
      clearTimeout(searchTimeout);<br>
      searchTimeout = window.setTimeout(() =&gt; {<br>
        this.search(searchInput.value);<br>
      }, 300);<br>
    });<br>
  }</p><p>  private async loadArticles(append = false): Promise&lt;void&gt; {<br>
    if (this.loading) return;<br>
    this.loading = true;</p><p>    const loadingEl = this.container.querySelector('.list-loading');<br>
    if (loadingEl) loadingEl.style.display = 'block';</p><p>    try {<br>
      const params = new URLSearchParams({<br>
        limit: this.pageSize.toString(),<br>
        offset: (this.page * this.pageSize).toString(),<br>
      });</p><p>      if (this.options.feedId) params.set('feedId', this.options.feedId);<br>
      if (this.options.tagId) params.set('tagId', this.options.tagId);<br>
      if (this.options.showUnreadOnly) params.set('isRead', 'false');</p><p>      const response = await fetch(<code>/api/articles?${params}</code>);<br>
      const data = await response.json();</p><p>      if (append) {<br>
        this.articles.push(...data.articles);<br>
      } else {<br>
        this.articles = data.articles;<br>
      }<br>
      this.total = data.total;</p><p>      this.renderArticles();<br>
    } finally {<br>
      this.loading = false;<br>
      if (loadingEl) loadingEl.style.display = 'none';<br>
    }<br>
  }</p><p>  private renderArticles(): void {<br>
    const listItems = this.container.querySelector('.list-items');<br>
    const emptyEl = this.container.querySelector('.list-empty');</p><p>    if (!listItems || !emptyEl) return;</p><p>    if (this.articles.length === 0) {<br>
      listItems.innerHTML = '';<br>
      emptyEl.style.display = 'block';<br>
      return;<br>
    }</p><p>    emptyEl.style.display = 'none';<br>
    listItems.innerHTML = this.articles<br>
      .map((article) =&gt; this.renderArticleItem(article))<br>
      .join('');</p><p>    // Add click handlers<br>
    listItems.querySelectorAll('.article-item').forEach((item) =&gt; {<br>
      item.addEventListener('click', () =&gt; {<br>
        const id = item.getAttribute('data-id');<br>
        if (id) this.openArticle(id);<br>
      });<br>
    });<br>
  }</p><p>  private renderArticleItem(article: Article): string {<br>
    const date = article.publishedAt<br>
      ? new Date(article.publishedAt).toLocaleDateString('en-US', {<br>
          month: 'short',<br>
          day: 'numeric',<br>
        })<br>
      : '';</p><p>    return <code><br>
      &lt;article class=&quot;article-item ${article.isRead ? 'read' : ''}&quot; data-id=&quot;${article.id}&quot;&gt;<br>
        &lt;div class=&quot;article-content&quot;&gt;<br>
          &lt;h3 class=&quot;article-title&quot;&gt;${this.escapeHtml(article.title)}&lt;/h3&gt;<br>
          ${article.excerpt ? </code>&lt;p class=&quot;article-excerpt&quot;&gt;${this.escapeHtml(article.excerpt.slice(0, 150))}...&lt;/p&gt;<code> : ''}<br>
          &lt;div class=&quot;article-meta&quot;&gt;<br>
            ${article.author ? </code>&lt;span class=&quot;article-author&quot;&gt;${this.escapeHtml(article.author)}&lt;/span&gt;<code> : ''}<br>
            ${date ? </code>&lt;span class=&quot;article-date&quot;&gt;${date}&lt;/span&gt;<code> : ''}<br>
            &lt;span class=&quot;article-time&quot;&gt;${article.readingTimeMinutes} min&lt;/span&gt;<br>
          &lt;/div&gt;<br>
        &lt;/div&gt;<br>
        ${article.imageUrl ? </code>&lt;img class=&quot;article-thumb&quot; src=&quot;${this.escapeHtml(article.imageUrl)}&quot; alt=&quot;&quot; loading=&quot;lazy&quot; /&gt;<code> : ''}<br>
      &lt;/article&gt;<br>
    </code>;<br>
  }</p><p>  private setupInfiniteScroll(): void {<br>
    const observer = new IntersectionObserver(<br>
      (entries) =&gt; {<br>
        if (entries[0]?.isIntersecting &amp;&amp; !this.loading) {<br>
          if (this.articles.length &lt; this.total) {<br>
            this.page++;<br>
            this.loadArticles(true);<br>
          }<br>
        }<br>
      },<br>
      { rootMargin: '100px' }<br>
    );</p><p>    const sentinel = document.createElement('div');<br>
    sentinel.className = 'scroll-sentinel';<br>
    this.container.appendChild(sentinel);<br>
    observer.observe(sentinel);<br>
  }</p><p>  private setFilter(filter: string | undefined): void {<br>
    // Update button states<br>
    this.container.querySelectorAll('.filter-btn').forEach((btn) =&gt; {<br>
      btn.classList.toggle('active', btn.dataset.filter === filter);<br>
    });</p><p>    // Update options<br>
    this.options.showUnreadOnly = filter === 'unread';<br>
    if (filter === 'favorites') {<br>
      // Would need to add isFavorite filter<br>
    }</p><p>    // Reload<br>
    this.page = 0;<br>
    this.loadArticles();<br>
  }</p><p>  private search(query: string): void {<br>
    // Would need to add search param handling<br>
    this.page = 0;<br>
    this.loadArticles();<br>
  }</p><p>  private openArticle(id: string): void {<br>
    window.location.href = <code>/read/${id}</code>;<br>
  }</p><p>  private escapeHtml(str: string): string {<br>
    const div = document.createElement('div');<br>
    div.textContent = str;<br>
    return div.innerHTML;<br>
  }<br>
}</code></pre><h2>Article List Styles</h2><pre><code class="language-css">/<em> styles/article-list.css </em>/</p><p>.article-list {<br>
  max-width: 800px;<br>
  margin: 0 auto;<br>
}</p><p>.list-header {<br>
  display: flex;<br>
  justify-content: space-between;<br>
  align-items: center;<br>
  padding: var(--space-4);<br>
  border-bottom: 1px solid var(--color-border);<br>
  position: sticky;<br>
  top: 0;<br>
  background: var(--color-bg);<br>
  z-index: 10;<br>
}</p><p>.list-filters {<br>
  display: flex;<br>
  gap: var(--space-2);<br>
}</p><p>.filter-btn {<br>
  padding: var(--space-2) var(--space-3);<br>
  border: none;<br>
  background: transparent;<br>
  color: var(--color-text-secondary);<br>
  cursor: pointer;<br>
  border-radius: 6px;<br>
  font-size: 0.875rem;<br>
}</p><p>.filter-btn:hover {<br>
  background: var(--color-bg-secondary);<br>
}</p><p>.filter-btn.active {<br>
  background: var(--color-bg-secondary);<br>
  color: var(--color-text);<br>
  font-weight: 500;<br>
}</p><p>.list-search input {<br>
  padding: var(--space-2) var(--space-3);<br>
  border: 1px solid var(--color-border);<br>
  border-radius: 6px;<br>
  background: var(--color-bg);<br>
  color: var(--color-text);<br>
  font-size: 0.875rem;<br>
  width: 200px;<br>
}</p><p>.article-item {<br>
  display: flex;<br>
  gap: var(--space-4);<br>
  padding: var(--space-4);<br>
  border-bottom: 1px solid var(--color-border);<br>
  cursor: pointer;<br>
  transition: background 0.15s;<br>
}</p><p>.article-item:hover {<br>
  background: var(--color-bg-secondary);<br>
}</p><p>.article-item.read {<br>
  opacity: 0.7;<br>
}</p><p>.article-item.read .article-title {<br>
  font-weight: 400;<br>
}</p><p>.article-content {<br>
  flex: 1;<br>
  min-width: 0;<br>
}</p><p>.article-title {<br>
  font-size: 1.125rem;<br>
  font-weight: 600;<br>
  margin: 0 0 var(--space-2);<br>
  line-height: 1.3;<br>
}</p><p>.article-excerpt {<br>
  font-size: 0.875rem;<br>
  color: var(--color-text-secondary);<br>
  margin: 0 0 var(--space-2);<br>
  line-height: 1.5;<br>
}</p><p>.article-meta {<br>
  display: flex;<br>
  gap: var(--space-3);<br>
  font-size: 0.75rem;<br>
  color: var(--color-text-secondary);<br>
}</p><p>.article-thumb {<br>
  width: 80px;<br>
  height: 80px;<br>
  object-fit: cover;<br>
  border-radius: 6px;<br>
  flex-shrink: 0;<br>
}</p><p>.list-loading,<br>
.list-empty {<br>
  padding: var(--space-8);<br>
  text-align: center;<br>
  color: var(--color-text-secondary);<br>
}</p><p>/<em> Reader styles </em>/<br>
.reader {<br>
  max-width: 65ch;<br>
  margin: 0 auto;<br>
  padding: var(--space-4);<br>
}</p><p>.reader-header {<br>
  margin-bottom: var(--space-8);<br>
}</p><p>.reader-title {<br>
  font-size: 2rem;<br>
  font-weight: 700;<br>
  line-height: 1.2;<br>
  margin: 0 0 var(--space-4);<br>
}</p><p>.reader-meta {<br>
  display: flex;<br>
  gap: var(--space-4);<br>
  font-size: 0.875rem;<br>
  color: var(--color-text-secondary);<br>
}</p><p>.reader-progress {<br>
  position: fixed;<br>
  top: 0;<br>
  left: 0;<br>
  right: 0;<br>
  height: 3px;<br>
  background: var(--color-border);<br>
  z-index: 100;<br>
}</p><p>.reader-progress-bar {<br>
  height: 100%;<br>
  background: var(--color-link);<br>
  width: 0;<br>
  transition: width 0.1s;<br>
}</p><p>.reader-footer {<br>
  margin-top: var(--space-12);<br>
  padding-top: var(--space-4);<br>
  border-top: 1px solid var(--color-border);<br>
}</p><p>.reader-actions {<br>
  display: flex;<br>
  gap: var(--space-4);<br>
}</p><p>.reader-actions button,<br>
.reader-actions a {<br>
  padding: var(--space-2) var(--space-4);<br>
  border: 1px solid var(--color-border);<br>
  border-radius: 6px;<br>
  background: transparent;<br>
  color: var(--color-text);<br>
  text-decoration: none;<br>
  font-size: 0.875rem;<br>
  cursor: pointer;<br>
}</p><p>.reader-actions button:hover,<br>
.reader-actions a:hover {<br>
  background: var(--color-bg-secondary);<br>
}</p><p>.reader-actions .active {<br>
  background: var(--color-highlight);<br>
  border-color: transparent;<br>
}</code></pre><h2>Settings Panel</h2><p>Let users customize their reading experience:</p><pre><code class="language-typescript">// web/src/components/Settings.ts</p><p>interface ReaderSettings {<br>
  theme: 'light' | 'dark' | 'system';<br>
  fontSize: 'small' | 'medium' | 'large';<br>
  fontFamily: 'serif' | 'sans';<br>
  lineHeight: 'compact' | 'normal' | 'relaxed';<br>
}</p><p>const DEFAULT_SETTINGS: ReaderSettings = {<br>
  theme: 'system',<br>
  fontSize: 'medium',<br>
  fontFamily: 'serif',<br>
  lineHeight: 'normal',<br>
};</p><p>export class Settings {<br>
  private settings: ReaderSettings;</p><p>  constructor() {<br>
    this.settings = this.load();<br>
    this.apply();<br>
  }</p><p>  private load(): ReaderSettings {<br>
    try {<br>
      const saved = localStorage.getItem('reader-settings');<br>
      if (saved) {<br>
        return { ...DEFAULT_SETTINGS, ...JSON.parse(saved) };<br>
      }<br>
    } catch {<br>
      // Ignore parse errors<br>
    }<br>
    return DEFAULT_SETTINGS;<br>
  }</p><p>  private save(): void {<br>
    localStorage.setItem('reader-settings', JSON.stringify(this.settings));<br>
  }</p><p>  private apply(): void {<br>
    const root = document.documentElement;</p><p>    // Theme<br>
    if (this.settings.theme === 'system') {<br>
      root.removeAttribute('data-theme');<br>
    } else {<br>
      root.setAttribute('data-theme', this.settings.theme);<br>
    }</p><p>    // Font size<br>
    const fontSizes = { small: '16px', medium: '18px', large: '20px' };<br>
    root.style.setProperty('--reader-font-size', fontSizes[this.settings.fontSize]);</p><p>    // Font family<br>
    root.setAttribute('data-font', this.settings.fontFamily);</p><p>    // Line height<br>
    const lineHeights = { compact: '1.5', normal: '1.7', relaxed: '1.9' };<br>
    root.style.setProperty(<br>
      '--reader-line-height',<br>
      lineHeights[this.settings.lineHeight]<br>
    );<br>
  }</p><p>  update(changes: Partial&lt;ReaderSettings&gt;): void {<br>
    this.settings = { ...this.settings, ...changes };<br>
    this.save();<br>
    this.apply();<br>
  }</p><p>  get(): ReaderSettings {<br>
    return { ...this.settings };<br>
  }</p><p>  renderPanel(containerId: string): void {<br>
    const container = document.getElementById(containerId);<br>
    if (!container) return;</p><p>    container.innerHTML = <code><br>
      &lt;div class=&quot;settings-panel&quot;&gt;<br>
        &lt;h2&gt;Reading Settings&lt;/h2&gt;</p><p>        &lt;div class=&quot;setting-group&quot;&gt;<br>
          &lt;label&gt;Theme&lt;/label&gt;<br>
          &lt;div class=&quot;setting-options&quot;&gt;<br>
            &lt;button data-setting=&quot;theme&quot; data-value=&quot;light&quot;<br>
                    class=&quot;${this.settings.theme === 'light' ? 'active' : ''}&quot;&gt;<br>
              Light<br>
            &lt;/button&gt;<br>
            &lt;button data-setting=&quot;theme&quot; data-value=&quot;dark&quot;<br>
                    class=&quot;${this.settings.theme === 'dark' ? 'active' : ''}&quot;&gt;<br>
              Dark<br>
            &lt;/button&gt;<br>
            &lt;button data-setting=&quot;theme&quot; data-value=&quot;system&quot;<br>
                    class=&quot;${this.settings.theme === 'system' ? 'active' : ''}&quot;&gt;<br>
              System<br>
            &lt;/button&gt;<br>
          &lt;/div&gt;<br>
        &lt;/div&gt;</p><p>        &lt;div class=&quot;setting-group&quot;&gt;<br>
          &lt;label&gt;Font Size&lt;/label&gt;<br>
          &lt;div class=&quot;setting-options&quot;&gt;<br>
            &lt;button data-setting=&quot;fontSize&quot; data-value=&quot;small&quot;<br>
                    class=&quot;${this.settings.fontSize === 'small' ? 'active' : ''}&quot;&gt;<br>
              Small<br>
            &lt;/button&gt;<br>
            &lt;button data-setting=&quot;fontSize&quot; data-value=&quot;medium&quot;<br>
                    class=&quot;${this.settings.fontSize === 'medium' ? 'active' : ''}&quot;&gt;<br>
              Medium<br>
            &lt;/button&gt;<br>
            &lt;button data-setting=&quot;fontSize&quot; data-value=&quot;large&quot;<br>
                    class=&quot;${this.settings.fontSize === 'large' ? 'active' : ''}&quot;&gt;<br>
              Large<br>
            &lt;/button&gt;<br>
          &lt;/div&gt;<br>
        &lt;/div&gt;</p><p>        &lt;div class=&quot;setting-group&quot;&gt;<br>
          &lt;label&gt;Font&lt;/label&gt;<br>
          &lt;div class=&quot;setting-options&quot;&gt;<br>
            &lt;button data-setting=&quot;fontFamily&quot; data-value=&quot;serif&quot;<br>
                    class=&quot;${this.settings.fontFamily === 'serif' ? 'active' : ''}&quot;&gt;<br>
              Serif<br>
            &lt;/button&gt;<br>
            &lt;button data-setting=&quot;fontFamily&quot; data-value=&quot;sans&quot;<br>
                    class=&quot;${this.settings.fontFamily === 'sans' ? 'active' : ''}&quot;&gt;<br>
              Sans<br>
            &lt;/button&gt;<br>
          &lt;/div&gt;<br>
        &lt;/div&gt;</p><p>        &lt;div class=&quot;setting-group&quot;&gt;<br>
          &lt;label&gt;Line Spacing&lt;/label&gt;<br>
          &lt;div class=&quot;setting-options&quot;&gt;<br>
            &lt;button data-setting=&quot;lineHeight&quot; data-value=&quot;compact&quot;<br>
                    class=&quot;${this.settings.lineHeight === 'compact' ? 'active' : ''}&quot;&gt;<br>
              Compact<br>
            &lt;/button&gt;<br>
            &lt;button data-setting=&quot;lineHeight&quot; data-value=&quot;normal&quot;<br>
                    class=&quot;${this.settings.lineHeight === 'normal' ? 'active' : ''}&quot;&gt;<br>
              Normal<br>
            &lt;/button&gt;<br>
            &lt;button data-setting=&quot;lineHeight&quot; data-value=&quot;relaxed&quot;<br>
                    class=&quot;${this.settings.lineHeight === 'relaxed' ? 'active' : ''}&quot;&gt;<br>
              Relaxed<br>
            &lt;/button&gt;<br>
          &lt;/div&gt;<br>
        &lt;/div&gt;<br>
      &lt;/div&gt;<br>
    </code>;</p><p>    container.querySelectorAll('[data-setting]').forEach((btn) =&gt; {<br>
      btn.addEventListener('click', () =&gt; {<br>
        const setting = btn.getAttribute('data-setting') as keyof ReaderSettings;<br>
        const value = btn.getAttribute('data-value');</p><p>        if (setting &amp;&amp; value) {<br>
          this.update({ [setting]: value } as Partial&lt;ReaderSettings&gt;);</p><p>          // Update active states<br>
          container<br>
            .querySelectorAll(<code>[data-setting=&quot;${setting}&quot;]</code>)<br>
            .forEach((b) =&gt; b.classList.remove('active'));<br>
          btn.classList.add('active');<br>
        }<br>
      });<br>
    });<br>
  }<br>
}</code></pre><h2>Next Steps</h2><p>With a functional reader interface, the next chapter adds text-to-speech—turning your reading library into an audio library.<br>
</p>
    </section>
  

    <section id="chapter-5" class="chapter">
      <h2>Text-to-Speech Integration</h2>
      <h2>The TTS Landscape</h2><p>Text-to-speech has evolved dramatically. You have several options:</p><p><strong>Browser Native (Web Speech API)</strong><br>
- Free, works offline<br>
- Quality varies by browser/OS<br>
- Limited voice options<br>
- No commercial licensing concerns</p><p><strong>Cloud Services (Google, AWS, Azure)</strong><br>
- High quality neural voices<br>
- Pay per character<br>
- Requires internet connection<br>
- Good for batch processing</p><p><strong>Specialized TTS (Speechify, ElevenLabs, PlayHT)</strong><br>
- Best quality, most natural<br>
- Higher cost<br>
- Premium features (voice cloning, emotional control)<br>
- Often have usage limits</p><p>We'll implement browser-native first, then add premium service integration.</p><h2>Web Speech API Basics</h2><p>The Web Speech API is surprisingly capable:</p><pre><code class="language-typescript">// src/services/tts-browser.ts</p><p>export interface TTSOptions {<br>
  rate?: number;      // 0.1 to 10, default 1<br>
  pitch?: number;     // 0 to 2, default 1<br>
  volume?: number;    // 0 to 1, default 1<br>
  voice?: string;     // Voice name<br>
}</p><p>export class BrowserTTS {<br>
  private synth: SpeechSynthesis;<br>
  private utterance: SpeechSynthesisUtterance | null = null;<br>
  private voices: SpeechSynthesisVoice[] = [];<br>
  private isReady = false;</p><p>  constructor() {<br>
    this.synth = window.speechSynthesis;<br>
    this.loadVoices();<br>
  }</p><p>  private loadVoices(): void {<br>
    // Voices may not be immediately available<br>
    const loadHandler = () =&gt; {<br>
      this.voices = this.synth.getVoices();<br>
      this.isReady = true;<br>
    };</p><p>    if (this.synth.getVoices().length &gt; 0) {<br>
      loadHandler();<br>
    } else {<br>
      this.synth.addEventListener('voiceschanged', loadHandler, { once: true });<br>
    }<br>
  }</p><p>  /**<br>
   * Get available voices<br>
   */<br>
  getVoices(): SpeechSynthesisVoice[] {<br>
    return this.voices;<br>
  }</p><p>  /**<br>
   * Get voices filtered by language<br>
   */<br>
  getVoicesByLanguage(lang: string): SpeechSynthesisVoice[] {<br>
    return this.voices.filter((v) =&gt; v.lang.startsWith(lang));<br>
  }</p><p>  /**<br>
   * Get recommended voice for English<br>
   */<br>
  getRecommendedVoice(): SpeechSynthesisVoice | undefined {<br>
    // Prefer high-quality voices<br>
    const englishVoices = this.getVoicesByLanguage('en');</p><p>    // Look for premium voices first<br>
    const premiumKeywords = ['Premium', 'Enhanced', 'Neural', 'Natural'];<br>
    for (const keyword of premiumKeywords) {<br>
      const premium = englishVoices.find((v) =&gt;<br>
        v.name.includes(keyword)<br>
      );<br>
      if (premium) return premium;<br>
    }</p><p>    // Fall back to any English voice<br>
    return englishVoices[0];<br>
  }</p><p>  /**<br>
   * Speak text<br>
   */<br>
  speak(<br>
    text: string,<br>
    options: TTSOptions = {},<br>
    callbacks?: {<br>
      onStart?: () =&gt; void;<br>
      onEnd?: () =&gt; void;<br>
      onPause?: () =&gt; void;<br>
      onResume?: () =&gt; void;<br>
      onBoundary?: (event: SpeechSynthesisEvent) =&gt; void;<br>
      onError?: (error: SpeechSynthesisErrorEvent) =&gt; void;<br>
    }<br>
  ): void {<br>
    // Cancel any ongoing speech<br>
    this.stop();</p><p>    this.utterance = new SpeechSynthesisUtterance(text);</p><p>    // Set options<br>
    this.utterance.rate = options.rate ?? 1;<br>
    this.utterance.pitch = options.pitch ?? 1;<br>
    this.utterance.volume = options.volume ?? 1;</p><p>    // Set voice<br>
    if (options.voice) {<br>
      const voice = this.voices.find((v) =&gt; v.name === options.voice);<br>
      if (voice) this.utterance.voice = voice;<br>
    } else {<br>
      const recommended = this.getRecommendedVoice();<br>
      if (recommended) this.utterance.voice = recommended;<br>
    }</p><p>    // Set callbacks<br>
    if (callbacks?.onStart) this.utterance.onstart = callbacks.onStart;<br>
    if (callbacks?.onEnd) this.utterance.onend = callbacks.onEnd;<br>
    if (callbacks?.onPause) this.utterance.onpause = callbacks.onPause;<br>
    if (callbacks?.onResume) this.utterance.onresume = callbacks.onResume;<br>
    if (callbacks?.onBoundary) this.utterance.onboundary = callbacks.onBoundary;<br>
    if (callbacks?.onError) this.utterance.onerror = callbacks.onError;</p><p>    this.synth.speak(this.utterance);<br>
  }</p><p>  /**<br>
   * Pause speech<br>
   */<br>
  pause(): void {<br>
    this.synth.pause();<br>
  }</p><p>  /**<br>
   * Resume speech<br>
   */<br>
  resume(): void {<br>
    this.synth.resume();<br>
  }</p><p>  /**<br>
   * Stop speech<br>
   */<br>
  stop(): void {<br>
    this.synth.cancel();<br>
    this.utterance = null;<br>
  }</p><p>  /**<br>
   * Check if speaking<br>
   */<br>
  isSpeaking(): boolean {<br>
    return this.synth.speaking;<br>
  }</p><p>  /**<br>
   * Check if paused<br>
   */<br>
  isPaused(): boolean {<br>
    return this.synth.paused;<br>
  }</p><p>  /**<br>
   * Check if ready<br>
   */<br>
  isInitialized(): boolean {<br>
    return this.isReady;<br>
  }<br>
}</p><p>export const browserTTS = new BrowserTTS();</code></pre><h2>Chunked Speech for Long Content</h2><p>The Web Speech API has quirks with long text. Some browsers stop after ~15 seconds. The solution: chunk the text and queue segments.</p><pre><code class="language-typescript">// web/src/services/tts-chunked.ts</p><p>interface ChunkedTTSOptions {<br>
  rate?: number;<br>
  pitch?: number;<br>
  volume?: number;<br>
  voice?: string;<br>
  chunkSize?: number;  // Characters per chunk<br>
}</p><p>interface PlaybackState {<br>
  isPlaying: boolean;<br>
  isPaused: boolean;<br>
  currentChunk: number;<br>
  totalChunks: number;<br>
  progress: number;  // 0-1<br>
}</p><p>export class ChunkedTTS {<br>
  private synth: SpeechSynthesis;<br>
  private chunks: string[] = [];<br>
  private currentChunkIndex = 0;<br>
  private options: ChunkedTTSOptions = {};<br>
  private voice: SpeechSynthesisVoice | null = null;<br>
  private isPlaying = false;<br>
  private isPaused = false;<br>
  private onStateChange?: (state: PlaybackState) =&gt; void;</p><p>  constructor() {<br>
    this.synth = window.speechSynthesis;<br>
  }</p><p>  /**<br>
   * Load text for playback<br>
   */<br>
  load(<br>
    text: string,<br>
    options: ChunkedTTSOptions = {},<br>
    onStateChange?: (state: PlaybackState) =&gt; void<br>
  ): void {<br>
    this.stop();</p><p>    this.options = options;<br>
    this.onStateChange = onStateChange;</p><p>    // Split into chunks at sentence boundaries<br>
    this.chunks = this.splitIntoChunks(text, options.chunkSize ?? 500);<br>
    this.currentChunkIndex = 0;</p><p>    // Find voice<br>
    const voices = this.synth.getVoices();<br>
    if (options.voice) {<br>
      this.voice = voices.find((v) =&gt; v.name === options.voice) ?? null;<br>
    }<br>
    if (!this.voice) {<br>
      // Default to first English voice<br>
      this.voice = voices.find((v) =&gt; v.lang.startsWith('en')) ?? null;<br>
    }</p><p>    this.emitState();<br>
  }</p><p>  /**<br>
   * Split text into chunks at sentence boundaries<br>
   */<br>
  private splitIntoChunks(text: string, maxLength: number): string[] {<br>
    const chunks: string[] = [];<br>
    const sentences = text.match(/[^.!?]+[.!?]+/g) ?? [text];</p><p>    let currentChunk = '';</p><p>    for (const sentence of sentences) {<br>
      if (currentChunk.length + sentence.length &gt; maxLength &amp;&amp; currentChunk) {<br>
        chunks.push(currentChunk.trim());<br>
        currentChunk = sentence;<br>
      } else {<br>
        currentChunk += sentence;<br>
      }<br>
    }</p><p>    if (currentChunk.trim()) {<br>
      chunks.push(currentChunk.trim());<br>
    }</p><p>    return chunks;<br>
  }</p><p>  /**<br>
   * Start or resume playback<br>
   */<br>
  play(): void {<br>
    if (this.isPaused) {<br>
      this.synth.resume();<br>
      this.isPaused = false;<br>
      this.emitState();<br>
      return;<br>
    }</p><p>    if (this.isPlaying) return;</p><p>    this.isPlaying = true;<br>
    this.playCurrentChunk();<br>
  }</p><p>  /**<br>
   * Play the current chunk<br>
   */<br>
  private playCurrentChunk(): void {<br>
    if (this.currentChunkIndex &gt;= this.chunks.length) {<br>
      this.isPlaying = false;<br>
      this.emitState();<br>
      return;<br>
    }</p><p>    const chunk = this.chunks[this.currentChunkIndex];<br>
    if (!chunk) return;</p><p>    const utterance = new SpeechSynthesisUtterance(chunk);</p><p>    utterance.rate = this.options.rate ?? 1;<br>
    utterance.pitch = this.options.pitch ?? 1;<br>
    utterance.volume = this.options.volume ?? 1;</p><p>    if (this.voice) {<br>
      utterance.voice = this.voice;<br>
    }</p><p>    utterance.onend = () =&gt; {<br>
      this.currentChunkIndex++;<br>
      this.emitState();</p><p>      if (this.isPlaying &amp;&amp; !this.isPaused) {<br>
        // Small delay between chunks for natural pacing<br>
        setTimeout(() =&gt; this.playCurrentChunk(), 100);<br>
      }<br>
    };</p><p>    utterance.onerror = (event) =&gt; {<br>
      console.error('TTS error:', event.error);<br>
      this.isPlaying = false;<br>
      this.emitState();<br>
    };</p><p>    this.synth.speak(utterance);<br>
    this.emitState();<br>
  }</p><p>  /**<br>
   * Pause playback<br>
   */<br>
  pause(): void {<br>
    if (!this.isPlaying) return;<br>
    this.synth.pause();<br>
    this.isPaused = true;<br>
    this.emitState();<br>
  }</p><p>  /**<br>
   * Stop playback<br>
   */<br>
  stop(): void {<br>
    this.synth.cancel();<br>
    this.isPlaying = false;<br>
    this.isPaused = false;<br>
    this.currentChunkIndex = 0;<br>
    this.emitState();<br>
  }</p><p>  /**<br>
   * Seek to position (0-1)<br>
   */<br>
  seek(position: number): void {<br>
    const wasPlaying = this.isPlaying;<br>
    this.stop();</p><p>    this.currentChunkIndex = Math.floor(position * this.chunks.length);<br>
    this.currentChunkIndex = Math.max(<br>
      0,<br>
      Math.min(this.currentChunkIndex, this.chunks.length - 1)<br>
    );</p><p>    if (wasPlaying) {<br>
      this.play();<br>
    }</p><p>    this.emitState();<br>
  }</p><p>  /**<br>
   * Get current state<br>
   */<br>
  getState(): PlaybackState {<br>
    return {<br>
      isPlaying: this.isPlaying,<br>
      isPaused: this.isPaused,<br>
      currentChunk: this.currentChunkIndex,<br>
      totalChunks: this.chunks.length,<br>
      progress:<br>
        this.chunks.length &gt; 0<br>
          ? this.currentChunkIndex / this.chunks.length<br>
          : 0,<br>
    };<br>
  }</p><p>  private emitState(): void {<br>
    this.onStateChange?.(this.getState());<br>
  }<br>
}</code></pre><h2>Audio Player Component</h2><p>A full-featured audio player UI:</p><pre><code class="language-typescript">// web/src/components/AudioPlayer.ts</p><p>import { ChunkedTTS } from '../services/tts-chunked.js';<br>
import { cleanForTts } from '../utils/text-utils.js';</p><p>interface AudioPlayerOptions {<br>
  articleId: string;<br>
  text: string;<br>
  onProgressUpdate?: (position: number) =&gt; void;<br>
}</p><p>export class AudioPlayer {<br>
  private container: HTMLElement;<br>
  private tts: ChunkedTTS;<br>
  private options: AudioPlayerOptions;<br>
  private settings = {<br>
    rate: 1,<br>
    pitch: 1,<br>
    volume: 1,<br>
    voice: '',<br>
  };</p><p>  constructor(containerId: string, options: AudioPlayerOptions) {<br>
    const container = document.getElementById(containerId);<br>
    if (!container) throw new Error('Container not found');<br>
    this.container = container;<br>
    this.options = options;</p><p>    this.tts = new ChunkedTTS();<br>
    this.loadSettings();<br>
    this.render();<br>
    this.initTTS();<br>
  }</p><p>  private loadSettings(): void {<br>
    try {<br>
      const saved = localStorage.getItem('tts-settings');<br>
      if (saved) {<br>
        this.settings = { ...this.settings, ...JSON.parse(saved) };<br>
      }<br>
    } catch {<br>
      // Ignore<br>
    }<br>
  }</p><p>  private saveSettings(): void {<br>
    localStorage.setItem('tts-settings', JSON.stringify(this.settings));<br>
  }</p><p>  private render(): void {<br>
    this.container.innerHTML = <code><br>
      &lt;div class=&quot;audio-player&quot;&gt;<br>
        &lt;div class=&quot;player-progress&quot;&gt;<br>
          &lt;div class=&quot;progress-bar&quot;&gt;<br>
            &lt;div class=&quot;progress-fill&quot;&gt;&lt;/div&gt;<br>
          &lt;/div&gt;<br>
          &lt;div class=&quot;progress-time&quot;&gt;<br>
            &lt;span class=&quot;time-current&quot;&gt;0:00&lt;/span&gt;<br>
            &lt;span class=&quot;time-total&quot;&gt;--:--&lt;/span&gt;<br>
          &lt;/div&gt;<br>
        &lt;/div&gt;</p><p>        &lt;div class=&quot;player-controls&quot;&gt;<br>
          &lt;button class=&quot;control-btn&quot; data-action=&quot;rewind&quot; title=&quot;Back 30s&quot;&gt;<br>
            &lt;span&gt;⏪&lt;/span&gt;<br>
          &lt;/button&gt;<br>
          &lt;button class=&quot;control-btn control-play&quot; data-action=&quot;play&quot; title=&quot;Play&quot;&gt;<br>
            &lt;span class=&quot;icon-play&quot;&gt;▶&lt;/span&gt;<br>
            &lt;span class=&quot;icon-pause&quot; style=&quot;display:none&quot;&gt;⏸&lt;/span&gt;<br>
          &lt;/button&gt;<br>
          &lt;button class=&quot;control-btn&quot; data-action=&quot;forward&quot; title=&quot;Forward 30s&quot;&gt;<br>
            &lt;span&gt;⏩&lt;/span&gt;<br>
          &lt;/button&gt;<br>
          &lt;button class=&quot;control-btn&quot; data-action=&quot;stop&quot; title=&quot;Stop&quot;&gt;<br>
            &lt;span&gt;⏹&lt;/span&gt;<br>
          &lt;/button&gt;<br>
        &lt;/div&gt;</p><p>        &lt;div class=&quot;player-settings&quot;&gt;<br>
          &lt;div class=&quot;setting-item&quot;&gt;<br>
            &lt;label&gt;Speed&lt;/label&gt;<br>
            &lt;select data-setting=&quot;rate&quot;&gt;<br>
              &lt;option value=&quot;0.5&quot;&gt;0.5x&lt;/option&gt;<br>
              &lt;option value=&quot;0.75&quot;&gt;0.75x&lt;/option&gt;<br>
              &lt;option value=&quot;1&quot; selected&gt;1x&lt;/option&gt;<br>
              &lt;option value=&quot;1.25&quot;&gt;1.25x&lt;/option&gt;<br>
              &lt;option value=&quot;1.5&quot;&gt;1.5x&lt;/option&gt;<br>
              &lt;option value=&quot;1.75&quot;&gt;1.75x&lt;/option&gt;<br>
              &lt;option value=&quot;2&quot;&gt;2x&lt;/option&gt;<br>
            &lt;/select&gt;<br>
          &lt;/div&gt;</p><p>          &lt;div class=&quot;setting-item&quot;&gt;<br>
            &lt;label&gt;Voice&lt;/label&gt;<br>
            &lt;select data-setting=&quot;voice&quot;&gt;<br>
              &lt;option value=&quot;&quot;&gt;Default&lt;/option&gt;<br>
            &lt;/select&gt;<br>
          &lt;/div&gt;<br>
        &lt;/div&gt;<br>
      &lt;/div&gt;<br>
    </code>;</p><p>    this.setupEventListeners();<br>
    this.populateVoices();<br>
    this.applySettings();<br>
  }</p><p>  private setupEventListeners(): void {<br>
    // Control buttons<br>
    this.container.querySelectorAll('[data-action]').forEach((btn) =&gt; {<br>
      btn.addEventListener('click', () =&gt; {<br>
        const action = btn.getAttribute('data-action');<br>
        if (action === 'play') this.togglePlay();<br>
        if (action === 'stop') this.stop();<br>
        if (action === 'rewind') this.seek(-0.1);<br>
        if (action === 'forward') this.seek(0.1);<br>
      });<br>
    });</p><p>    // Settings<br>
    this.container.querySelectorAll('[data-setting]').forEach((select) =&gt; {<br>
      select.addEventListener('change', (e) =&gt; {<br>
        const setting = select.getAttribute('data-setting');<br>
        const value = (e.target as HTMLSelectElement).value;</p><p>        if (setting === 'rate') {<br>
          this.settings.rate = parseFloat(value);<br>
        } else if (setting === 'voice') {<br>
          this.settings.voice = value;<br>
        }</p><p>        this.saveSettings();<br>
        this.reinitTTS();<br>
      });<br>
    });</p><p>    // Progress bar click<br>
    const progressBar = this.container.querySelector('.progress-bar');<br>
    progressBar?.addEventListener('click', (e) =&gt; {<br>
      const rect = (e.currentTarget as HTMLElement).getBoundingClientRect();<br>
      const position = (e.clientX - rect.left) / rect.width;<br>
      this.tts.seek(position);<br>
    });<br>
  }</p><p>  private populateVoices(): void {<br>
    const select = this.container.querySelector(<br>
      '[data-setting=&quot;voice&quot;]'<br>
    ) as HTMLSelectElement;<br>
    if (!select) return;</p><p>    // Wait for voices to load<br>
    const populateOnce = () =&gt; {<br>
      const voices = speechSynthesis.getVoices();<br>
      const englishVoices = voices.filter((v) =&gt; v.lang.startsWith('en'));</p><p>      select.innerHTML =<br>
        '&lt;option value=&quot;&quot;&gt;Default&lt;/option&gt;' +<br>
        englishVoices<br>
          .map(<br>
            (v) =&gt;<br>
              <code>&lt;option value=&quot;${v.name}&quot;&gt;${v.name} (${v.lang})&lt;/option&gt;</code><br>
          )<br>
          .join('');</p><p>      // Restore saved voice<br>
      if (this.settings.voice) {<br>
        select.value = this.settings.voice;<br>
      }<br>
    };</p><p>    if (speechSynthesis.getVoices().length &gt; 0) {<br>
      populateOnce();<br>
    } else {<br>
      speechSynthesis.addEventListener('voiceschanged', populateOnce, {<br>
        once: true,<br>
      });<br>
    }<br>
  }</p><p>  private applySettings(): void {<br>
    const rateSelect = this.container.querySelector(<br>
      '[data-setting=&quot;rate&quot;]'<br>
    ) as HTMLSelectElement;<br>
    if (rateSelect) {<br>
      rateSelect.value = this.settings.rate.toString();<br>
    }<br>
  }</p><p>  private initTTS(): void {<br>
    const cleanText = cleanForTts(this.options.text);</p><p>    this.tts.load(cleanText, this.settings, (state) =&gt; {<br>
      this.updateUI(state);</p><p>      // Save progress<br>
      if (state.progress &gt; 0) {<br>
        this.options.onProgressUpdate?.(state.progress);<br>
      }<br>
    });<br>
  }</p><p>  private reinitTTS(): void {<br>
    const wasPlaying = this.tts.getState().isPlaying;<br>
    const position = this.tts.getState().progress;</p><p>    this.initTTS();</p><p>    if (position &gt; 0) {<br>
      this.tts.seek(position);<br>
    }</p><p>    if (wasPlaying) {<br>
      this.tts.play();<br>
    }<br>
  }</p><p>  private togglePlay(): void {<br>
    const state = this.tts.getState();<br>
    if (state.isPlaying &amp;&amp; !state.isPaused) {<br>
      this.tts.pause();<br>
    } else {<br>
      this.tts.play();<br>
    }<br>
  }</p><p>  private stop(): void {<br>
    this.tts.stop();<br>
  }</p><p>  private seek(delta: number): void {<br>
    const state = this.tts.getState();<br>
    const newPosition = Math.max(0, Math.min(1, state.progress + delta));<br>
    this.tts.seek(newPosition);<br>
  }</p><p>  private updateUI(state: { isPlaying: boolean; isPaused: boolean; progress: number }): void {<br>
    // Update play/pause icon<br>
    const playIcon = this.container.querySelector('.icon-play') as HTMLElement;<br>
    const pauseIcon = this.container.querySelector('.icon-pause') as HTMLElement;</p><p>    if (playIcon &amp;&amp; pauseIcon) {<br>
      playIcon.style.display = state.isPlaying &amp;&amp; !state.isPaused ? 'none' : '';<br>
      pauseIcon.style.display = state.isPlaying &amp;&amp; !state.isPaused ? '' : 'none';<br>
    }</p><p>    // Update progress bar<br>
    const progressFill = this.container.querySelector(<br>
      '.progress-fill'<br>
    ) as HTMLElement;<br>
    if (progressFill) {<br>
      progressFill.style.width = <code>${state.progress * 100}%</code>;<br>
    }<br>
  }</p><p>  /**<br>
   * Resume from saved position<br>
   */<br>
  resumeFrom(position: number): void {<br>
    this.tts.seek(position);<br>
  }</p><p>  /**<br>
   * Cleanup<br>
   */<br>
  destroy(): void {<br>
    this.tts.stop();<br>
  }<br>
}</code></pre><h2>Audio Player Styles</h2><pre><code class="language-css">/<em> styles/audio-player.css </em>/</p><p>.audio-player {<br>
  background: var(--color-bg-secondary);<br>
  border-radius: 8px;<br>
  padding: var(--space-4);<br>
  margin: var(--space-4) 0;<br>
}</p><p>.player-progress {<br>
  margin-bottom: var(--space-4);<br>
}</p><p>.progress-bar {<br>
  height: 6px;<br>
  background: var(--color-border);<br>
  border-radius: 3px;<br>
  cursor: pointer;<br>
  overflow: hidden;<br>
}</p><p>.progress-fill {<br>
  height: 100%;<br>
  background: var(--color-link);<br>
  width: 0;<br>
  transition: width 0.1s;<br>
}</p><p>.progress-time {<br>
  display: flex;<br>
  justify-content: space-between;<br>
  font-size: 0.75rem;<br>
  color: var(--color-text-secondary);<br>
  margin-top: var(--space-1);<br>
}</p><p>.player-controls {<br>
  display: flex;<br>
  justify-content: center;<br>
  gap: var(--space-4);<br>
  margin-bottom: var(--space-4);<br>
}</p><p>.control-btn {<br>
  width: 44px;<br>
  height: 44px;<br>
  border: none;<br>
  background: transparent;<br>
  border-radius: 50%;<br>
  cursor: pointer;<br>
  display: flex;<br>
  align-items: center;<br>
  justify-content: center;<br>
  font-size: 1.25rem;<br>
  color: var(--color-text);<br>
  transition: background 0.15s;<br>
}</p><p>.control-btn:hover {<br>
  background: var(--color-border);<br>
}</p><p>.control-play {<br>
  width: 56px;<br>
  height: 56px;<br>
  background: var(--color-link);<br>
  color: white;<br>
  font-size: 1.5rem;<br>
}</p><p>.control-play:hover {<br>
  background: var(--color-link);<br>
  opacity: 0.9;<br>
}</p><p>.player-settings {<br>
  display: flex;<br>
  gap: var(--space-4);<br>
  justify-content: center;<br>
  border-top: 1px solid var(--color-border);<br>
  padding-top: var(--space-4);<br>
}</p><p>.setting-item {<br>
  display: flex;<br>
  align-items: center;<br>
  gap: var(--space-2);<br>
}</p><p>.setting-item label {<br>
  font-size: 0.75rem;<br>
  color: var(--color-text-secondary);<br>
}</p><p>.setting-item select {<br>
  padding: var(--space-1) var(--space-2);<br>
  border: 1px solid var(--color-border);<br>
  border-radius: 4px;<br>
  background: var(--color-bg);<br>
  color: var(--color-text);<br>
  font-size: 0.875rem;<br>
}</code></pre><h2>Premium TTS Integration (Speechify)</h2><p>For higher quality, integrate a premium service:</p><pre><code class="language-typescript">// src/services/tts-speechify.ts</p><p>interface SpeechifyVoice {<br>
  id: string;<br>
  name: string;<br>
  language: string;<br>
}</p><p>interface SpeechifyOptions {<br>
  voiceId: string;<br>
  speed?: number;  // 0.5 to 2.0<br>
}</p><p>export class SpeechifyTTS {<br>
  private apiKey: string;<br>
  private baseUrl = 'https://api.sws.speechify.com';</p><p>  constructor(apiKey: string) {<br>
    this.apiKey = apiKey;<br>
  }</p><p>  /**<br>
   * Get available voices<br>
   */<br>
  async getVoices(): Promise&lt;SpeechifyVoice[]&gt; {<br>
    const response = await fetch(<code>${this.baseUrl}/v1/voices</code>, {<br>
      headers: {<br>
        Authorization: <code>Bearer ${this.apiKey}</code>,<br>
      },<br>
    });</p><p>    if (!response.ok) {<br>
      throw new Error('Failed to fetch voices');<br>
    }</p><p>    const data = await response.json();<br>
    return data.voices;<br>
  }</p><p>  /**<br>
   * Generate audio from text<br>
   */<br>
  async generateAudio(<br>
    text: string,<br>
    options: SpeechifyOptions<br>
  ): Promise&lt;ArrayBuffer&gt; {<br>
    const response = await fetch(<code>${this.baseUrl}/v1/audio/speech</code>, {<br>
      method: 'POST',<br>
      headers: {<br>
        Authorization: <code>Bearer ${this.apiKey}</code>,<br>
        'Content-Type': 'application/json',<br>
      },<br>
      body: JSON.stringify({<br>
        input: text,<br>
        voice_id: options.voiceId,<br>
        audio_format: 'mp3',<br>
        speed: options.speed ?? 1.0,<br>
      }),<br>
    });</p><p>    if (!response.ok) {<br>
      throw new Error('Failed to generate audio');<br>
    }</p><p>    return response.arrayBuffer();<br>
  }</p><p>  /**<br>
   * Stream audio generation<br>
   */<br>
  async *streamAudio(<br>
    text: string,<br>
    options: SpeechifyOptions<br>
  ): AsyncGenerator&lt;ArrayBuffer&gt; {<br>
    const response = await fetch(<code>${this.baseUrl}/v1/audio/speech/stream</code>, {<br>
      method: 'POST',<br>
      headers: {<br>
        Authorization: <code>Bearer ${this.apiKey}</code>,<br>
        'Content-Type': 'application/json',<br>
      },<br>
      body: JSON.stringify({<br>
        input: text,<br>
        voice_id: options.voiceId,<br>
        audio_format: 'mp3',<br>
        speed: options.speed ?? 1.0,<br>
      }),<br>
    });</p><p>    if (!response.ok || !response.body) {<br>
      throw new Error('Failed to stream audio');<br>
    }</p><p>    const reader = response.body.getReader();</p><p>    while (true) {<br>
      const { done, value } = await reader.read();<br>
      if (done) break;<br>
      yield value.buffer;<br>
    }<br>
  }<br>
}</code></pre><h2>Server-Side TTS Endpoint</h2><p>Generate and cache audio on the server:</p><pre><code class="language-typescript">// src/api/routes/tts.ts<br>
import { Router } from 'express';<br>
import { queryOne } from '../../db/client.js';<br>
import { cleanForTts } from '../../utils/html-cleaner.js';<br>
import { SpeechifyTTS } from '../../services/tts-speechify.js';<br>
import type { Article } from '../../types/index.js';</p><p>export const ttsRouter = Router();</p><p>const speechify = process.env.SPEECHIFY_API_KEY<br>
  ? new SpeechifyTTS(process.env.SPEECHIFY_API_KEY)<br>
  : null;</p><p>// Get available voices<br>
ttsRouter.get('/voices', async (_req, res, next) =&gt; {<br>
  try {<br>
    if (!speechify) {<br>
      // Return browser voices info<br>
      res.json({<br>
        provider: 'browser',<br>
        message: 'Using browser TTS. Configure SPEECHIFY_API_KEY for premium voices.',<br>
      });<br>
      return;<br>
    }</p><p>    const voices = await speechify.getVoices();<br>
    res.json({ provider: 'speechify', voices });<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Generate audio for article<br>
ttsRouter.post('/:articleId/generate', async (req, res, next) =&gt; {<br>
  try {<br>
    if (!speechify) {<br>
      res.status(400).json({<br>
        error: 'Premium TTS not configured. Use browser TTS instead.',<br>
      });<br>
      return;<br>
    }</p><p>    const article = await queryOne&lt;Article&gt;(<br>
      'SELECT * FROM articles WHERE id = $1',<br>
      [req.params.articleId]<br>
    );</p><p>    if (!article) {<br>
      res.status(404).json({ error: 'Article not found' });<br>
      return;<br>
    }</p><p>    const { voiceId, speed } = req.body;</p><p>    // Clean text for TTS<br>
    const text = cleanForTts(article.textContent);</p><p>    // Generate audio<br>
    const audio = await speechify.generateAudio(text, {<br>
      voiceId: voiceId ?? 'default',<br>
      speed: speed ?? 1.0,<br>
    });</p><p>    // Set headers for audio download<br>
    res.setHeader('Content-Type', 'audio/mpeg');<br>
    res.setHeader(<br>
      'Content-Disposition',<br>
      <code>attachment; filename=&quot;${article.id}.mp3&quot;</code><br>
    );</p><p>    res.send(Buffer.from(audio));<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Stream audio<br>
ttsRouter.get('/:articleId/stream', async (req, res, next) =&gt; {<br>
  try {<br>
    if (!speechify) {<br>
      res.status(400).json({<br>
        error: 'Premium TTS not configured',<br>
      });<br>
      return;<br>
    }</p><p>    const article = await queryOne&lt;Article&gt;(<br>
      'SELECT * FROM articles WHERE id = $1',<br>
      [req.params.articleId]<br>
    );</p><p>    if (!article) {<br>
      res.status(404).json({ error: 'Article not found' });<br>
      return;<br>
    }</p><p>    const voiceId = req.query.voiceId as string ?? 'default';<br>
    const speed = parseFloat(req.query.speed as string ?? '1');</p><p>    const text = cleanForTts(article.textContent);</p><p>    res.setHeader('Content-Type', 'audio/mpeg');<br>
    res.setHeader('Transfer-Encoding', 'chunked');</p><p>    for await (const chunk of speechify.streamAudio(text, { voiceId, speed })) {<br>
      res.write(Buffer.from(chunk));<br>
    }</p><p>    res.end();<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</code></pre><h2>Hybrid TTS: Browser + Premium</h2><p>Use browser TTS as fallback, premium when available:</p><pre><code class="language-typescript">// web/src/services/tts-hybrid.ts</p><p>import { ChunkedTTS } from './tts-chunked.js';</p><p>interface HybridTTSOptions {<br>
  preferPremium?: boolean;<br>
  browserRate?: number;<br>
  premiumVoiceId?: string;<br>
}</p><p>export class HybridTTS {<br>
  private browserTTS: ChunkedTTS;<br>
  private premiumAvailable = false;</p><p>  constructor() {<br>
    this.browserTTS = new ChunkedTTS();<br>
    this.checkPremiumAvailability();<br>
  }</p><p>  private async checkPremiumAvailability(): Promise&lt;void&gt; {<br>
    try {<br>
      const response = await fetch('/api/tts/voices');<br>
      const data = await response.json();<br>
      this.premiumAvailable = data.provider === 'speechify';<br>
    } catch {<br>
      this.premiumAvailable = false;<br>
    }<br>
  }</p><p>  /**<br>
   * Play article audio<br>
   */<br>
  async play(<br>
    articleId: string,<br>
    text: string,<br>
    options: HybridTTSOptions = {}<br>
  ): Promise&lt;void&gt; {<br>
    if (options.preferPremium &amp;&amp; this.premiumAvailable) {<br>
      await this.playPremium(articleId, options);<br>
    } else {<br>
      this.playBrowser(text, options);<br>
    }<br>
  }</p><p>  private playBrowser(text: string, options: HybridTTSOptions): void {<br>
    this.browserTTS.load(<br>
      text,<br>
      { rate: options.browserRate ?? 1 },<br>
      () =&gt; {}<br>
    );<br>
    this.browserTTS.play();<br>
  }</p><p>  private async playPremium(<br>
    articleId: string,<br>
    options: HybridTTSOptions<br>
  ): Promise&lt;void&gt; {<br>
    const params = new URLSearchParams();<br>
    if (options.premiumVoiceId) params.set('voiceId', options.premiumVoiceId);</p><p>    const audio = new Audio(<code>/api/tts/${articleId}/stream?${params}</code>);<br>
    audio.play();<br>
  }</p><p>  /**<br>
   * Check if premium TTS is available<br>
   */<br>
  isPremiumAvailable(): boolean {<br>
    return this.premiumAvailable;<br>
  }<br>
}</code></pre><h2>Next Steps</h2><p>With TTS integration complete, the next chapter covers organization—tagging, reading lists, and search to manage a growing library.<br>
</p>
    </section>
  

    <section id="chapter-6" class="chapter">
      <h2>Organization and Search</h2>
      <h2>The Organization Challenge</h2><p>A reading library grows quickly. Subscribe to ten feeds, and you'll have hundreds of articles within weeks. Without organization, finding that article you half-remember becomes impossible.</p><p>We need:<br>
- <strong>Tags</strong> for categorization<br>
- <strong>Reading lists</strong> for curation<br>
- <strong>Full-text search</strong> for discovery<br>
- <strong>Smart filters</strong> for browsing</p><h2>Tag Management</h2><p>Tags are the primary organization mechanism. Keep them simple: a name and a color.</p><pre><code class="language-typescript">// src/services/tag-service.ts<br>
import { query, queryOne, execute } from '../db/client.js';<br>
import type { Tag } from '../types/index.js';</p><p>export class TagService {<br>
  /**<br>
   * Create a new tag<br>
   */<br>
  async createTag(name: string, color?: string): Promise&lt;Tag&gt; {<br>
    const normalizedName = name.toLowerCase().trim();</p><p>    const tag = await queryOne&lt;Tag&gt;(<br>
      <code>INSERT INTO tags (name, color)<br>
       VALUES ($1, $2)<br>
       ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name<br>
       RETURNING *</code>,<br>
      [normalizedName, color ?? this.generateColor(normalizedName)]<br>
    );</p><p>    if (!tag) {<br>
      throw new Error('Failed to create tag');<br>
    }</p><p>    return tag;<br>
  }</p><p>  /**<br>
   * Get all tags with usage counts<br>
   */<br>
  async getAllTags(): Promise&lt;Array&lt;Tag &amp; { articleCount: number }&gt;&gt; {<br>
    return query(<br>
      <code>SELECT t.*, COUNT(at.article_id)::int as article_count<br>
       FROM tags t<br>
       LEFT JOIN article_tags at ON at.tag_id = t.id<br>
       GROUP BY t.id<br>
       ORDER BY t.name</code><br>
    );<br>
  }</p><p>  /**<br>
   * Get tag by ID<br>
   */<br>
  async getTag(id: string): Promise&lt;Tag | null&gt; {<br>
    return queryOne&lt;Tag&gt;('SELECT * FROM tags WHERE id = $1', [id]);<br>
  }</p><p>  /**<br>
   * Update tag<br>
   */<br>
  async updateTag(<br>
    id: string,<br>
    updates: { name?: string; color?: string }<br>
  ): Promise&lt;Tag | null&gt; {<br>
    const setClauses: string[] = [];<br>
    const params: unknown[] = [];<br>
    let paramIndex = 1;</p><p>    if (updates.name) {<br>
      setClauses.push(<code>name = $${paramIndex++}</code>);<br>
      params.push(updates.name.toLowerCase().trim());<br>
    }</p><p>    if (updates.color) {<br>
      setClauses.push(<code>color = $${paramIndex++}</code>);<br>
      params.push(updates.color);<br>
    }</p><p>    if (setClauses.length === 0) {<br>
      return this.getTag(id);<br>
    }</p><p>    params.push(id);</p><p>    return queryOne&lt;Tag&gt;(<br>
      <code>UPDATE tags SET ${setClauses.join(', ')} WHERE id = $${paramIndex} RETURNING *</code>,<br>
      params<br>
    );<br>
  }</p><p>  /**<br>
   * Delete tag<br>
   */<br>
  async deleteTag(id: string): Promise&lt;void&gt; {<br>
    await execute('DELETE FROM tags WHERE id = $1', [id]);<br>
  }</p><p>  /**<br>
   * Generate a color from tag name (deterministic)<br>
   */<br>
  private generateColor(name: string): string {<br>
    // Hash the name to get consistent colors<br>
    let hash = 0;<br>
    for (let i = 0; i &lt; name.length; i++) {<br>
      hash = name.charCodeAt(i) + ((hash &lt;&lt; 5) - hash);<br>
    }</p><p>    // Convert to HSL for nice colors<br>
    const h = hash % 360;<br>
    const s = 50 + (hash % 30); // 50-80%<br>
    const l = 40 + (hash % 20); // 40-60%</p><p>    return <code>hsl(${h}, ${s}%, ${l}%)</code>;<br>
  }<br>
}</p><p>export const tagService = new TagService();</code></pre><h2>Auto-Tagging with AI</h2><p>Use Claude to suggest tags based on content:</p><pre><code class="language-typescript">// src/services/auto-tagger.ts<br>
import Anthropic from '@anthropic-ai/sdk';<br>
import { tagService } from './tag-service.js';<br>
import { articleService } from './article-service.js';<br>
import type { Tag } from '../types/index.js';</p><p>const anthropic = process.env.ANTHROPIC_API_KEY<br>
  ? new Anthropic()<br>
  : null;</p><p>export class AutoTagger {<br>
  /**<br>
   * Suggest tags for an article<br>
   */<br>
  async suggestTags(articleId: string): Promise&lt;string[]&gt; {<br>
    if (!anthropic) {<br>
      return [];<br>
    }</p><p>    const article = await articleService.getArticle(articleId);<br>
    if (!article) return [];</p><p>    // Get existing tags for context<br>
    const existingTags = await tagService.getAllTags();<br>
    const tagNames = existingTags.map((t) =&gt; t.name);</p><p>    const response = await anthropic.messages.create({<br>
      model: 'claude-3-haiku-20240307',<br>
      max_tokens: 200,<br>
      messages: [<br>
        {<br>
          role: 'user',<br>
          content: <code>Suggest 2-4 tags for this article. Prefer existing tags when appropriate.</p><p>Existing tags: ${tagNames.join(', ')}</p><p>Article title: ${article.title}<br>
Article excerpt: ${article.textContent.slice(0, 1000)}</p><p>Return only tag names, one per line, lowercase. Create new tags only if necessary.</code>,<br>
        },<br>
      ],<br>
    });</p><p>    const text = response.content[0]?.type === 'text'<br>
      ? response.content[0].text<br>
      : '';</p><p>    return text<br>
      .split('\n')<br>
      .map((t) =&gt; t.trim().toLowerCase())<br>
      .filter((t) =&gt; t.length &gt; 0 &amp;&amp; t.length &lt; 30);<br>
  }</p><p>  /**<br>
   * Auto-tag an article<br>
   */<br>
  async autoTag(articleId: string): Promise&lt;Tag[]&gt; {<br>
    const suggestions = await this.suggestTags(articleId);<br>
    const appliedTags: Tag[] = [];</p><p>    for (const name of suggestions) {<br>
      // Get or create tag<br>
      let tag = (await tagService.getAllTags()).find(<br>
        (t) =&gt; t.name === name<br>
      );</p><p>      if (!tag) {<br>
        tag = await tagService.createTag(name);<br>
      }</p><p>      // Apply to article<br>
      await articleService.addTags(articleId, [tag.id]);<br>
      appliedTags.push(tag);<br>
    }</p><p>    return appliedTags;<br>
  }<br>
}</p><p>export const autoTagger = new AutoTagger();</code></pre><h2>Reading Lists</h2><p>Reading lists are curated collections, like playlists for articles:</p><pre><code class="language-typescript">// src/services/reading-list-service.ts<br>
import { query, queryOne, execute } from '../db/client.js';<br>
import type { ReadingList, Article } from '../types/index.js';</p><p>export interface ReadingListWithArticles extends ReadingList {<br>
  articles: Article[];<br>
  articleCount: number;<br>
}</p><p>export class ReadingListService {<br>
  /**<br>
   * Create a new reading list<br>
   */<br>
  async createList(name: string, description?: string): Promise&lt;ReadingList&gt; {<br>
    // Get max position<br>
    const maxPos = await queryOne&lt;{ max: number }&gt;(<br>
      'SELECT COALESCE(MAX(position), 0) as max FROM reading_lists'<br>
    );</p><p>    const list = await queryOne&lt;ReadingList&gt;(<br>
      <code>INSERT INTO reading_lists (name, description, position)<br>
       VALUES ($1, $2, $3)<br>
       RETURNING *</code>,<br>
      [name, description ?? null, (maxPos?.max ?? 0) + 1]<br>
    );</p><p>    if (!list) {<br>
      throw new Error('Failed to create reading list');<br>
    }</p><p>    return list;<br>
  }</p><p>  /**<br>
   * Get all reading lists with article counts<br>
   */<br>
  async getAllLists(): Promise&lt;Array&lt;ReadingList &amp; { articleCount: number }&gt;&gt; {<br>
    return query(<br>
      <code>SELECT rl.*, COUNT(rla.article_id)::int as article_count<br>
       FROM reading_lists rl<br>
       LEFT JOIN reading_list_articles rla ON rla.reading_list_id = rl.id<br>
       GROUP BY rl.id<br>
       ORDER BY rl.position</code><br>
    );<br>
  }</p><p>  /**<br>
   * Get reading list with articles<br>
   */<br>
  async getListWithArticles(id: string): Promise&lt;ReadingListWithArticles | null&gt; {<br>
    const list = await queryOne&lt;ReadingList&gt;(<br>
      'SELECT * FROM reading_lists WHERE id = $1',<br>
      [id]<br>
    );</p><p>    if (!list) return null;</p><p>    const articles = await query&lt;Article&gt;(<br>
      <code>SELECT a.*<br>
       FROM articles a<br>
       JOIN reading_list_articles rla ON rla.article_id = a.id<br>
       WHERE rla.reading_list_id = $1<br>
       ORDER BY rla.position</code>,<br>
      [id]<br>
    );</p><p>    return {<br>
      ...list,<br>
      articles,<br>
      articleCount: articles.length,<br>
    };<br>
  }</p><p>  /**<br>
   * Add article to list<br>
   */<br>
  async addArticle(listId: string, articleId: string): Promise&lt;void&gt; {<br>
    // Get max position in list<br>
    const maxPos = await queryOne&lt;{ max: number }&gt;(<br>
      <code>SELECT COALESCE(MAX(position), 0) as max<br>
       FROM reading_list_articles<br>
       WHERE reading_list_id = $1</code>,<br>
      [listId]<br>
    );</p><p>    await execute(<br>
      <code>INSERT INTO reading_list_articles (reading_list_id, article_id, position)<br>
       VALUES ($1, $2, $3)<br>
       ON CONFLICT DO NOTHING</code>,<br>
      [listId, articleId, (maxPos?.max ?? 0) + 1]<br>
    );<br>
  }</p><p>  /**<br>
   * Remove article from list<br>
   */<br>
  async removeArticle(listId: string, articleId: string): Promise&lt;void&gt; {<br>
    await execute(<br>
      <code>DELETE FROM reading_list_articles<br>
       WHERE reading_list_id = $1 AND article_id = $2</code>,<br>
      [listId, articleId]<br>
    );<br>
  }</p><p>  /**<br>
   * Reorder article in list<br>
   */<br>
  async reorderArticle(<br>
    listId: string,<br>
    articleId: string,<br>
    newPosition: number<br>
  ): Promise&lt;void&gt; {<br>
    // Get current position<br>
    const current = await queryOne&lt;{ position: number }&gt;(<br>
      <code>SELECT position FROM reading_list_articles<br>
       WHERE reading_list_id = $1 AND article_id = $2</code>,<br>
      [listId, articleId]<br>
    );</p><p>    if (!current) return;</p><p>    const oldPosition = current.position;</p><p>    if (newPosition &gt; oldPosition) {<br>
      // Moving down: shift items up<br>
      await execute(<br>
        <code>UPDATE reading_list_articles<br>
         SET position = position - 1<br>
         WHERE reading_list_id = $1<br>
           AND position &gt; $2<br>
           AND position &lt;= $3</code>,<br>
        [listId, oldPosition, newPosition]<br>
      );<br>
    } else {<br>
      // Moving up: shift items down<br>
      await execute(<br>
        <code>UPDATE reading_list_articles<br>
         SET position = position + 1<br>
         WHERE reading_list_id = $1<br>
           AND position &gt;= $2<br>
           AND position &lt; $3</code>,<br>
        [listId, newPosition, oldPosition]<br>
      );<br>
    }</p><p>    // Update target position<br>
    await execute(<br>
      <code>UPDATE reading_list_articles<br>
       SET position = $1<br>
       WHERE reading_list_id = $2 AND article_id = $3</code>,<br>
      [newPosition, listId, articleId]<br>
    );<br>
  }</p><p>  /**<br>
   * Delete reading list<br>
   */<br>
  async deleteList(id: string): Promise&lt;void&gt; {<br>
    await execute('DELETE FROM reading_lists WHERE id = $1', [id]);<br>
  }</p><p>  /**<br>
   * Update reading list<br>
   */<br>
  async updateList(<br>
    id: string,<br>
    updates: { name?: string; description?: string }<br>
  ): Promise&lt;ReadingList | null&gt; {<br>
    const setClauses: string[] = [];<br>
    const params: unknown[] = [];<br>
    let paramIndex = 1;</p><p>    if (updates.name) {<br>
      setClauses.push(<code>name = $${paramIndex++}</code>);<br>
      params.push(updates.name);<br>
    }</p><p>    if (updates.description !== undefined) {<br>
      setClauses.push(<code>description = $${paramIndex++}</code>);<br>
      params.push(updates.description);<br>
    }</p><p>    if (setClauses.length === 0) return null;</p><p>    setClauses.push('updated_at = NOW()');<br>
    params.push(id);</p><p>    return queryOne&lt;ReadingList&gt;(<br>
      <code>UPDATE reading_lists SET ${setClauses.join(', ')} WHERE id = $${paramIndex} RETURNING *</code>,<br>
      params<br>
    );<br>
  }<br>
}</p><p>export const readingListService = new ReadingListService();</code></pre><h2>Full-Text Search</h2><p>PostgreSQL's full-text search is powerful and fast:</p><pre><code class="language-typescript">// src/services/search-service.ts<br>
import { query } from '../db/client.js';<br>
import type { Article } from '../types/index.js';</p><p>export interface SearchResult extends Article {<br>
  rank: number;<br>
  headline: string;<br>
}</p><p>export class SearchService {<br>
  /**<br>
   * Search articles<br>
   */<br>
  async search(<br>
    queryText: string,<br>
    options: {<br>
      feedId?: string;<br>
      tagId?: string;<br>
      limit?: number;<br>
      offset?: number;<br>
    } = {}<br>
  ): Promise&lt;{ results: SearchResult[]; total: number }&gt; {<br>
    const conditions: string[] = [];<br>
    const params: unknown[] = [];<br>
    let paramIndex = 1;</p><p>    // Full-text search condition<br>
    conditions.push(<br>
      <code>to_tsvector('english', a.title || ' ' || a.text_content) @@ plainto_tsquery('english', $${paramIndex++})</code><br>
    );<br>
    params.push(queryText);</p><p>    // Optional filters<br>
    if (options.feedId) {<br>
      conditions.push(<code>a.feed_id = $${paramIndex++}</code>);<br>
      params.push(options.feedId);<br>
    }</p><p>    if (options.tagId) {<br>
      conditions.push(<br>
        <code>EXISTS (SELECT 1 FROM article_tags at WHERE at.article_id = a.id AND at.tag_id = $${paramIndex++})</code><br>
      );<br>
      params.push(options.tagId);<br>
    }</p><p>    // Don't include archived by default<br>
    conditions.push('NOT a.is_archived');</p><p>    const whereClause = conditions.join(' AND ');</p><p>    // Get total count<br>
    const countResult = await query&lt;{ count: string }&gt;(<br>
      <code>SELECT COUNT(*)::text as count<br>
       FROM articles a<br>
       WHERE ${whereClause}</code>,<br>
      params<br>
    );<br>
    const total = parseInt(countResult[0]?.count ?? '0', 10);</p><p>    // Get results with ranking and headlines<br>
    const limit = options.limit ?? 20;<br>
    const offset = options.offset ?? 0;</p><p>    const results = await query&lt;SearchResult&gt;(<br>
      <code>SELECT a.*,<br>
              ts_rank(<br>
                to_tsvector('english', a.title || ' ' || a.text_content),<br>
                plainto_tsquery('english', $1)<br>
              ) as rank,<br>
              ts_headline(<br>
                'english',<br>
                a.text_content,<br>
                plainto_tsquery('english', $1),<br>
                'StartSel=&lt;mark&gt;, StopSel=&lt;/mark&gt;, MaxWords=50, MinWords=20'<br>
              ) as headline<br>
       FROM articles a<br>
       WHERE ${whereClause}<br>
       ORDER BY rank DESC, a.created_at DESC<br>
       LIMIT $${paramIndex++} OFFSET $${paramIndex++}</code>,<br>
      [...params, limit, offset]<br>
    );</p><p>    return { results, total };<br>
  }</p><p>  /**<br>
   * Get search suggestions (autocomplete)<br>
   */<br>
  async getSuggestions(prefix: string, limit = 10): Promise&lt;string[]&gt; {<br>
    // Search titles starting with prefix<br>
    const results = await query&lt;{ title: string }&gt;(<br>
      <code>SELECT DISTINCT title<br>
       FROM articles<br>
       WHERE LOWER(title) LIKE LOWER($1 || '%')<br>
       ORDER BY title<br>
       LIMIT $2</code>,<br>
      [prefix, limit]<br>
    );</p><p>    return results.map((r) =&gt; r.title);<br>
  }</p><p>  /**<br>
   * Get related articles<br>
   */<br>
  async getRelated(articleId: string, limit = 5): Promise&lt;Article[]&gt; {<br>
    // Find articles with similar content using full-text search<br>
    return query&lt;Article&gt;(<br>
      <code>WITH source AS (<br>
         SELECT title, text_content FROM articles WHERE id = $1<br>
       )<br>
       SELECT a.*<br>
       FROM articles a, source s<br>
       WHERE a.id != $1<br>
         AND NOT a.is_archived<br>
         AND to_tsvector('english', a.title || ' ' || a.text_content) @@<br>
             to_tsquery('english',<br>
               regexp_replace(<br>
                 regexp_replace(s.title, '[^a-zA-Z0-9\\s]', '', 'g'),<br>
                 '\\s+',<br>
                 ' | ',<br>
                 'g'<br>
               )<br>
             )<br>
       ORDER BY ts_rank(<br>
         to_tsvector('english', a.title || ' ' || a.text_content),<br>
         to_tsquery('english',<br>
           regexp_replace(<br>
             regexp_replace(s.title, '[^a-zA-Z0-9\\s]', '', 'g'),<br>
             '\\s+',<br>
             ' | ',<br>
             'g'<br>
           )<br>
         )<br>
       ) DESC<br>
       LIMIT $2</code>,<br>
      [articleId, limit]<br>
    );<br>
  }<br>
}</p><p>export const searchService = new SearchService();</code></pre><h2>Search API Routes</h2><pre><code class="language-typescript">// src/api/routes/search.ts<br>
import { Router } from 'express';<br>
import { searchService } from '../../services/search-service.js';<br>
import { AppError } from '../middleware/error.js';</p><p>export const searchRouter = Router();</p><p>// Full-text search<br>
searchRouter.get('/', async (req, res, next) =&gt; {<br>
  try {<br>
    const { q, feedId, tagId, limit, offset } = req.query;</p><p>    if (!q || typeof q !== 'string') {<br>
      throw new AppError(400, 'Search query required', 'MISSING_QUERY');<br>
    }</p><p>    const results = await searchService.search(q, {<br>
      feedId: feedId as string | undefined,<br>
      tagId: tagId as string | undefined,<br>
      limit: limit ? parseInt(limit as string, 10) : undefined,<br>
      offset: offset ? parseInt(offset as string, 10) : undefined,<br>
    });</p><p>    res.json(results);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Autocomplete suggestions<br>
searchRouter.get('/suggest', async (req, res, next) =&gt; {<br>
  try {<br>
    const { q, limit } = req.query;</p><p>    if (!q || typeof q !== 'string') {<br>
      res.json([]);<br>
      return;<br>
    }</p><p>    const suggestions = await searchService.getSuggestions(<br>
      q,<br>
      limit ? parseInt(limit as string, 10) : undefined<br>
    );</p><p>    res.json(suggestions);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Related articles<br>
searchRouter.get('/related/:articleId', async (req, res, next) =&gt; {<br>
  try {<br>
    const { limit } = req.query;</p><p>    const related = await searchService.getRelated(<br>
      req.params.articleId,<br>
      limit ? parseInt(limit as string, 10) : undefined<br>
    );</p><p>    res.json(related);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</code></pre><h2>Search UI Component</h2><pre><code class="language-typescript">// web/src/components/Search.ts</p><p>export class Search {<br>
  private container: HTMLElement;<br>
  private input: HTMLInputElement | null = null;<br>
  private results: HTMLElement | null = null;<br>
  private suggestions: HTMLElement | null = null;<br>
  private searchTimeout: number | null = null;</p><p>  constructor(containerId: string) {<br>
    const container = document.getElementById(containerId);<br>
    if (!container) throw new Error('Container not found');<br>
    this.container = container;</p><p>    this.render();<br>
    this.setupEventListeners();<br>
  }</p><p>  private render(): void {<br>
    this.container.innerHTML = <code><br>
      &lt;div class=&quot;search-container&quot;&gt;<br>
        &lt;div class=&quot;search-input-wrapper&quot;&gt;<br>
          &lt;input<br>
            type=&quot;search&quot;<br>
            class=&quot;search-input&quot;<br>
            placeholder=&quot;Search articles...&quot;<br>
            autocomplete=&quot;off&quot;<br>
          /&gt;<br>
          &lt;div class=&quot;search-suggestions&quot;&gt;&lt;/div&gt;<br>
        &lt;/div&gt;<br>
        &lt;div class=&quot;search-results&quot;&gt;&lt;/div&gt;<br>
      &lt;/div&gt;<br>
    </code>;</p><p>    this.input = this.container.querySelector('.search-input');<br>
    this.results = this.container.querySelector('.search-results');<br>
    this.suggestions = this.container.querySelector('.search-suggestions');<br>
  }</p><p>  private setupEventListeners(): void {<br>
    if (!this.input) return;</p><p>    // Input handler with debounce<br>
    this.input.addEventListener('input', () =&gt; {<br>
      if (this.searchTimeout) {<br>
        clearTimeout(this.searchTimeout);<br>
      }</p><p>      const query = this.input?.value.trim();</p><p>      if (!query) {<br>
        this.hideSuggestions();<br>
        this.clearResults();<br>
        return;<br>
      }</p><p>      // Show suggestions after short delay<br>
      this.searchTimeout = window.setTimeout(() =&gt; {<br>
        this.fetchSuggestions(query);<br>
      }, 150);<br>
    });</p><p>    // Submit handler for full search<br>
    this.input.addEventListener('keydown', (e) =&gt; {<br>
      if (e.key === 'Enter') {<br>
        e.preventDefault();<br>
        this.hideSuggestions();<br>
        const query = this.input?.value.trim();<br>
        if (query) {<br>
          this.performSearch(query);<br>
        }<br>
      }</p><p>      if (e.key === 'Escape') {<br>
        this.hideSuggestions();<br>
      }<br>
    });</p><p>    // Click outside to close suggestions<br>
    document.addEventListener('click', (e) =&gt; {<br>
      if (!this.container.contains(e.target as Node)) {<br>
        this.hideSuggestions();<br>
      }<br>
    });<br>
  }</p><p>  private async fetchSuggestions(query: string): Promise&lt;void&gt; {<br>
    try {<br>
      const response = await fetch(<br>
        <code>/api/search/suggest?q=${encodeURIComponent(query)}</code><br>
      );<br>
      const suggestions = await response.json();<br>
      this.showSuggestions(suggestions);<br>
    } catch {<br>
      this.hideSuggestions();<br>
    }<br>
  }</p><p>  private showSuggestions(items: string[]): void {<br>
    if (!this.suggestions || items.length === 0) {<br>
      this.hideSuggestions();<br>
      return;<br>
    }</p><p>    this.suggestions.innerHTML = items<br>
      .map(<br>
        (item) =&gt; <code><br>
        &lt;div class=&quot;suggestion-item&quot; data-value=&quot;${this.escapeHtml(item)}&quot;&gt;<br>
          ${this.escapeHtml(item)}<br>
        &lt;/div&gt;<br>
      </code><br>
      )<br>
      .join('');</p><p>    this.suggestions.style.display = 'block';</p><p>    // Click handlers for suggestions<br>
    this.suggestions.querySelectorAll('.suggestion-item').forEach((el) =&gt; {<br>
      el.addEventListener('click', () =&gt; {<br>
        const value = el.getAttribute('data-value');<br>
        if (value &amp;&amp; this.input) {<br>
          this.input.value = value;<br>
          this.hideSuggestions();<br>
          this.performSearch(value);<br>
        }<br>
      });<br>
    });<br>
  }</p><p>  private hideSuggestions(): void {<br>
    if (this.suggestions) {<br>
      this.suggestions.style.display = 'none';<br>
    }<br>
  }</p><p>  private async performSearch(query: string): Promise&lt;void&gt; {<br>
    if (!this.results) return;</p><p>    this.results.innerHTML = '&lt;div class=&quot;search-loading&quot;&gt;Searching...&lt;/div&gt;';</p><p>    try {<br>
      const response = await fetch(<br>
        <code>/api/search?q=${encodeURIComponent(query)}</code><br>
      );<br>
      const data = await response.json();<br>
      this.renderResults(data.results, data.total);<br>
    } catch {<br>
      this.results.innerHTML =<br>
        '&lt;div class=&quot;search-error&quot;&gt;Search failed. Please try again.&lt;/div&gt;';<br>
    }<br>
  }</p><p>  private renderResults(<br>
    results: Array&lt;{<br>
      id: string;<br>
      title: string;<br>
      headline: string;<br>
      author: string | null;<br>
      readingTimeMinutes: number;<br>
    }&gt;,<br>
    total: number<br>
  ): void {<br>
    if (!this.results) return;</p><p>    if (results.length === 0) {<br>
      this.results.innerHTML =<br>
        '&lt;div class=&quot;search-empty&quot;&gt;No articles found.&lt;/div&gt;';<br>
      return;<br>
    }</p><p>    this.results.innerHTML = <code><br>
      &lt;div class=&quot;search-meta&quot;&gt;${total} result${total === 1 ? '' : 's'}&lt;/div&gt;<br>
      &lt;div class=&quot;search-items&quot;&gt;<br>
        ${results<br>
          .map(<br>
            (r) =&gt; </code><br>
          &lt;article class=&quot;search-result&quot; data-id=&quot;${r.id}&quot;&gt;<br>
            &lt;h3 class=&quot;result-title&quot;&gt;${this.escapeHtml(r.title)}&lt;/h3&gt;<br>
            &lt;p class=&quot;result-headline&quot;&gt;${r.headline}&lt;/p&gt;<br>
            &lt;div class=&quot;result-meta&quot;&gt;<br>
              ${r.author ? <code>&lt;span&gt;${this.escapeHtml(r.author)}&lt;/span&gt;</code> : ''}<br>
              &lt;span&gt;${r.readingTimeMinutes} min read&lt;/span&gt;<br>
            &lt;/div&gt;<br>
          &lt;/article&gt;<br>
        <code><br>
          )<br>
          .join('')}<br>
      &lt;/div&gt;<br>
    </code>;</p><p>    // Click handlers<br>
    this.results.querySelectorAll('.search-result').forEach((el) =&gt; {<br>
      el.addEventListener('click', () =&gt; {<br>
        const id = el.getAttribute('data-id');<br>
        if (id) {<br>
          window.location.href = <code>/read/${id}</code>;<br>
        }<br>
      });<br>
    });<br>
  }</p><p>  private clearResults(): void {<br>
    if (this.results) {<br>
      this.results.innerHTML = '';<br>
    }<br>
  }</p><p>  private escapeHtml(str: string): string {<br>
    const div = document.createElement('div');<br>
    div.textContent = str;<br>
    return div.innerHTML;<br>
  }<br>
}</code></pre><h2>Search Styles</h2><pre><code class="language-css">/<em> styles/search.css </em>/</p><p>.search-container {<br>
  max-width: 800px;<br>
  margin: 0 auto;<br>
  padding: var(--space-4);<br>
}</p><p>.search-input-wrapper {<br>
  position: relative;<br>
}</p><p>.search-input {<br>
  width: 100%;<br>
  padding: var(--space-3) var(--space-4);<br>
  font-size: 1.125rem;<br>
  border: 2px solid var(--color-border);<br>
  border-radius: 8px;<br>
  background: var(--color-bg);<br>
  color: var(--color-text);<br>
}</p><p>.search-input:focus {<br>
  outline: none;<br>
  border-color: var(--color-link);<br>
}</p><p>.search-suggestions {<br>
  display: none;<br>
  position: absolute;<br>
  top: 100%;<br>
  left: 0;<br>
  right: 0;<br>
  background: var(--color-bg);<br>
  border: 1px solid var(--color-border);<br>
  border-top: none;<br>
  border-radius: 0 0 8px 8px;<br>
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);<br>
  z-index: 100;<br>
}</p><p>.suggestion-item {<br>
  padding: var(--space-3) var(--space-4);<br>
  cursor: pointer;<br>
}</p><p>.suggestion-item:hover {<br>
  background: var(--color-bg-secondary);<br>
}</p><p>.search-meta {<br>
  font-size: 0.875rem;<br>
  color: var(--color-text-secondary);<br>
  margin: var(--space-4) 0;<br>
}</p><p>.search-result {<br>
  padding: var(--space-4);<br>
  border-bottom: 1px solid var(--color-border);<br>
  cursor: pointer;<br>
  transition: background 0.15s;<br>
}</p><p>.search-result:hover {<br>
  background: var(--color-bg-secondary);<br>
}</p><p>.result-title {<br>
  font-size: 1.125rem;<br>
  font-weight: 600;<br>
  margin: 0 0 var(--space-2);<br>
}</p><p>.result-headline {<br>
  font-size: 0.875rem;<br>
  color: var(--color-text-secondary);<br>
  margin: 0 0 var(--space-2);<br>
  line-height: 1.5;<br>
}</p><p>.result-headline mark {<br>
  background: var(--color-highlight);<br>
  color: inherit;<br>
  padding: 0 2px;<br>
}</p><p>.result-meta {<br>
  display: flex;<br>
  gap: var(--space-3);<br>
  font-size: 0.75rem;<br>
  color: var(--color-text-secondary);<br>
}</p><p>.search-loading,<br>
.search-empty,<br>
.search-error {<br>
  padding: var(--space-8);<br>
  text-align: center;<br>
  color: var(--color-text-secondary);<br>
}</code></pre><h2>Tag and Reading List APIs</h2><pre><code class="language-typescript">// src/api/routes/tags.ts<br>
import { Router } from 'express';<br>
import { tagService } from '../../services/tag-service.js';<br>
import { autoTagger } from '../../services/auto-tagger.js';<br>
import { AppError } from '../middleware/error.js';</p><p>export const tagsRouter = Router();</p><p>tagsRouter.get('/', async (_req, res, next) =&gt; {<br>
  try {<br>
    const tags = await tagService.getAllTags();<br>
    res.json(tags);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>tagsRouter.post('/', async (req, res, next) =&gt; {<br>
  try {<br>
    const { name, color } = req.body;</p><p>    if (!name) {<br>
      throw new AppError(400, 'Name required', 'MISSING_NAME');<br>
    }</p><p>    const tag = await tagService.createTag(name, color);<br>
    res.status(201).json(tag);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>tagsRouter.patch('/:id', async (req, res, next) =&gt; {<br>
  try {<br>
    const { name, color } = req.body;<br>
    const tag = await tagService.updateTag(req.params.id, { name, color });</p><p>    if (!tag) {<br>
      throw new AppError(404, 'Tag not found', 'TAG_NOT_FOUND');<br>
    }</p><p>    res.json(tag);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>tagsRouter.delete('/:id', async (req, res, next) =&gt; {<br>
  try {<br>
    await tagService.deleteTag(req.params.id);<br>
    res.status(204).send();<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Auto-tag an article<br>
tagsRouter.post('/auto/:articleId', async (req, res, next) =&gt; {<br>
  try {<br>
    const tags = await autoTagger.autoTag(req.params.articleId);<br>
    res.json(tags);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</code></pre><pre><code class="language-typescript">// src/api/routes/reading-lists.ts<br>
import { Router } from 'express';<br>
import { readingListService } from '../../services/reading-list-service.js';<br>
import { AppError } from '../middleware/error.js';</p><p>export const readingListsRouter = Router();</p><p>readingListsRouter.get('/', async (_req, res, next) =&gt; {<br>
  try {<br>
    const lists = await readingListService.getAllLists();<br>
    res.json(lists);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>readingListsRouter.post('/', async (req, res, next) =&gt; {<br>
  try {<br>
    const { name, description } = req.body;</p><p>    if (!name) {<br>
      throw new AppError(400, 'Name required', 'MISSING_NAME');<br>
    }</p><p>    const list = await readingListService.createList(name, description);<br>
    res.status(201).json(list);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>readingListsRouter.get('/:id', async (req, res, next) =&gt; {<br>
  try {<br>
    const list = await readingListService.getListWithArticles(req.params.id);</p><p>    if (!list) {<br>
      throw new AppError(404, 'List not found', 'LIST_NOT_FOUND');<br>
    }</p><p>    res.json(list);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>readingListsRouter.patch('/:id', async (req, res, next) =&gt; {<br>
  try {<br>
    const { name, description } = req.body;<br>
    const list = await readingListService.updateList(req.params.id, {<br>
      name,<br>
      description,<br>
    });</p><p>    if (!list) {<br>
      throw new AppError(404, 'List not found', 'LIST_NOT_FOUND');<br>
    }</p><p>    res.json(list);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>readingListsRouter.delete('/:id', async (req, res, next) =&gt; {<br>
  try {<br>
    await readingListService.deleteList(req.params.id);<br>
    res.status(204).send();<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Add article to list<br>
readingListsRouter.post('/:id/articles', async (req, res, next) =&gt; {<br>
  try {<br>
    const { articleId } = req.body;</p><p>    if (!articleId) {<br>
      throw new AppError(400, 'articleId required', 'MISSING_ARTICLE_ID');<br>
    }</p><p>    await readingListService.addArticle(req.params.id, articleId);<br>
    res.status(204).send();<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Remove article from list<br>
readingListsRouter.delete('/:id/articles/:articleId', async (req, res, next) =&gt; {<br>
  try {<br>
    await readingListService.removeArticle(<br>
      req.params.id,<br>
      req.params.articleId<br>
    );<br>
    res.status(204).send();<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Reorder article<br>
readingListsRouter.post('/:id/reorder', async (req, res, next) =&gt; {<br>
  try {<br>
    const { articleId, position } = req.body;</p><p>    if (!articleId || position === undefined) {<br>
      throw new AppError(400, 'articleId and position required', 'MISSING_PARAMS');<br>
    }</p><p>    await readingListService.reorderArticle(req.params.id, articleId, position);<br>
    res.status(204).send();<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</code></pre><h2>Next Steps</h2><p>With organization in place, the final chapter covers deployment—self-hosting, cross-device sync, and backup strategies.<br>
</p>
    </section>
  

    <section id="chapter-7" class="chapter">
      <h2>Deployment and Sync</h2>
      <h2>Deployment Options</h2><p>A personal reading library has unique deployment considerations:</p><p>- <strong>Single user</strong> - no multi-tenancy complexity<br>
- <strong>Always available</strong> - you want your library accessible<br>
- <strong>Private data</strong> - your reading habits are personal<br>
- <strong>Offline capable</strong> - reading on planes, in subways</p><p>We'll cover three deployment approaches:</p><p>1. <strong>Local only</strong> - runs on your computer<br>
2. <strong>Self-hosted server</strong> - VPS or home server<br>
3. <strong>Hybrid</strong> - local with cloud sync</p><h2>Local Development Build</h2><p>For local-only use, build and run:</p><pre><code class="language-bash"># Build everything<br>
npm run build</p><h1>Run with Node</h1><br>
node dist/api/index.js</code></pre><p>Create a startup script:</p><pre><code class="language-bash">#!/bin/bash<br>
<h1>start-library.sh</h1><h1>Start database</h1><br>
docker-compose up -d db</p><h1>Wait for DB</h1><br>
sleep 3</p><h1>Start API</h1><br>
node dist/api/index.js &amp;</p><h1>Open browser</h1><br>
open http://localhost:3000</code></pre><h2>Docker Deployment</h2><p>Package everything in Docker for portability:</p><pre><code class="language-dockerfile"># Dockerfile<br>
FROM node:22-alpine AS builder</p><p>WORKDIR /app<br>
COPY package*.json ./<br>
RUN npm ci</p><p>COPY . .<br>
RUN npm run build</p><p>FROM node:22-alpine AS runner</p><p>WORKDIR /app<br>
ENV NODE_ENV=production</p><p>COPY --from=builder /app/dist ./dist<br>
COPY --from=builder /app/node_modules ./node_modules<br>
COPY --from=builder /app/package.json ./</p><p>EXPOSE 3000</p><p>CMD [&quot;node&quot;, &quot;dist/api/index.js&quot;]</code></pre><p>Docker Compose for full stack:</p><pre><code class="language-yaml"># docker-compose.prod.yml<br>
version: '3.8'</p><p>services:<br>
  api:<br>
    build: .<br>
    ports:<br>
      - &quot;3000:3000&quot;<br>
    environment:<br>
      DATABASE_URL: postgresql://library:library@db:5432/reading_library<br>
      NODE_ENV: production<br>
    depends_on:<br>
      db:<br>
        condition: service_healthy<br>
    restart: unless-stopped</p><p>  db:<br>
    image: postgres:16-alpine<br>
    environment:<br>
      POSTGRES_USER: library<br>
      POSTGRES_PASSWORD: library<br>
      POSTGRES_DB: reading_library<br>
    volumes:<br>
      - postgres_data:/var/lib/postgresql/data<br>
      - ./src/db/migrations:/docker-entrypoint-initdb.d<br>
    healthcheck:<br>
      test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U library&quot;]<br>
      interval: 5s<br>
      timeout: 5s<br>
      retries: 5<br>
    restart: unless-stopped</p><p>volumes:<br>
  postgres_data:</code></pre><p>Run with:</p><pre><code class="language-bash">docker-compose -f docker-compose.prod.yml up -d</code></pre><h2>VPS Deployment</h2><p>For a dedicated server (DigitalOcean, Linode, Hetzner):</p><h3>Server Setup</h3><pre><code class="language-bash"># Update system<br>
sudo apt update &amp;&amp; sudo apt upgrade -y</p><h1>Install Docker</h1><br>
curl -fsSL https://get.docker.com | sh<br>
sudo usermod -aG docker $USER</p><h1>Install Docker Compose</h1><br>
sudo apt install docker-compose-plugin -y</p><h1>Create app directory</h1><br>
mkdir -p ~/reading-library<br>
cd ~/reading-library</code></pre><h3>Nginx Reverse Proxy</h3><pre><code class="language-nginx"># /etc/nginx/sites-available/library<br>
server {<br>
    listen 80;<br>
    server_name library.yourdomain.com;</p><p>    location / {<br>
        proxy_pass http://localhost:3000;<br>
        proxy_http_version 1.1;<br>
        proxy_set_header Upgrade $http_upgrade;<br>
        proxy_set_header Connection 'upgrade';<br>
        proxy_set_header Host $host;<br>
        proxy_set_header X-Real-IP $remote_addr;<br>
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>
        proxy_set_header X-Forwarded-Proto $scheme;<br>
        proxy_cache_bypass $http_upgrade;<br>
    }<br>
}</code></pre><h3>SSL with Let's Encrypt</h3><pre><code class="language-bash"># Install Certbot<br>
sudo apt install certbot python3-certbot-nginx -y</p><h1>Get certificate</h1><br>
sudo certbot --nginx -d library.yourdomain.com</p><h1>Auto-renewal is configured automatically</code></pre></h1><h3>Systemd Service</h3><pre><code class="language-ini"># /etc/systemd/system/reading-library.service<br>
[Unit]<br>
Description=Reading Library<br>
Requires=docker.service<br>
After=docker.service</p><p>[Service]<br>
Type=oneshot<br>
RemainAfterExit=yes<br>
WorkingDirectory=/home/user/reading-library<br>
ExecStart=/usr/bin/docker compose -f docker-compose.prod.yml up -d<br>
ExecStop=/usr/bin/docker compose -f docker-compose.prod.yml down</p><p>[Install]<br>
WantedBy=multi-user.target</code></pre><p>Enable and start:</p><pre><code class="language-bash">sudo systemctl enable reading-library<br>
sudo systemctl start reading-library</code></pre><h2>Authentication</h2><p>For a public server, add authentication:</p><pre><code class="language-typescript">// src/api/middleware/auth.ts<br>
import { Request, Response, NextFunction } from 'express';<br>
import crypto from 'crypto';</p><p>const API_KEY = process.env.API_KEY;</p><p>export function authMiddleware(<br>
  req: Request,<br>
  res: Response,<br>
  next: NextFunction<br>
): void {<br>
  // Skip auth in development<br>
  if (process.env.NODE_ENV !== 'production') {<br>
    next();<br>
    return;<br>
  }</p><p>  // Check API key header<br>
  const apiKey = req.headers['x-api-key'];</p><p>  if (!apiKey || !API_KEY) {<br>
    res.status(401).json({ error: 'Unauthorized' });<br>
    return;<br>
  }</p><p>  // Constant-time comparison<br>
  const valid = crypto.timingSafeEqual(<br>
    Buffer.from(apiKey as string),<br>
    Buffer.from(API_KEY)<br>
  );</p><p>  if (!valid) {<br>
    res.status(401).json({ error: 'Unauthorized' });<br>
    return;<br>
  }</p><p>  next();<br>
}</code></pre><p>Apply to routes:</p><pre><code class="language-typescript">// src/api/index.ts<br>
import { authMiddleware } from './middleware/auth.js';</p><p>// Apply to all API routes<br>
app.use('/api', authMiddleware);</code></pre><p>Generate a secure API key:</p><pre><code class="language-bash">openssl rand -hex 32</code></pre><h2>Offline Support with Service Worker</h2><p>Make the app work offline:</p><pre><code class="language-typescript">// web/src/sw.ts<br>
const CACHE_NAME = 'reading-library-v1';<br>
const STATIC_ASSETS = [<br>
  '/',<br>
  '/index.html',<br>
  '/src/main.ts',<br>
  '/src/styles/main.css',<br>
];</p><p>// Install: cache static assets<br>
self.addEventListener('install', (event: ExtendableEvent) =&gt; {<br>
  event.waitUntil(<br>
    caches.open(CACHE_NAME).then((cache) =&gt; {<br>
      return cache.addAll(STATIC_ASSETS);<br>
    })<br>
  );<br>
});</p><p>// Activate: clean old caches<br>
self.addEventListener('activate', (event: ExtendableEvent) =&gt; {<br>
  event.waitUntil(<br>
    caches.keys().then((keys) =&gt; {<br>
      return Promise.all(<br>
        keys<br>
          .filter((key) =&gt; key !== CACHE_NAME)<br>
          .map((key) =&gt; caches.delete(key))<br>
      );<br>
    })<br>
  );<br>
});</p><p>// Fetch: serve from cache, fallback to network<br>
self.addEventListener('fetch', (event: FetchEvent) =&gt; {<br>
  const url = new URL(event.request.url);</p><p>  // API requests: network first<br>
  if (url.pathname.startsWith('/api')) {<br>
    event.respondWith(<br>
      fetch(event.request)<br>
        .then((response) =&gt; {<br>
          // Cache successful GET responses<br>
          if (event.request.method === 'GET' &amp;&amp; response.ok) {<br>
            const clone = response.clone();<br>
            caches.open(CACHE_NAME).then((cache) =&gt; {<br>
              cache.put(event.request, clone);<br>
            });<br>
          }<br>
          return response;<br>
        })<br>
        .catch(() =&gt; {<br>
          // Offline: try cache<br>
          return caches.match(event.request).then((cached) =&gt; {<br>
            if (cached) return cached;<br>
            return new Response(<br>
              JSON.stringify({ error: 'Offline' }),<br>
              { status: 503, headers: { 'Content-Type': 'application/json' } }<br>
            );<br>
          });<br>
        })<br>
    );<br>
    return;<br>
  }</p><p>  // Static assets: cache first<br>
  event.respondWith(<br>
    caches.match(event.request).then((cached) =&gt; {<br>
      if (cached) return cached;</p><p>      return fetch(event.request).then((response) =&gt; {<br>
        if (response.ok) {<br>
          const clone = response.clone();<br>
          caches.open(CACHE_NAME).then((cache) =&gt; {<br>
            cache.put(event.request, clone);<br>
          });<br>
        }<br>
        return response;<br>
      });<br>
    })<br>
  );<br>
});</code></pre><p>Register the service worker:</p><pre><code class="language-typescript">// web/src/main.ts<br>
if ('serviceWorker' in navigator) {<br>
  navigator.serviceWorker<br>
    .register('/sw.js')<br>
    .then((reg) =&gt; console.log('SW registered:', reg.scope))<br>
    .catch((err) =&gt; console.error('SW registration failed:', err));<br>
}</code></pre><h2>IndexedDB for Offline Articles</h2><p>Cache articles locally for offline reading:</p><pre><code class="language-typescript">// web/src/services/offline-storage.ts</p><p>const DB_NAME = 'reading-library';<br>
const DB_VERSION = 1;</p><p>interface OfflineArticle {<br>
  id: string;<br>
  title: string;<br>
  content: string;<br>
  textContent: string;<br>
  savedAt: number;<br>
}</p><p>export class OfflineStorage {<br>
  private db: IDBDatabase | null = null;</p><p>  async init(): Promise&lt;void&gt; {<br>
    return new Promise((resolve, reject) =&gt; {<br>
      const request = indexedDB.open(DB_NAME, DB_VERSION);</p><p>      request.onerror = () =&gt; reject(request.error);<br>
      request.onsuccess = () =&gt; {<br>
        this.db = request.result;<br>
        resolve();<br>
      };</p><p>      request.onupgradeneeded = (event) =&gt; {<br>
        const db = (event.target as IDBOpenDBRequest).result;</p><p>        // Articles store<br>
        if (!db.objectStoreNames.contains('articles')) {<br>
          const store = db.createObjectStore('articles', { keyPath: 'id' });<br>
          store.createIndex('savedAt', 'savedAt');<br>
        }</p><p>        // Progress store<br>
        if (!db.objectStoreNames.contains('progress')) {<br>
          db.createObjectStore('progress', { keyPath: 'articleId' });<br>
        }<br>
      };<br>
    });<br>
  }</p><p>  async saveArticle(article: OfflineArticle): Promise&lt;void&gt; {<br>
    if (!this.db) await this.init();</p><p>    return new Promise((resolve, reject) =&gt; {<br>
      const tx = this.db!.transaction('articles', 'readwrite');<br>
      const store = tx.objectStore('articles');</p><p>      const request = store.put({<br>
        ...article,<br>
        savedAt: Date.now(),<br>
      });</p><p>      request.onerror = () =&gt; reject(request.error);<br>
      request.onsuccess = () =&gt; resolve();<br>
    });<br>
  }</p><p>  async getArticle(id: string): Promise&lt;OfflineArticle | null&gt; {<br>
    if (!this.db) await this.init();</p><p>    return new Promise((resolve, reject) =&gt; {<br>
      const tx = this.db!.transaction('articles', 'readonly');<br>
      const store = tx.objectStore('articles');<br>
      const request = store.get(id);</p><p>      request.onerror = () =&gt; reject(request.error);<br>
      request.onsuccess = () =&gt; resolve(request.result ?? null);<br>
    });<br>
  }</p><p>  async getAllArticles(): Promise&lt;OfflineArticle[]&gt; {<br>
    if (!this.db) await this.init();</p><p>    return new Promise((resolve, reject) =&gt; {<br>
      const tx = this.db!.transaction('articles', 'readonly');<br>
      const store = tx.objectStore('articles');<br>
      const request = store.getAll();</p><p>      request.onerror = () =&gt; reject(request.error);<br>
      request.onsuccess = () =&gt; resolve(request.result);<br>
    });<br>
  }</p><p>  async deleteArticle(id: string): Promise&lt;void&gt; {<br>
    if (!this.db) await this.init();</p><p>    return new Promise((resolve, reject) =&gt; {<br>
      const tx = this.db!.transaction('articles', 'readwrite');<br>
      const store = tx.objectStore('articles');<br>
      const request = store.delete(id);</p><p>      request.onerror = () =&gt; reject(request.error);<br>
      request.onsuccess = () =&gt; resolve();<br>
    });<br>
  }</p><p>  async saveProgress(<br>
    articleId: string,<br>
    progress: { scrollPosition?: number; audioPosition?: number }<br>
  ): Promise&lt;void&gt; {<br>
    if (!this.db) await this.init();</p><p>    return new Promise((resolve, reject) =&gt; {<br>
      const tx = this.db!.transaction('progress', 'readwrite');<br>
      const store = tx.objectStore('progress');</p><p>      const request = store.put({<br>
        articleId,<br>
        ...progress,<br>
        updatedAt: Date.now(),<br>
      });</p><p>      request.onerror = () =&gt; reject(request.error);<br>
      request.onsuccess = () =&gt; resolve();<br>
    });<br>
  }</p><p>  async getProgress(<br>
    articleId: string<br>
  ): Promise&lt;{ scrollPosition: number; audioPosition: number } | null&gt; {<br>
    if (!this.db) await this.init();</p><p>    return new Promise((resolve, reject) =&gt; {<br>
      const tx = this.db!.transaction('progress', 'readonly');<br>
      const store = tx.objectStore('progress');<br>
      const request = store.get(articleId);</p><p>      request.onerror = () =&gt; reject(request.error);<br>
      request.onsuccess = () =&gt; resolve(request.result ?? null);<br>
    });<br>
  }<br>
}</p><p>export const offlineStorage = new OfflineStorage();</code></pre><h2>Sync Strategy</h2><p>Sync local changes when back online:</p><pre><code class="language-typescript">// web/src/services/sync-service.ts</p><p>import { offlineStorage } from './offline-storage.js';</p><p>interface SyncQueue {<br>
  id: string;<br>
  type: 'progress' | 'read' | 'favorite' | 'archive';<br>
  articleId: string;<br>
  data: Record&lt;string, unknown&gt;;<br>
  timestamp: number;<br>
}</p><p>export class SyncService {<br>
  private queue: SyncQueue[] = [];<br>
  private syncing = false;</p><p>  constructor() {<br>
    this.loadQueue();<br>
    this.setupOnlineListener();<br>
  }</p><p>  private loadQueue(): void {<br>
    const saved = localStorage.getItem('sync-queue');<br>
    if (saved) {<br>
      this.queue = JSON.parse(saved);<br>
    }<br>
  }</p><p>  private saveQueue(): void {<br>
    localStorage.setItem('sync-queue', JSON.stringify(this.queue));<br>
  }</p><p>  /**<br>
   * Add action to sync queue<br>
   */<br>
  queueAction(<br>
    type: SyncQueue['type'],<br>
    articleId: string,<br>
    data: Record&lt;string, unknown&gt;<br>
  ): void {<br>
    this.queue.push({<br>
      id: crypto.randomUUID(),<br>
      type,<br>
      articleId,<br>
      data,<br>
      timestamp: Date.now(),<br>
    });<br>
    this.saveQueue();</p><p>    // Try to sync immediately if online<br>
    if (navigator.onLine) {<br>
      this.sync();<br>
    }<br>
  }</p><p>  /**<br>
   * Listen for online status changes<br>
   */<br>
  private setupOnlineListener(): void {<br>
    window.addEventListener('online', () =&gt; {<br>
      console.log('Back online, syncing...');<br>
      this.sync();<br>
    });<br>
  }</p><p>  /**<br>
   * Sync queued actions<br>
   */<br>
  async sync(): Promise&lt;void&gt; {<br>
    if (this.syncing || this.queue.length === 0 || !navigator.onLine) {<br>
      return;<br>
    }</p><p>    this.syncing = true;</p><p>    try {<br>
      const toSync = [...this.queue];</p><p>      for (const item of toSync) {<br>
        try {<br>
          await this.syncItem(item);<br>
          // Remove from queue on success<br>
          this.queue = this.queue.filter((q) =&gt; q.id !== item.id);<br>
          this.saveQueue();<br>
        } catch (error) {<br>
          console.error('Sync failed for item:', item, error);<br>
          // Keep in queue to retry later<br>
        }<br>
      }<br>
    } finally {<br>
      this.syncing = false;<br>
    }<br>
  }</p><p>  private async syncItem(item: SyncQueue): Promise&lt;void&gt; {<br>
    switch (item.type) {<br>
      case 'progress':<br>
        await fetch(<code>/api/articles/${item.articleId}/progress</code>, {<br>
          method: 'PUT',<br>
          headers: { 'Content-Type': 'application/json' },<br>
          body: JSON.stringify(item.data),<br>
        });<br>
        break;</p><p>      case 'read':<br>
        await fetch(<code>/api/articles/${item.articleId}/read</code>, {<br>
          method: 'POST',<br>
        });<br>
        break;</p><p>      case 'favorite':<br>
        await fetch(<code>/api/articles/${item.articleId}/favorite</code>, {<br>
          method: 'POST',<br>
        });<br>
        break;</p><p>      case 'archive':<br>
        await fetch(<code>/api/articles/${item.articleId}/archive</code>, {<br>
          method: 'POST',<br>
        });<br>
        break;<br>
    }<br>
  }</p><p>  /**<br>
   * Get pending sync count<br>
   */<br>
  getPendingCount(): number {<br>
    return this.queue.length;<br>
  }<br>
}</p><p>export const syncService = new SyncService();</code></pre><h2>Backup Strategy</h2><p>Regular backups are essential:</p><pre><code class="language-typescript">// src/services/backup-service.ts<br>
import { query } from '../db/client.js';<br>
import fs from 'fs/promises';<br>
import path from 'path';</p><p>export class BackupService {<br>
  private backupDir: string;</p><p>  constructor(backupDir: string = './backups') {<br>
    this.backupDir = backupDir;<br>
  }</p><p>  /**<br>
   * Create a full backup<br>
   */<br>
  async createBackup(): Promise&lt;string&gt; {<br>
    await fs.mkdir(this.backupDir, { recursive: true });</p><p>    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');<br>
    const filename = <code>backup-${timestamp}.json</code>;<br>
    const filepath = path.join(this.backupDir, filename);</p><p>    // Export all data<br>
    const data = {<br>
      version: 1,<br>
      timestamp: new Date().toISOString(),<br>
      feeds: await query('SELECT * FROM feeds'),<br>
      articles: await query('SELECT * FROM articles'),<br>
      tags: await query('SELECT * FROM tags'),<br>
      articleTags: await query('SELECT * FROM article_tags'),<br>
      readingLists: await query('SELECT * FROM reading_lists'),<br>
      readingListArticles: await query('SELECT * FROM reading_list_articles'),<br>
      readingProgress: await query('SELECT * FROM reading_progress'),<br>
    };</p><p>    await fs.writeFile(filepath, JSON.stringify(data, null, 2));</p><p>    return filepath;<br>
  }</p><p>  /**<br>
   * Restore from backup<br>
   */<br>
  async restoreBackup(filepath: string): Promise&lt;void&gt; {<br>
    const content = await fs.readFile(filepath, 'utf-8');<br>
    const data = JSON.parse(content);</p><p>    if (data.version !== 1) {<br>
      throw new Error(<code>Unsupported backup version: ${data.version}</code>);<br>
    }</p><p>    // Clear existing data<br>
    await query('TRUNCATE reading_progress, reading_list_articles, reading_lists, article_tags, tags, articles, feeds CASCADE');</p><p>    // Restore in order (respecting foreign keys)<br>
    for (const feed of data.feeds) {<br>
      await query(<br>
        <code>INSERT INTO feeds (id, url, title, description, site_url, favicon_url, last_fetched_at, fetch_error, is_active, created_at, updated_at)<br>
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)</code>,<br>
        [feed.id, feed.url, feed.title, feed.description, feed.site_url, feed.favicon_url, feed.last_fetched_at, feed.fetch_error, feed.is_active, feed.created_at, feed.updated_at]<br>
      );<br>
    }</p><p>    for (const article of data.articles) {<br>
      await query(<br>
        <code>INSERT INTO articles (id, feed_id, url, title, author, published_at, content, text_content, excerpt, word_count, reading_time_minutes, image_url, is_read, is_archived, is_favorite, created_at, updated_at)<br>
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)</code>,<br>
        [article.id, article.feed_id, article.url, article.title, article.author, article.published_at, article.content, article.text_content, article.excerpt, article.word_count, article.reading_time_minutes, article.image_url, article.is_read, article.is_archived, article.is_favorite, article.created_at, article.updated_at]<br>
      );<br>
    }</p><p>    for (const tag of data.tags) {<br>
      await query(<br>
        <code>INSERT INTO tags (id, name, color, created_at) VALUES ($1, $2, $3, $4)</code>,<br>
        [tag.id, tag.name, tag.color, tag.created_at]<br>
      );<br>
    }</p><p>    for (const at of data.articleTags) {<br>
      await query(<br>
        <code>INSERT INTO article_tags (article_id, tag_id) VALUES ($1, $2)</code>,<br>
        [at.article_id, at.tag_id]<br>
      );<br>
    }</p><p>    for (const list of data.readingLists) {<br>
      await query(<br>
        <code>INSERT INTO reading_lists (id, name, description, is_default, position, created_at, updated_at)<br>
         VALUES ($1, $2, $3, $4, $5, $6, $7)</code>,<br>
        [list.id, list.name, list.description, list.is_default, list.position, list.created_at, list.updated_at]<br>
      );<br>
    }</p><p>    for (const rla of data.readingListArticles) {<br>
      await query(<br>
        <code>INSERT INTO reading_list_articles (reading_list_id, article_id, position, added_at)<br>
         VALUES ($1, $2, $3, $4)</code>,<br>
        [rla.reading_list_id, rla.article_id, rla.position, rla.added_at]<br>
      );<br>
    }</p><p>    for (const progress of data.readingProgress) {<br>
      await query(<br>
        <code>INSERT INTO reading_progress (id, article_id, scroll_position, audio_position, last_read_at)<br>
         VALUES ($1, $2, $3, $4, $5)</code>,<br>
        [progress.id, progress.article_id, progress.scroll_position, progress.audio_position, progress.last_read_at]<br>
      );<br>
    }<br>
  }</p><p>  /**<br>
   * List available backups<br>
   */<br>
  async listBackups(): Promise&lt;Array&lt;{ filename: string; size: number; created: Date }&gt;&gt; {<br>
    try {<br>
      const files = await fs.readdir(this.backupDir);<br>
      const backups = [];</p><p>      for (const file of files) {<br>
        if (file.startsWith('backup-') &amp;&amp; file.endsWith('.json')) {<br>
          const stat = await fs.stat(path.join(this.backupDir, file));<br>
          backups.push({<br>
            filename: file,<br>
            size: stat.size,<br>
            created: stat.mtime,<br>
          });<br>
        }<br>
      }</p><p>      return backups.sort((a, b) =&gt; b.created.getTime() - a.created.getTime());<br>
    } catch {<br>
      return [];<br>
    }<br>
  }</p><p>  /**<br>
   * Delete old backups (keep last N)<br>
   */<br>
  async pruneBackups(keepCount: number = 10): Promise&lt;number&gt; {<br>
    const backups = await this.listBackups();<br>
    const toDelete = backups.slice(keepCount);</p><p>    for (const backup of toDelete) {<br>
      await fs.unlink(path.join(this.backupDir, backup.filename));<br>
    }</p><p>    return toDelete.length;<br>
  }<br>
}</p><p>export const backupService = new BackupService();</code></pre><h2>Scheduled Backups</h2><p>Add backup to the scheduler:</p><pre><code class="language-typescript">// src/services/scheduler-service.ts (extended)</p><p>import { backupService } from './backup-service.js';</p><p>export class SchedulerService {<br>
  // ... existing code ...</p><p>  /**<br>
   * Start backup scheduler<br>
   */<br>
  startBackupScheduler(intervalHours: number = 24): void {<br>
    // Run immediately<br>
    this.runBackup();</p><p>    // Then on interval<br>
    setInterval(<br>
      () =&gt; this.runBackup(),<br>
      intervalHours <em> 60 </em> 60 * 1000<br>
    );<br>
  }</p><p>  private async runBackup(): Promise&lt;void&gt; {<br>
    try {<br>
      console.log('Creating backup...');<br>
      const filepath = await backupService.createBackup();<br>
      console.log(<code>Backup created: ${filepath}</code>);</p><p>      // Prune old backups<br>
      const deleted = await backupService.pruneBackups(10);<br>
      if (deleted &gt; 0) {<br>
        console.log(<code>Pruned ${deleted} old backups</code>);<br>
      }<br>
    } catch (error) {<br>
      console.error('Backup failed:', error);<br>
    }<br>
  }<br>
}</code></pre><h2>Backup API</h2><pre><code class="language-typescript">// src/api/routes/backup.ts<br>
import { Router } from 'express';<br>
import { backupService } from '../../services/backup-service.js';</p><p>export const backupRouter = Router();</p><p>// List backups<br>
backupRouter.get('/', async (_req, res, next) =&gt; {<br>
  try {<br>
    const backups = await backupService.listBackups();<br>
    res.json(backups);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Create backup<br>
backupRouter.post('/', async (_req, res, next) =&gt; {<br>
  try {<br>
    const filepath = await backupService.createBackup();<br>
    res.json({ filepath });<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</p><p>// Download backup<br>
backupRouter.get('/:filename', async (req, res, next) =&gt; {<br>
  try {<br>
    const { filename } = req.params;</p><p>    // Validate filename<br>
    if (!filename.startsWith('backup-') || !filename.endsWith('.json')) {<br>
      res.status(400).json({ error: 'Invalid backup filename' });<br>
      return;<br>
    }</p><p>    res.download(<code>./backups/${filename}</code>);<br>
  } catch (error) {<br>
    next(error);<br>
  }<br>
});</code></pre><h2>Final Architecture</h2><pre><code class="language-">┌─────────────────────────────────────────────────────────────────┐<br>
│                        Browser (PWA)                             │<br>
│  ┌─────────────┐  ┌─────────────┐  ┌──────────────────────────┐ │<br>
│  │  Reader UI  │  │  TTS Player │  │    Offline Storage       │ │<br>
│  │             │  │             │  │    (IndexedDB)           │ │<br>
│  └─────────────┘  └─────────────┘  └──────────────────────────┘ │<br>
│                              │                                   │<br>
│                    Service Worker (Cache)                        │<br>
└─────────────────────────────────────────────────────────────────┘<br>
                              │<br>
                         HTTPS/WSS<br>
                              │<br>
┌─────────────────────────────────────────────────────────────────┐<br>
│                        Server                                    │<br>
│  ┌─────────────────────────────────────────────────────────┐   │<br>
│  │                     Express API                          │   │<br>
│  │  /feeds  /articles  /tags  /search  /tts  /backup       │   │<br>
│  └─────────────────────────────────────────────────────────┘   │<br>
│                              │                                   │<br>
│  ┌─────────────┐  ┌─────────────┐  ┌──────────────────────┐   │<br>
│  │ Feed Service│  │  TTS Service│  │   Backup Service     │   │<br>
│  │  (Scheduler)│  │ (Speechify) │  │                      │   │<br>
│  └─────────────┘  └─────────────┘  └──────────────────────┘   │<br>
│                              │                                   │<br>
│  ┌─────────────────────────────────────────────────────────┐   │<br>
│  │                     PostgreSQL                           │   │<br>
│  └─────────────────────────────────────────────────────────┘   │<br>
└─────────────────────────────────────────────────────────────────┘</code></pre><h2>What You've Built</h2><p>A complete personal reading library with:</p><p>- <strong>RSS feed management</strong> - Subscribe, fetch, organize<br>
- <strong>Content extraction</strong> - Clean articles from any URL<br>
- <strong>Beautiful reader</strong> - Typography, dark mode, progress tracking<br>
- <strong>Text-to-speech</strong> - Browser native + premium services<br>
- <strong>Organization</strong> - Tags, reading lists, full-text search<br>
- <strong>Offline support</strong> - Service worker + IndexedDB<br>
- <strong>Self-hosted</strong> - Docker deployment, backups</p><h2>Going Further</h2><p>Ideas for extending your library:</p><p>- <strong>Browser extension</strong> - Save articles from any page<br>
- <strong>Email integration</strong> - Forward newsletters to your library<br>
- <strong>Pocket/Instapaper import</strong> - Migrate existing collections<br>
- <strong>Kindle export</strong> - Send articles to your e-reader<br>
- <strong>Social features</strong> - Share reading lists with friends<br>
- <strong>AI summaries</strong> - Generate article summaries with Claude<br>
- <strong>Spaced repetition</strong> - Review highlights and notes</p><p>The foundation is solid. Build what you need.<br>
</p>
    </section>
  
    </main>

    <footer>
      <p>Generated with <a href="https://claude.ai/code">Claude Code</a> | <a href="https://github.com/bedwards/metavibe">View source</a></p>
    </footer>
  </div>
</body>
</html>